diff --git a/lib/bbcloud/vendor/excon-0.2.4/Gemfile b/lib/bbcloud/vendor/excon-0.2.4/Gemfile
new file mode 100644
index 0000000..209c4ad
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/Gemfile
@@ -0,0 +1,11 @@
+source "http://rubygems.org"
+
+group :test do
+  gem "shindo"
+  gem "tach"
+
+  gem "sinatra"
+  gem "rake"
+  gem "mongrel"
+  gem "open4"
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/README.rdoc b/lib/bbcloud/vendor/excon-0.2.4/README.rdoc
new file mode 100644
index 0000000..b33e3de
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/README.rdoc
@@ -0,0 +1,57 @@
+= excon
+
+Http(s) EXtended CONnections
+
+== Getting Started
+
+  sudo gem install excon
+
+Now you are ready to get started, easiest is to use one off requests to start.
+
+  Excon.get('http://geemus.com')
+
+This will return a response object, which has body, headers and status attributes you can check out.
+
+This supports all the major http verbs: [connect, delete, get, head, options, post, put, trace]
+
+You can also create a connection to try and keep open across multiple requests.
+
+  connection = Excon.new('http://geemus.com')
+  connection.request(:method => 'GET')
+
+You can also specify more complicated options to either style of call
+
+  Excon.get('http://geemus.com', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+  # or
+  connection.request(:method => 'GET', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+
+If you need to do something special with a response you can also pass a block that will be called with each chunk.
+
+  Excon.get('http://geemus.com') {|chunk| p chunk }
+
+From there you should be able to make just about any request you might need.
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/excon-0.2.4/Rakefile b/lib/bbcloud/vendor/excon-0.2.4/Rakefile
new file mode 100644
index 0000000..5f393c8
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/Rakefile
@@ -0,0 +1,147 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+require 'rake/testtask'
+Rake::TestTask.new(:test) do |test|
+  test.libs << 'lib' << 'test'
+  test.pattern = 'test/**/test_*.rb'
+  test.verbose = true
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/benchmarks/excon_vs.rb b/lib/bbcloud/vendor/excon-0.2.4/benchmarks/excon_vs.rb
new file mode 100644
index 0000000..f10d3bc
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/benchmarks/excon_vs.rb
@@ -0,0 +1,39 @@
+require File.join(File.dirname(__FILE__), '..', 'lib/excon')
+
+require 'benchmark'
+require 'net/http'
+require 'open-uri'
+
+COUNT = 100
+data = "Content-Length: 100"
+Benchmark.bmbm(25) do |bench|
+  bench.report('excon') do
+    COUNT.times do
+      Excon.new('http://www.google.com').request(:method => 'GET', :path => '/')
+    end
+  end
+  bench.report('excon (persistent)') do
+    excon = Excon.new('http://www.google.com')
+    COUNT.times do
+      excon.request(:method => 'GET', :path => '/')
+    end
+  end
+  bench.report('net/http') do
+    COUNT.times do
+      # Net::HTTP.get('www.google.com', '/')
+      Net::HTTP.start('www.google.com') {|http| http.get('/') }
+    end
+  end
+  bench.report('net/http (persistent)') do
+    Net::HTTP.start('www.google.com', 80) do |http|
+      COUNT.times do
+        http.get('/')
+      end
+    end
+  end
+  bench.report('open-uri') do
+    COUNT.times do
+      open('http://www.google.com/').read
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/benchmarks/headers_split_vs_match.rb b/lib/bbcloud/vendor/excon-0.2.4/benchmarks/headers_split_vs_match.rb
new file mode 100644
index 0000000..77f4b75
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/benchmarks/headers_split_vs_match.rb
@@ -0,0 +1,47 @@
+# require 'benchmark'
+
+# COUNT = 1_000_000
+# data = "Content-Length: 100"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('regex') do
+#     COUNT.times do
+#       header = data.match(/(.*):\s(.*)/)
+#     end
+#   end
+#   bench.report('split') do
+#     COUNT.times do
+#       header = data.split(': ')
+#     end
+#   end
+# end
+
+# Rehearsal ------------------------------------------------------------
+# regex                      4.270000   0.010000   4.280000 (  4.294186)
+# split                      3.870000   0.000000   3.870000 (  3.885645)
+# --------------------------------------------------- total: 8.150000sec
+# 
+#                                user     system      total        real
+# regex                      4.260000   0.010000   4.270000 (  4.284764)
+# split                      3.860000   0.010000   3.870000 (  3.882795)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100"
+Tach.meter(1_000_000) do
+  tach('regex') do
+    data.match(/(.*):\s(.*)/)
+    header = [$1, $2]
+  end
+  tach('split') do
+    header = data.split(': ')
+  end
+end
+
+# +-------+----------+----------+
+# | tach  | average  | total    |
+# +-------+----------+----------+
+# | regex | 4.680451 | 4.680451 |
+# +-------+----------+----------+
+# | split | 4.393218 | 4.393218 |
+# +-------+----------+----------+
diff --git a/lib/bbcloud/vendor/excon-0.2.4/benchmarks/strip_newline.rb b/lib/bbcloud/vendor/excon-0.2.4/benchmarks/strip_newline.rb
new file mode 100644
index 0000000..88a964f
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/benchmarks/strip_newline.rb
@@ -0,0 +1,115 @@
+# require 'benchmark'
+# 
+# COUNT = 1_000_000
+# data = "Content-Length: 100\r\n"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('chomp') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp
+#     end
+#   end
+#   bench.report('chomp!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp!
+#     end
+#   end
+#   bench.report('chop') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop
+#     end
+#   end
+#   bench.report('chop!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop!
+#     end
+#   end
+#   bench.report('strip') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip
+#     end
+#   end
+#   bench.report('strip!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip!
+#     end
+#   end
+#   bench.report('index') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data[0..-3]
+#     end
+#   end
+# end
+
+
+
+# Rehearsal ------------------------------------------------------------
+# chomp                      0.640000   0.000000   0.640000 (  0.644043)
+# chomp!                     0.530000   0.000000   0.530000 (  0.531415)
+# chop                       0.620000   0.000000   0.620000 (  0.624321)
+# chop!                      0.500000   0.000000   0.500000 (  0.509146)
+# strip                      0.640000   0.000000   0.640000 (  0.638785)
+# strip!                     0.530000   0.000000   0.530000 (  0.532196)
+# index                      0.740000   0.000000   0.740000 (  0.745742)
+# --------------------------------------------------- total: 4.200000sec
+# 
+#                                user     system      total        real
+# chomp                      0.640000   0.010000   0.650000 (  0.647287)
+# chomp!                     0.530000   0.000000   0.530000 (  0.532868)
+# chop                       0.630000   0.000000   0.630000 (  0.628236)
+# chop!                      0.520000   0.000000   0.520000 (  0.522950)
+# strip                      0.640000   0.000000   0.640000 (  0.646328)
+# strip!                     0.520000   0.000000   0.520000 (  0.532715)
+# index                      0.740000   0.010000   0.750000 (  0.771277)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100\r\n"
+Tach.meter(1_000_000) do
+  tach('chomp') do
+    data.dup.chomp
+  end
+  tach('chomp!') do
+    data.dup.chomp!
+  end
+  tach('chop') do
+    data.dup.chop
+  end
+  tach('chop!') do
+    data.dup.chop!
+  end
+  tach('strip') do
+    data.dup.strip
+  end
+  tach('strip!') do
+    data.dup.strip!
+  end
+  tach('index') do
+    data.dup[0..-3]
+  end
+end
+
+# +--------+----------+----------+
+# | tach   | average  | total    |
+# +--------+----------+----------+
+# | chomp  | 1.444547 | 1.444547 |
+# +--------+----------+----------+
+# | chomp! | 1.276813 | 1.276813 |
+# +--------+----------+----------+
+# | chop   | 1.422744 | 1.422744 |
+# +--------+----------+----------+
+# | chop!  | 1.240941 | 1.240941 |
+# +--------+----------+----------+
+# | strip  | 1.444776 | 1.444776 |
+# +--------+----------+----------+
+# | strip! | 1.266459 | 1.266459 |
+# +--------+----------+----------+
+# | index  | 1.557975 | 1.557975 |
+# +--------+----------+----------+
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/excon-0.2.4/excon.gemspec b/lib/bbcloud/vendor/excon-0.2.4/excon.gemspec
new file mode 100644
index 0000000..6c75a0b
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/excon.gemspec
@@ -0,0 +1,82 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'excon'
+  s.version           = '0.2.4'
+  s.date              = '2010-10-11'
+  s.rubyforge_project = 'excon'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "speed, persistence, http(s)"
+  s.description = "EXtended http(s) CONnections"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    benchmarks/excon_vs.rb
+    benchmarks/headers_split_vs_match.rb
+    benchmarks/strip_newline.rb
+    excon.gemspec
+    lib/excon.rb
+    lib/excon/connection.rb
+    lib/excon/errors.rb
+    lib/excon/response.rb
+    tests/config.ru
+    tests/test_helper.rb
+    tests/threaded_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/lib/excon.rb b/lib/bbcloud/vendor/excon-0.2.4/lib/excon.rb
new file mode 100644
index 0000000..b29e060
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/lib/excon.rb
@@ -0,0 +1,36 @@
+__DIR__ = File.dirname(__FILE__)
+
+$LOAD_PATH.unshift __DIR__ unless
+  $LOAD_PATH.include?(__DIR__) ||
+  $LOAD_PATH.include?(File.expand_path(__DIR__))
+
+require 'cgi'
+require 'openssl'
+require 'socket'
+require 'uri'
+
+require 'excon/connection'
+require 'excon/errors'
+require 'excon/response'
+
+module Excon
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.2.4'
+  end
+
+  CHUNK_SIZE = 1048576 # 1 megabyte
+
+  def self.new(url, params = {})
+    Excon::Connection.new(url, params)
+  end
+
+  %w{connect delete get head options post put trace}.each do |method|
+    eval <<-DEF
+      def self.#{method}(url, params = {}, &block)
+        new(url).request(params.merge!(:method => '#{method.upcase}'), &block)
+      end
+    DEF
+  end
+
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/lib/excon/connection.rb b/lib/bbcloud/vendor/excon-0.2.4/lib/excon/connection.rb
new file mode 100644
index 0000000..9ca9262
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/lib/excon/connection.rb
@@ -0,0 +1,132 @@
+module Excon
+  class Connection
+
+    def initialize(url, params = {})
+      uri = URI.parse(url)
+      @connection = {
+        :headers  => {},
+        :host     => uri.host,
+        :path     => uri.path,
+        :port     => uri.port,
+        :query    => uri.query,
+        :scheme   => uri.scheme
+      }.merge!(params)
+    end
+
+    def request(params, &block)
+      begin
+        params[:path] ||= @connection[:path]
+        unless params[:path][0..0] == '/'
+          params[:path] = "/#{params[:path]}"
+        end
+        request = "#{params[:method].upcase} #{params[:path]}?"
+        for key, values in (params[:query] || @connection[:query] || {})
+          for value in [*values]
+            request << "#{key}#{value && "=#{CGI.escape(value.to_s)}"}&"
+          end
+        end
+        request.chop!
+        request << " HTTP/1.1\r\n"
+        params[:headers] ||= @connection[:headers]
+        params[:headers]['Host'] ||= params[:host] || @connection[:host]
+        params[:body] ||= @connection[:body]
+        params[:headers]['Content-Length'] = case params[:body]
+        when File
+          params[:body].binmode
+          File.size(params[:body].path)
+        when String
+          if params[:body].respond_to?(:force_encoding)
+            params[:body].force_encoding('BINARY')
+          end
+          params[:body].length
+        else
+          0
+        end
+        for key, value in params[:headers]
+          request << "#{key}: #{value}\r\n"
+        end
+        request << "\r\n"
+        socket.write(request)
+
+        if params[:body]
+          if params[:body].is_a?(String)
+            socket.write(params[:body])
+          else
+            while chunk = params[:body].read(CHUNK_SIZE)
+              socket.write(chunk)
+            end
+          end
+        end
+
+        response = Excon::Response.parse(socket, params, &block)
+        if response.headers['Connection'] == 'close'
+          reset
+        end
+        response
+      rescue => socket_error
+        reset
+        raise(socket_error)
+      end
+
+      if params[:expects] && ![*params[:expects]].include?(response.status)
+        reset
+        raise(Excon::Errors.status_error(params, response))
+      else
+        response
+      end
+
+    rescue => request_error
+      if params[:idempotent] &&
+          (!request_error.is_a?(Excon::Errors::Error) || response.status != 404)
+        retries_remaining ||= 4
+        retries_remaining -= 1
+        if retries_remaining > 0
+          retry
+        else
+          raise(request_error)
+        end
+      else
+        raise(request_error)
+      end
+    end
+
+    def reset
+      (old_socket = sockets.delete(socket_key)) && old_socket.close
+    end
+
+    private
+
+    def connect
+      new_socket = TCPSocket.open(@connection[:host], @connection[:port])
+
+      if @connection[:scheme] == 'https'
+        @ssl_context = OpenSSL::SSL::SSLContext.new
+        @ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
+        new_socket = OpenSSL::SSL::SSLSocket.new(new_socket, @ssl_context)
+        new_socket.sync_close = true
+        new_socket.connect
+      end
+
+      new_socket
+    end
+
+    def closed?
+      sockets[socket_key] && sockets[socket_key].closed?
+    end
+
+    def socket
+      if closed?
+        reset
+      end
+      sockets[socket_key] ||= connect
+    end
+
+    def sockets
+      Thread.current[:_excon_sockets] ||= {}
+    end
+
+    def socket_key
+      "#{@connection[:host]}:#{@connection[:port]}"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/lib/excon/errors.rb b/lib/bbcloud/vendor/excon-0.2.4/lib/excon/errors.rb
new file mode 100644
index 0000000..0147862
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/lib/excon/errors.rb
@@ -0,0 +1,104 @@
+module Excon
+
+  module Errors
+    class Error < StandardError
+      attr_reader :request, :response
+
+      def initialize(msg, request = nil, response = nil)
+        super(msg)
+        @request = request
+        @response = response
+      end
+    end
+
+    class Continue < Error; end                     # 100
+    class SwitchingProtocols < Error; end           # 101
+    class OK < Error; end                           # 200
+    class Created < Error; end                      # 201
+    class Accepted < Error; end                     # 202
+    class NonAuthoritativeInformation < Error; end  # 203
+    class NoContent < Error; end                    # 204
+    class ResetContent < Error; end                 # 205
+    class PartialContent < Error; end               # 206
+    class MultipleChoices < Error; end              # 300
+    class MovedPermanently < Error; end             # 301
+    class Found < Error; end                        # 302
+    class SeeOther < Error; end                     # 303
+    class NotModified < Error; end                  # 304
+    class UseProxy < Error; end                     # 305
+    class TemporaryRedirect < Error; end            # 307
+    class BadRequest < Error; end                   # 400
+    class Unauthorized < Error; end                 # 401
+    class PaymentRequired < Error; end              # 402
+    class Forbidden < Error; end                    # 403
+    class NotFound < Error; end                     # 404
+    class MethodNotAllowed < Error; end             # 405
+    class NotAcceptable < Error; end                # 406
+    class ProxyAuthenticationRequired < Error; end  # 407
+    class RequestTimeout < Error; end               # 408
+    class Conflict < Error; end                     # 409
+    class Gone < Error; end                         # 410
+    class LengthRequired < Error; end               # 411
+    class PreconditionFailed < Error; end           # 412
+    class RequestEntityTooLarge < Error; end        # 412
+    class RequestURITooLong < Error; end            # 414
+    class UnsupportedMediaType < Error; end         # 415
+    class RequestedRangeNotSatisfiable < Error; end # 416
+    class ExpectationFailed < Error; end            # 417
+    class UnprocessableEntity < Error; end          # 422
+    class InternalServerError < Error; end          # 500
+    class NotImplemented < Error; end               # 501
+    class BadGateway < Error; end                   # 502
+    class ServiceUnavailable < Error; end           # 503
+    class GatewayTimeout < Error; end               # 504
+
+    # Messages for nicer exceptions, from rfc2616
+    def self.status_error(request, response)
+      @errors ||= { 
+        100 => [Excon::Errors::Continue, 'Continue'],
+        101 => [Excon::Errors::SwitchingProtocols, 'Switching Protocols'],
+        200 => [Excon::Errors::OK, 'OK'],
+        201 => [Excon::Errors::Created, 'Created'],
+        202 => [Excon::Errors::Accepted, 'Accepted'],
+        203 => [Excon::Errors::NonAuthoritativeInformation, 'Non-Authoritative Information'],
+        204 => [Excon::Errors::NoContent, 'No Content'],
+        205 => [Excon::Errors::ResetContent, 'Reset Content'],
+        206 => [Excon::Errors::PartialContent, 'Partial Content'],
+        300 => [Excon::Errors::MultipleChoices, 'Multiple Choices'],
+        301 => [Excon::Errors::MovedPermanently, 'Moved Permanently'],
+        302 => [Excon::Errors::Found, 'Found'],
+        303 => [Excon::Errors::SeeOther, 'See Other'],
+        304 => [Excon::Errors::NotModified, 'Not Modified'],
+        305 => [Excon::Errors::UseProxy, 'Use Proxy'],
+        307 => [Excon::Errors::TemporaryRedirect, 'Temporary Redirect'],
+        400 => [Excon::Errors::BadRequest, 'Bad Request'],
+        401 => [Excon::Errors::Unauthorized, 'Unauthorized'],
+        402 => [Excon::Errors::PaymentRequired, 'Payment Required'],
+        403 => [Excon::Errors::Forbidden, 'Forbidden'],
+        404 => [Excon::Errors::NotFound, 'Not Found'],
+        405 => [Excon::Errors::MethodNotAllowed, 'Method Not Allowed'],
+        406 => [Excon::Errors::NotAcceptable, 'Not Acceptable'],
+        407 => [Excon::Errors::ProxyAuthenticationRequired, 'Proxy Authentication Required'],
+        408 => [Excon::Errors::RequestTimeout, 'Request Timeout'],
+        409 => [Excon::Errors::Conflict, 'Conflict'],
+        410 => [Excon::Errors::Gone, 'Gone'],
+        411 => [Excon::Errors::LengthRequired, 'Length Required'],
+        412 => [Excon::Errors::PreconditionFailed, 'Precondition Failed'],
+        413 => [Excon::Errors::RequestEntityTooLarge, 'Request Entity Too Large'],
+        414 => [Excon::Errors::RequestURITooLong, 'Request-URI Too Long'],
+        415 => [Excon::Errors::UnsupportedMediaType, 'Unsupported Media Type'],
+        416 => [Excon::Errors::RequestedRangeNotSatisfiable, 'Request Range Not Satisfiable'],
+        417 => [Excon::Errors::ExpectationFailed, 'Expectation Failed'],
+        422 => [Excon::Errors::UnprocessableEntity, 'Unprocessable Entity'],
+        500 => [Excon::Errors::InternalServerError, 'InternalServerError'],
+        501 => [Excon::Errors::NotImplemented, 'Not Implemented'],
+        502 => [Excon::Errors::BadGateway, 'Bad Gateway'],
+        503 => [Excon::Errors::ServiceUnavailable, 'Service Unavailable'],
+        504 => [Excon::Errors::GatewayTimeout, 'Gateway Timeout']
+      }
+      error, message = @errors[response.status] || [Excon::Errors::Error, 'Unknown']
+      error.new("Expected(#{request[:expects].inspect}) <=> Actual(#{response.status} #{message})\n  request => #{request.inspect}\n  response => #{response.inspect}", request, response)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/lib/excon/response.rb b/lib/bbcloud/vendor/excon-0.2.4/lib/excon/response.rb
new file mode 100644
index 0000000..49f7efc
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/lib/excon/response.rb
@@ -0,0 +1,62 @@
+module Excon
+  class Response
+
+    def self.parse(socket, params = {}, &block)
+      if params[:block]
+        print "  \e[33m[WARN] params[:block] is deprecated, please pass the block to the request\e[0m"
+        block = params[:block]
+      end
+
+      response = new
+
+      response.status = socket.readline[9..11].to_i
+      while true
+        data = socket.readline.chop!
+        unless data.empty?
+          key, value = data.split(': ')
+          response.headers[key] = value
+        else
+          break
+        end
+      end
+
+      unless params[:method] == 'HEAD'
+        if !block || (params[:expects] && ![*params[:expects]].include?(response.status))
+          response.body = ''
+          block = lambda { |chunk| response.body << chunk }
+        end
+
+        if response.headers['Transfer-Encoding'] && response.headers['Transfer-Encoding'].downcase == 'chunked'
+          while true
+            chunk_size = socket.readline.chop!.to_i(16)
+            chunk = socket.read(chunk_size + 2).chop! # 2 == "/r/n".length
+            if chunk_size > 0
+              block.call(chunk)
+            else
+              break
+            end
+          end
+        elsif response.headers['Connection'] && response.headers['Connection'].downcase == 'close'
+          block.call(socket.read)
+        elsif response.headers['Content-Length']
+          remaining = response.headers['Content-Length'].to_i
+          while remaining > 0
+            block.call(socket.read([CHUNK_SIZE, remaining].min))
+            remaining -= CHUNK_SIZE
+          end
+        end
+      end
+
+      response
+    end
+
+    attr_accessor :body, :headers, :status
+
+    def initialize(attributes = {})
+      @body    = attributes[:body] || ''
+      @headers = attributes[:headers] || {}
+      @status  = attributes[:status]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/tests/config.ru b/lib/bbcloud/vendor/excon-0.2.4/tests/config.ru
new file mode 100644
index 0000000..2fa5581
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/tests/config.ru
@@ -0,0 +1,10 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get '/id/:id/wait/:wait' do |id, wait|
+    sleep wait.to_i
+    id.to_s
+  end
+end
+
+run App
diff --git a/lib/bbcloud/vendor/excon-0.2.4/tests/test_helper.rb b/lib/bbcloud/vendor/excon-0.2.4/tests/test_helper.rb
new file mode 100644
index 0000000..e709e52
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/tests/test_helper.rb
@@ -0,0 +1,15 @@
+require File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib/excon'))
+
+require 'open4'
+
+def local_file(*parts)
+  File.expand_path(File.join(File.dirname(__FILE__), *parts))
+end
+
+def with_rackup(configru = local_file('config.ru'))
+  pid, w, r, e = Open4.popen4("rackup #{configru}")
+  while `lsof -p #{pid} -P -i | grep ruby | grep TCP`.chomp.empty?; end
+  yield
+ensure
+  Process.kill(9, pid)
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.4/tests/threaded_tests.rb b/lib/bbcloud/vendor/excon-0.2.4/tests/threaded_tests.rb
new file mode 100644
index 0000000..6f102b6
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.4/tests/threaded_tests.rb
@@ -0,0 +1,24 @@
+require File.expand_path(File.join(File.dirname(__FILE__), 'test_helper'))
+
+with_rackup do
+  Shindo.tests do
+    test('threaded requests') do
+      connection = Excon.new('http://127.0.0.1:9292')
+
+      long_thread = Thread.new {
+        response = connection.request(:method => 'GET', :path => '/id/1/wait/2')
+        Thread.current[:success] = response.body == '1'
+      }
+
+      short_thread = Thread.new {
+        response = connection.request(:method => 'GET', :path => '/id/2/wait/1')
+        Thread.current[:success] = response.body == '2'
+      }
+
+      long_thread.join
+      short_thread.join
+
+      long_thread[:success] && short_thread[:success]
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/.document b/lib/bbcloud/vendor/fog-brightbox/.document
new file mode 100644
index 0000000..2a5f665
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/.document
@@ -0,0 +1,3 @@
+README.rdoc
+lib/**/*.rb
+bin/*
diff --git a/lib/bbcloud/vendor/fog-brightbox/.gitignore b/lib/bbcloud/vendor/fog-brightbox/.gitignore
new file mode 100644
index 0000000..26f7bd6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/.gitignore
@@ -0,0 +1,8 @@
+*.sw?
+.DS_Store
+coverage
+rdoc
+pkg
+spec/credentials.yml
+.bundle
+*.gem
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/Gemfile b/lib/bbcloud/vendor/fog-brightbox/Gemfile
new file mode 100644
index 0000000..c80ee36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/Gemfile
@@ -0,0 +1,3 @@
+source "http://rubygems.org"
+
+gemspec
diff --git a/lib/bbcloud/vendor/fog-brightbox/Gemfile.lock b/lib/bbcloud/vendor/fog-brightbox/Gemfile.lock
new file mode 100644
index 0000000..dbd4ef5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/Gemfile.lock
@@ -0,0 +1,48 @@
+PATH
+  remote: .
+  specs:
+    fog (0.3.1)
+      builder
+      excon (>= 0.2.1)
+      formatador (>= 0.0.15)
+      json
+      mime-types
+      net-ssh (~> 2.0.23)
+      nokogiri (~> 1.4.3.1)
+      ruby-hmac
+
+GEM
+  remote: http://rubygems.org/
+  specs:
+    builder (2.1.2)
+    excon (0.2.1)
+    formatador (0.0.15)
+    gestalt (0.0.11)
+      formatador (>= 0.0.12)
+    json (1.4.6)
+    mime-types (1.16)
+    net-ssh (2.0.23)
+    nokogiri (1.4.3.1)
+    rake (0.8.7)
+    rspec (1.3.0)
+    ruby-hmac (0.4.0)
+    shindo (0.1.6)
+      formatador (>= 0.0.14)
+      gestalt (>= 0.0.11)
+
+PLATFORMS
+  ruby
+
+DEPENDENCIES
+  builder
+  excon (>= 0.2.1)
+  fog!
+  formatador (>= 0.0.15)
+  json
+  mime-types
+  net-ssh (~> 2.0.23)
+  nokogiri (~> 1.4.3.1)
+  rake
+  rspec
+  ruby-hmac
+  shindo (= 0.1.6)
diff --git a/lib/bbcloud/vendor/fog-brightbox/README.rdoc b/lib/bbcloud/vendor/fog-brightbox/README.rdoc
new file mode 100644
index 0000000..c51fc58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/README.rdoc
@@ -0,0 +1,141 @@
+http://geemus.com/fog.png
+
+fog is the Ruby cloud computing library.
+
+The quick and dirty, top to bottom:
+* Collections provide a simplified interface, making clouds easier to work with and switch between.
+* Requests allow power users to get the most out of the features of each individual cloud.
+* Mocks make testing and integrating a breeze.
+
+Put them together and you get a great cloud computing experience, but we are getting ahead of ourselves...
+
+== Getting Started
+
+  sudo gem install fog
+
+Now just type 'fog' to trying stuff out, confident that fog should let you know what you need to do. Here is an example of wading through server creation for Amazon Elastic Compute Cloud:
+
+  >> server = AWS.servers.create
+  ArgumentError: image_id is required for this operation
+  >> server = AWS.servers.create(:image_id => 'ami-5ee70037')
+  <Fog::AWS::EC2::Server [...]>
+  >> server.destroy # cleanup after yourself or regret it, trust me
+  true
+
+== Collections
+
+A high level interface to each cloud is provided through collections, such as images and servers.
+You can see a list of available collections by calling #collections on the connection object.
+Some of these collections are shared across multiple providers.
+Shared collections for compute are: flavors, images and servers.
+Shared collections for storage are: directory and file.
+
+Some common methods for all of these collections are:
+* #all - fetch every object of that type from the provider.
+* #create  initialize a new record locally and then persists it with the provider.
+* #get - fetch a single object by its identity from the provider.
+* #new - initialize a new record locally, but do not persist it to the provider.
+
+As an example, we'll try initializing and persisting a Rackspace Cloud server:
+
+  require 'fog'
+
+  # initialize a connection to Rackspace Cloud Servers
+  connection = Fog::Rackspace::Servers.new(
+    :rackspace_api_key => key,
+    :rackspace_username => username
+  )
+
+  # boot a gentoo server (flavor 1 = 256, image 3 = gentoo 2008.0)
+  server = connection.servers.create(:flavor_id => 1, :image_id => 3, :name => 'my_server')
+
+  # wait for it to be ready to do stuff
+  server.wait_for { ready? }
+
+  # DO STUFF
+
+  # shutdown the server
+  server.destroy
+
+== Models
+
+Many of the collection methods return individual objects, which also provide some common methods:
+* #destroy - will destroy the persisted object from the provider
+* #save - persist the object to the provider
+* #wait_for - takes a block and waits for either the block to return true for the object or for a timeout (defaults to 10 minutes)
+
+== Mocks
+
+Mocking provides an in memory representation of the state of cloud resources as you make requests.
+Mocked calls to mimic the behavior of each provider while eliminating the cost and time needed to actually use cloud resources.
+Enabling mocking easy to use, before you run any other commands run:
+
+  Fog.mock!
+
+Then you can run other commands just like you always would.
+Some mocks are not implemented just yet, but fog will raise an error to let you know and contributions are always welcome!
+
+== Requests
+
+Requests allow you to dive deeper when the models just can't cut it.
+You can see a list of available requests by calling #requests on the connection object.
+For instance, ec2 provides methods related to reserved instances that don't have any models (yet).
+Here is how you can lookup your reserved instances:
+
+  $ fog
+  >> AWS[:ec2].describe_reserved_instances
+  #<Excon::Response [...]>
+
+It will return an {excon}[http://github.com/geemus/excon] response, which has #headers and #body. Both return nice hashes.
+
+== Go forth and conquer
+
+Play around and use the console to explore or check out the {getting started guide}[http://wiki.github.com/geemus/fog/getting-started-with-fog] for more details.
+
+You should try out the (varying) support fog has for:
+* {AWS}[http://aws.amazon.com] [{EC2}[http://aws.amazon.com/ec2], {ELB}[http://aws.amazon.com/elasticloadbalancing], {S3}[http://aws.amazon.com/s3], {SimpleDB}[http://aws.amazon.com/simpledb]]
+* {Blue Box Group}[http://www.blueboxgrp.com] [{Blocks}[http://www.blueboxgrp.com/blocks]]
+* {Rackspace}[http://www.rackspace.com] [{Files}[http://www.rackspacecloud.com/cloud_hosting_products/files], {Servers}[http://www.rackspacecloud.com/cloud_hosting_products/servers]]
+* {Slicehost}[http://www.slicehost.com]
+* {Terremark}[http://www.terremark.com] [{vCloud Express}[http://vcloudexpress.terremark.com]]
+
+There are also the basics of these providers (that could use your love):
+* {GoGrid}[http://www.gogrid.com]
+* {Linode}[http://www.linode.com]
+* Local [Files]
+* {New Servers}[http://www.newservers.com]
+
+Enjoy, and let me know what I can do to continue improving fog!
+
+* See what already uses fog and add your own stuff to {the list}[http://wiki.github.com/geemus/fog/in-the-wild].
+* Work for {twitter}[http://twitter.com]? I'd love to reclaim the unused {@fog}[http://twitter.com/fog] account!
+* Follow {@geemus}[http://twitter.com/geemus] on Twitter.
+* Discuss in irc on the {#ruby-fog}[irc://irc.freenode.net/ruby-fog]#ruby-fog channel on Freenode or via email on the {mailing list}[http://groups.google.com/group/ruby-fog].
+* See upcoming work in the {tracker}[http://www.pivotaltracker.com/projects/54635].
+* Report bugs in {issues}[http://github.com/geemus/fog/issues].
+* Learn about {contributing}[http://wiki.github.com/geemus/fog/contributors-guide].
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/fog-brightbox/Rakefile b/lib/bbcloud/vendor/fog-brightbox/Rakefile
new file mode 100644
index 0000000..042a8b8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/Rakefile
@@ -0,0 +1,146 @@
+require 'rubygems'
+require 'bundler/setup'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+task :test do
+  sh("export FOG_MOCK=true  && bundle exec spec -cfs spec") &&
+  sh("export FOG_MOCK=true  && bundle exec shindo tests") &&
+  sh("export FOG_MOCK=false && bundle exec spec -cfs spec") &&
+  sh("export FOG_MOCK=false && bundle exec shindo tests")
+end
+
+task :ci do
+  sh("export FOG_MOCK=true  && bundle exec spec spec") &&
+  sh("export FOG_MOCK=true  && bundle exec shindont tests") &&
+  sh("export FOG_MOCK=false && bundle exec spec spec") &&
+  sh("export FOG_MOCK=false && bundle exec shindont tests")
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/benchs/fog_vs.rb b/lib/bbcloud/vendor/fog-brightbox/benchs/fog_vs.rb
new file mode 100644
index 0000000..464d8df
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/benchs/fog_vs.rb
@@ -0,0 +1,106 @@
+require 'rubygems'
+require 'aws/s3'
+require 'benchmark'
+require 'right_aws'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+
+data = File.open(File.expand_path('~/.fog')).read
+config = YAML.load(data)[:default]
+fog = Fog::AWS::S3.new(
+  :aws_access_key_id     => config[:aws_access_key_id],
+  :aws_secret_access_key => config[:aws_secret_access_key]
+)
+raws = RightAws::S3Interface.new(
+  config[:aws_access_key_id],
+  config[:aws_secret_access_key]
+)
+raws.logger.level = 3 # ERROR
+awss3 = AWS::S3::Base.establish_connection!(
+  :access_key_id     => config[:aws_access_key_id],
+  :secret_access_key => config[:aws_secret_access_key],
+  :persistent        => true
+)
+
+TIMES = 10
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('fog.put_bucket') do
+    TIMES.times do |x|
+      fog.put_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.create_bucket') do
+    TIMES.times do |x|
+      raws.create_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.create') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.create("awss3bench#{x}")
+    end
+  end
+
+  bench.report('fog.put_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        fog.put_object("fogbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('raws.put') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        raws.put("rawsbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('awss3::S3Object.create') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        AWS::S3::S3Object.create("lorem_#{y}", file, "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        fog.delete_object("fogbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('raws.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        raws.delete("rawsbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('awss3::S3Object.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        AWS::S3::S3Object.delete("lorem_#{y}", "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_bucket') do
+    TIMES.times do |x|
+      fog.delete_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.delete_bucket') do
+    TIMES.times do |x|
+      raws.delete_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.delete') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.delete("awss3bench#{x}")
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/benchs/params.rb b/lib/bbcloud/vendor/fog-brightbox/benchs/params.rb
new file mode 100644
index 0000000..25674e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/benchs/params.rb
@@ -0,0 +1,43 @@
+require 'benchmark'
+
+def hash(options)
+  result = "#{options.delete(:name)}"
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+def optional(name, a = nil, b = nil, c = nil)
+  result = "#{name}"
+  options = { :a => a, :b => b, :c => c }
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+COUNT = 100_000
+data = "Content-Length: 100"
+Benchmark.bmbm(25) do |bench|
+  bench.report('hash') do
+    COUNT.times do
+      hash({:name => 'name'})
+    end
+  end
+  bench.report('optional') do
+    COUNT.times do
+      optional('name')
+    end
+  end
+  bench.report('hash_with_option') do
+    COUNT.times do
+      hash({:name => 'name', :a => 'a', :b => 'b', :c => 'c'})
+    end
+  end
+  bench.report('optional_with_option') do
+    COUNT.times do
+      optional('name', :a => 'a', :b => 'b', :c => 'c')
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/benchs/parse_vs_push.rb b/lib/bbcloud/vendor/fog-brightbox/benchs/parse_vs_push.rb
new file mode 100644
index 0000000..37d85e4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/benchs/parse_vs_push.rb
@@ -0,0 +1,60 @@
+require 'benchmark'
+require 'rubygems'
+require 'nokogiri'
+
+class Parser < Nokogiri::XML::SAX::Document
+
+  attr_reader :response
+
+  def initialize
+    reset
+  end
+
+  def reset
+    @item = {}
+    @response = { :items => [] }
+  end
+
+  def characters(string)
+    @value << string.strip
+  end
+
+  def start_element(name, attrs = [])
+    @value = nil
+  end
+
+  def end_element(name)
+    case name
+    when 'item'
+      @response[:items] << @item
+      @item = {}
+    when 'key'
+      @item[:key] = @value
+    end
+  end
+
+end
+
+data = <<-DATA
+<items>
+  <item>
+    <key>value</key>
+  </item>
+</items>
+DATA
+
+COUNT = 100
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('parse') do
+    parser = Parser.new
+    Nokogiri::XML::SAX::Parser.new(parser).parse(data)
+    parser.response
+  end
+
+  bench.report('push') do
+    parser = Parser.new
+    Nokogiri::XML::SAX::PushParser.new(parser).write(data, true)
+    parser.response
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/bin/fog b/lib/bbcloud/vendor/fog-brightbox/bin/fog
new file mode 100755
index 0000000..46cbe72
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/bin/fog
@@ -0,0 +1,44 @@
+#!/usr/bin/env ruby
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+require 'irb'
+require 'yaml'
+require File.join('fog', 'credentials')
+Fog.credential = ARGV.first ? ARGV.first.to_sym : nil
+Fog.bin = true
+unless Fog.credentials
+  exit
+end
+
+require 'fog/bin'
+
+if ARGV.length > 1
+  print(instance_eval(ARGV[1..-1].join(' ')).to_json)
+else
+
+  ARGV.clear # Avoid passing args to IRB
+  IRB.setup(nil)
+  @irb = IRB::Irb.new(nil)
+  IRB.conf[:MAIN_CONTEXT] = @irb.context
+  IRB.conf[:PROMPT][:FOG] = IRB.conf[:PROMPT][:SIMPLE].dup
+  IRB.conf[:PROMPT][:FOG][:RETURN] = "%s\n"
+  @irb.context.prompt_mode = :FOG
+  @irb.context.workspace = IRB::WorkSpace.new(binding)
+
+  providers = Fog.providers.map{|provider| provider.to_s}
+  providers = if providers.length > 1
+    providers[0...-1].join(', ') << ' and ' << providers[-1]
+  else
+    providers.first
+  end
+  Formatador.display_line('Welcome to fog interactive!')
+  Formatador.display_line(":#{Fog.credential.to_s} credentials provide #{providers}")
+  providers = Fog.providers
+  Fog.modules.each do |_module_|
+    if _module_.respond_to?(:startup_notice)
+      _module_.send(:startup_notice)
+    end
+  end
+
+  catch(:IRB_EXIT) { @irb.eval_input }
+
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/examples/bluebox_create.rb b/lib/bbcloud/vendor/fog-brightbox/examples/bluebox_create.rb
new file mode 100644
index 0000000..43c76ac
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/examples/bluebox_create.rb
@@ -0,0 +1,33 @@
+#!/usr/bin/env ruby
+
+# For example only - you'd want to use your own AMI id.
+unless defined?(GENTOO_AMI)
+  GENTOO_AMI = 'ami-5ee70037'
+end
+
+require 'rubygems'
+require 'fog'
+
+@bluebox_api_key = "CHANGEME"
+@aws_access_key_id = "CHANGEME"
+@aws_secret_access_key = "CHANGEME"
+
+@flavor_id = "94fd37a7-2606-47f7-84d5-9000deda52ae" # Block 1GB Virtual Server
+@image_id = "03807e08-a13d-44e4-b011-ebec7ef2c928"  # Ubuntu 10.04 x64 LTS
+
+# Grab our current list of servers
+@bbg_servers = Fog::Bluebox.new(:bluebox_api_key => @bluebox_api_key).servers
+@ec2_servers = Fog::AWS::EC2.new(:aws_access_key_id => @aws_access_key_id, :aws_secret_access_key => @aws_secret_access_key).servers
+
+# Create a new server.
+@server = @bbg_servers.new(:flavor_id => @flavor_id, :image_id => @image_id,
+                           :name => "My Server", :password => "MyPassword")
+
+# Save the server, triggering its creation
+@server.save
+
+if @server.status == 'error'
+  # The create failed - create a new server on Amazon instead
+  @server = @ec2_servers.new(:image_id => GENTOO_AMI)
+  @server.save
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/fog.gemspec b/lib/bbcloud/vendor/fog-brightbox/fog.gemspec
new file mode 100644
index 0000000..d4df8c9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/fog.gemspec
@@ -0,0 +1,703 @@
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'fog'
+  s.version           = '0.3.1'
+  s.date              = '2010-10-20'
+  s.rubyforge_project = 'fog'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "brings clouds to you"
+  s.description = "The Ruby cloud computing library."
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/fog'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  s.executables = ["fog"]
+  s.default_executable = 'fog'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  s.add_dependency('builder')
+  s.add_dependency('excon', '>=0.2.1')
+  s.add_dependency('formatador', '>=0.0.15')
+  s.add_dependency('json')
+  s.add_dependency('mime-types')
+  s.add_dependency('net-ssh', '~>2.0.23')
+  s.add_dependency('nokogiri', '~>1.4.3.1')
+  s.add_dependency('ruby-hmac')
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  s.add_development_dependency('rake')
+  s.add_development_dependency('rspec')
+  s.add_development_dependency('shindo', '0.1.6')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    Gemfile.lock
+    README.rdoc
+    Rakefile
+    benchs/fog_vs.rb
+    benchs/params.rb
+    benchs/parse_vs_push.rb
+    bin/fog
+    examples/bluebox_create.rb
+    fog.gemspec
+    lib/fog.rb
+    lib/fog/attributes.rb
+    lib/fog/aws.rb
+    lib/fog/aws/bin.rb
+    lib/fog/aws/compute.rb
+    lib/fog/aws/ec2.rb
+    lib/fog/aws/elb.rb
+    lib/fog/aws/models/compute/address.rb
+    lib/fog/aws/models/compute/addresses.rb
+    lib/fog/aws/models/compute/flavor.rb
+    lib/fog/aws/models/compute/flavors.rb
+    lib/fog/aws/models/compute/image.rb
+    lib/fog/aws/models/compute/images.rb
+    lib/fog/aws/models/compute/key_pair.rb
+    lib/fog/aws/models/compute/key_pairs.rb
+    lib/fog/aws/models/compute/security_group.rb
+    lib/fog/aws/models/compute/security_groups.rb
+    lib/fog/aws/models/compute/server.rb
+    lib/fog/aws/models/compute/servers.rb
+    lib/fog/aws/models/compute/snapshot.rb
+    lib/fog/aws/models/compute/snapshots.rb
+    lib/fog/aws/models/compute/volume.rb
+    lib/fog/aws/models/compute/volumes.rb
+    lib/fog/aws/models/storage/directories.rb
+    lib/fog/aws/models/storage/directory.rb
+    lib/fog/aws/models/storage/file.rb
+    lib/fog/aws/models/storage/files.rb
+    lib/fog/aws/parsers/compute/allocate_address.rb
+    lib/fog/aws/parsers/compute/attach_volume.rb
+    lib/fog/aws/parsers/compute/basic.rb
+    lib/fog/aws/parsers/compute/create_image.rb
+    lib/fog/aws/parsers/compute/create_key_pair.rb
+    lib/fog/aws/parsers/compute/create_snapshot.rb
+    lib/fog/aws/parsers/compute/create_volume.rb
+    lib/fog/aws/parsers/compute/deregister_image.rb
+    lib/fog/aws/parsers/compute/describe_addresses.rb
+    lib/fog/aws/parsers/compute/describe_availability_zones.rb
+    lib/fog/aws/parsers/compute/describe_images.rb
+    lib/fog/aws/parsers/compute/describe_instances.rb
+    lib/fog/aws/parsers/compute/describe_key_pairs.rb
+    lib/fog/aws/parsers/compute/describe_regions.rb
+    lib/fog/aws/parsers/compute/describe_reserved_instances.rb
+    lib/fog/aws/parsers/compute/describe_security_groups.rb
+    lib/fog/aws/parsers/compute/describe_snapshots.rb
+    lib/fog/aws/parsers/compute/describe_volumes.rb
+    lib/fog/aws/parsers/compute/detach_volume.rb
+    lib/fog/aws/parsers/compute/get_console_output.rb
+    lib/fog/aws/parsers/compute/import_key_pair.rb
+    lib/fog/aws/parsers/compute/register_image.rb
+    lib/fog/aws/parsers/compute/run_instances.rb
+    lib/fog/aws/parsers/compute/start_stop_instances.rb
+    lib/fog/aws/parsers/compute/terminate_instances.rb
+    lib/fog/aws/parsers/elb/create_load_balancer.rb
+    lib/fog/aws/parsers/elb/delete_load_balancer.rb
+    lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
+    lib/fog/aws/parsers/elb/describe_instance_health.rb
+    lib/fog/aws/parsers/elb/describe_load_balancers.rb
+    lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
+    lib/fog/aws/parsers/simpledb/basic.rb
+    lib/fog/aws/parsers/simpledb/domain_metadata.rb
+    lib/fog/aws/parsers/simpledb/get_attributes.rb
+    lib/fog/aws/parsers/simpledb/list_domains.rb
+    lib/fog/aws/parsers/simpledb/select.rb
+    lib/fog/aws/parsers/storage/access_control_list.rb
+    lib/fog/aws/parsers/storage/copy_object.rb
+    lib/fog/aws/parsers/storage/get_bucket.rb
+    lib/fog/aws/parsers/storage/get_bucket_location.rb
+    lib/fog/aws/parsers/storage/get_bucket_logging.rb
+    lib/fog/aws/parsers/storage/get_bucket_object_versions.rb
+    lib/fog/aws/parsers/storage/get_bucket_versioning.rb
+    lib/fog/aws/parsers/storage/get_request_payment.rb
+    lib/fog/aws/parsers/storage/get_service.rb
+    lib/fog/aws/requests/compute/allocate_address.rb
+    lib/fog/aws/requests/compute/associate_address.rb
+    lib/fog/aws/requests/compute/attach_volume.rb
+    lib/fog/aws/requests/compute/authorize_security_group_ingress.rb
+    lib/fog/aws/requests/compute/create_image.rb
+    lib/fog/aws/requests/compute/create_key_pair.rb
+    lib/fog/aws/requests/compute/create_security_group.rb
+    lib/fog/aws/requests/compute/create_snapshot.rb
+    lib/fog/aws/requests/compute/create_volume.rb
+    lib/fog/aws/requests/compute/delete_key_pair.rb
+    lib/fog/aws/requests/compute/delete_security_group.rb
+    lib/fog/aws/requests/compute/delete_snapshot.rb
+    lib/fog/aws/requests/compute/delete_volume.rb
+    lib/fog/aws/requests/compute/deregister_image.rb
+    lib/fog/aws/requests/compute/describe_addresses.rb
+    lib/fog/aws/requests/compute/describe_availability_zones.rb
+    lib/fog/aws/requests/compute/describe_images.rb
+    lib/fog/aws/requests/compute/describe_instances.rb
+    lib/fog/aws/requests/compute/describe_key_pairs.rb
+    lib/fog/aws/requests/compute/describe_regions.rb
+    lib/fog/aws/requests/compute/describe_reserved_instances.rb
+    lib/fog/aws/requests/compute/describe_security_groups.rb
+    lib/fog/aws/requests/compute/describe_snapshots.rb
+    lib/fog/aws/requests/compute/describe_volumes.rb
+    lib/fog/aws/requests/compute/detach_volume.rb
+    lib/fog/aws/requests/compute/disassociate_address.rb
+    lib/fog/aws/requests/compute/get_console_output.rb
+    lib/fog/aws/requests/compute/import_key_pair.rb
+    lib/fog/aws/requests/compute/modify_image_attributes.rb
+    lib/fog/aws/requests/compute/modify_snapshot_attribute.rb
+    lib/fog/aws/requests/compute/reboot_instances.rb
+    lib/fog/aws/requests/compute/register_image.rb
+    lib/fog/aws/requests/compute/release_address.rb
+    lib/fog/aws/requests/compute/revoke_security_group_ingress.rb
+    lib/fog/aws/requests/compute/run_instances.rb
+    lib/fog/aws/requests/compute/start_instances.rb
+    lib/fog/aws/requests/compute/stop_instances.rb
+    lib/fog/aws/requests/compute/terminate_instances.rb
+    lib/fog/aws/requests/elb/create_load_balancer.rb
+    lib/fog/aws/requests/elb/delete_load_balancer.rb
+    lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
+    lib/fog/aws/requests/elb/describe_instance_health.rb
+    lib/fog/aws/requests/elb/describe_load_balancers.rb
+    lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
+    lib/fog/aws/requests/simpledb/batch_put_attributes.rb
+    lib/fog/aws/requests/simpledb/create_domain.rb
+    lib/fog/aws/requests/simpledb/delete_attributes.rb
+    lib/fog/aws/requests/simpledb/delete_domain.rb
+    lib/fog/aws/requests/simpledb/domain_metadata.rb
+    lib/fog/aws/requests/simpledb/get_attributes.rb
+    lib/fog/aws/requests/simpledb/list_domains.rb
+    lib/fog/aws/requests/simpledb/put_attributes.rb
+    lib/fog/aws/requests/simpledb/select.rb
+    lib/fog/aws/requests/storage/copy_object.rb
+    lib/fog/aws/requests/storage/delete_bucket.rb
+    lib/fog/aws/requests/storage/delete_object.rb
+    lib/fog/aws/requests/storage/get_bucket.rb
+    lib/fog/aws/requests/storage/get_bucket_acl.rb
+    lib/fog/aws/requests/storage/get_bucket_location.rb
+    lib/fog/aws/requests/storage/get_bucket_logging.rb
+    lib/fog/aws/requests/storage/get_bucket_object_versions.rb
+    lib/fog/aws/requests/storage/get_bucket_versioning.rb
+    lib/fog/aws/requests/storage/get_object.rb
+    lib/fog/aws/requests/storage/get_object_acl.rb
+    lib/fog/aws/requests/storage/get_object_torrent.rb
+    lib/fog/aws/requests/storage/get_object_url.rb
+    lib/fog/aws/requests/storage/get_request_payment.rb
+    lib/fog/aws/requests/storage/get_service.rb
+    lib/fog/aws/requests/storage/head_object.rb
+    lib/fog/aws/requests/storage/put_bucket.rb
+    lib/fog/aws/requests/storage/put_bucket_acl.rb
+    lib/fog/aws/requests/storage/put_bucket_logging.rb
+    lib/fog/aws/requests/storage/put_bucket_versioning.rb
+    lib/fog/aws/requests/storage/put_object.rb
+    lib/fog/aws/requests/storage/put_object_url.rb
+    lib/fog/aws/requests/storage/put_request_payment.rb
+    lib/fog/aws/s3.rb
+    lib/fog/aws/simpledb.rb
+    lib/fog/aws/storage.rb
+    lib/fog/bin.rb
+    lib/fog/bluebox.rb
+    lib/fog/bluebox/bin.rb
+    lib/fog/bluebox/compute.rb
+    lib/fog/bluebox/models/compute/flavor.rb
+    lib/fog/bluebox/models/compute/flavors.rb
+    lib/fog/bluebox/models/compute/image.rb
+    lib/fog/bluebox/models/compute/images.rb
+    lib/fog/bluebox/models/compute/server.rb
+    lib/fog/bluebox/models/compute/servers.rb
+    lib/fog/bluebox/requests/compute/create_block.rb
+    lib/fog/bluebox/requests/compute/destroy_block.rb
+    lib/fog/bluebox/requests/compute/get_block.rb
+    lib/fog/bluebox/requests/compute/get_blocks.rb
+    lib/fog/bluebox/requests/compute/get_product.rb
+    lib/fog/bluebox/requests/compute/get_products.rb
+    lib/fog/bluebox/requests/compute/get_template.rb
+    lib/fog/bluebox/requests/compute/get_templates.rb
+    lib/fog/bluebox/requests/compute/reboot_block.rb
+    lib/fog/brightbox.rb
+    lib/fog/brightbox/bin.rb
+    lib/fog/brightbox/compute.rb
+    lib/fog/brightbox/models/compute/cloud_ip.rb
+    lib/fog/brightbox/models/compute/cloud_ips.rb
+    lib/fog/brightbox/models/compute/flavor.rb
+    lib/fog/brightbox/models/compute/flavors.rb
+    lib/fog/brightbox/models/compute/image.rb
+    lib/fog/brightbox/models/compute/images.rb
+    lib/fog/brightbox/models/compute/server.rb
+    lib/fog/brightbox/models/compute/servers.rb
+    lib/fog/brightbox/models/compute/user.rb
+    lib/fog/brightbox/models/compute/users.rb
+    lib/fog/brightbox/models/compute/zone.rb
+    lib/fog/brightbox/models/compute/zones.rb
+    lib/fog/brightbox/requests/compute/create_account.rb
+    lib/fog/brightbox/requests/compute/create_api_client.rb
+    lib/fog/brightbox/requests/compute/create_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/create_image.rb
+    lib/fog/brightbox/requests/compute/create_server.rb
+    lib/fog/brightbox/requests/compute/destroy_api_client.rb
+    lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/destroy_image.rb
+    lib/fog/brightbox/requests/compute/destroy_server.rb
+    lib/fog/brightbox/requests/compute/get_account.rb
+    lib/fog/brightbox/requests/compute/get_api_client.rb
+    lib/fog/brightbox/requests/compute/get_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/get_image.rb
+    lib/fog/brightbox/requests/compute/get_interface.rb
+    lib/fog/brightbox/requests/compute/get_server.rb
+    lib/fog/brightbox/requests/compute/get_server_type.rb
+    lib/fog/brightbox/requests/compute/get_user.rb
+    lib/fog/brightbox/requests/compute/get_zone.rb
+    lib/fog/brightbox/requests/compute/list_accounts.rb
+    lib/fog/brightbox/requests/compute/list_api_clients.rb
+    lib/fog/brightbox/requests/compute/list_cloud_ips.rb
+    lib/fog/brightbox/requests/compute/list_images.rb
+    lib/fog/brightbox/requests/compute/list_server_types.rb
+    lib/fog/brightbox/requests/compute/list_servers.rb
+    lib/fog/brightbox/requests/compute/list_users.rb
+    lib/fog/brightbox/requests/compute/list_zones.rb
+    lib/fog/brightbox/requests/compute/map_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/rebuild_server.rb
+    lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
+    lib/fog/brightbox/requests/compute/resize_server.rb
+    lib/fog/brightbox/requests/compute/restart_server.rb
+    lib/fog/brightbox/requests/compute/shutdown_server.rb
+    lib/fog/brightbox/requests/compute/snapshot_server.rb
+    lib/fog/brightbox/requests/compute/start_server.rb
+    lib/fog/brightbox/requests/compute/stop_server.rb
+    lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/update_account.rb
+    lib/fog/brightbox/requests/compute/update_api_client.rb
+    lib/fog/brightbox/requests/compute/update_image.rb
+    lib/fog/brightbox/requests/compute/update_server.rb
+    lib/fog/brightbox/requests/compute/update_user.rb
+    lib/fog/collection.rb
+    lib/fog/connection.rb
+    lib/fog/credentials.rb
+    lib/fog/deprecation.rb
+    lib/fog/errors.rb
+    lib/fog/go_grid.rb
+    lib/fog/go_grid/bin.rb
+    lib/fog/go_grid/compute.rb
+    lib/fog/go_grid/requests/compute/common_lookup_list.rb
+    lib/fog/go_grid/requests/compute/grid_image_list.rb
+    lib/fog/go_grid/requests/compute/grid_ip_list.rb
+    lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb
+    lib/fog/go_grid/requests/compute/grid_server_add.rb
+    lib/fog/go_grid/requests/compute/grid_server_delete.rb
+    lib/fog/go_grid/requests/compute/grid_server_get.rb
+    lib/fog/go_grid/requests/compute/grid_server_list.rb
+    lib/fog/go_grid/requests/compute/grid_server_power.rb
+    lib/fog/hmac.rb
+    lib/fog/linode.rb
+    lib/fog/linode/bin.rb
+    lib/fog/linode/compute.rb
+    lib/fog/linode/requests/compute/avail_datacenters.rb
+    lib/fog/linode/requests/compute/avail_distributions.rb
+    lib/fog/linode/requests/compute/avail_kernels.rb
+    lib/fog/linode/requests/compute/avail_linodeplans.rb
+    lib/fog/linode/requests/compute/avail_stackscripts.rb
+    lib/fog/linode/requests/compute/linode_create.rb
+    lib/fog/linode/requests/compute/linode_delete.rb
+    lib/fog/linode/requests/compute/linode_list.rb
+    lib/fog/linode/requests/compute/linode_reboot.rb
+    lib/fog/local.rb
+    lib/fog/local/bin.rb
+    lib/fog/local/models/storage/directories.rb
+    lib/fog/local/models/storage/directory.rb
+    lib/fog/local/models/storage/file.rb
+    lib/fog/local/models/storage/files.rb
+    lib/fog/local/storage.rb
+    lib/fog/model.rb
+    lib/fog/new_servers.rb
+    lib/fog/new_servers/bin.rb
+    lib/fog/new_servers/compute.rb
+    lib/fog/new_servers/requests/compute/add_server.rb
+    lib/fog/new_servers/requests/compute/cancel_server.rb
+    lib/fog/new_servers/requests/compute/get_server.rb
+    lib/fog/new_servers/requests/compute/list_images.rb
+    lib/fog/new_servers/requests/compute/list_plans.rb
+    lib/fog/new_servers/requests/compute/list_servers.rb
+    lib/fog/new_servers/requests/compute/reboot_server.rb
+    lib/fog/parser.rb
+    lib/fog/provider.rb
+    lib/fog/rackspace.rb
+    lib/fog/rackspace/bin.rb
+    lib/fog/rackspace/compute.rb
+    lib/fog/rackspace/files.rb
+    lib/fog/rackspace/models/compute/flavor.rb
+    lib/fog/rackspace/models/compute/flavors.rb
+    lib/fog/rackspace/models/compute/image.rb
+    lib/fog/rackspace/models/compute/images.rb
+    lib/fog/rackspace/models/compute/server.rb
+    lib/fog/rackspace/models/compute/servers.rb
+    lib/fog/rackspace/models/storage/directories.rb
+    lib/fog/rackspace/models/storage/directory.rb
+    lib/fog/rackspace/models/storage/file.rb
+    lib/fog/rackspace/models/storage/files.rb
+    lib/fog/rackspace/requests/compute/create_image.rb
+    lib/fog/rackspace/requests/compute/create_server.rb
+    lib/fog/rackspace/requests/compute/delete_image.rb
+    lib/fog/rackspace/requests/compute/delete_server.rb
+    lib/fog/rackspace/requests/compute/get_flavor_details.rb
+    lib/fog/rackspace/requests/compute/get_image_details.rb
+    lib/fog/rackspace/requests/compute/get_server_details.rb
+    lib/fog/rackspace/requests/compute/list_addresses.rb
+    lib/fog/rackspace/requests/compute/list_flavors.rb
+    lib/fog/rackspace/requests/compute/list_flavors_detail.rb
+    lib/fog/rackspace/requests/compute/list_images.rb
+    lib/fog/rackspace/requests/compute/list_images_detail.rb
+    lib/fog/rackspace/requests/compute/list_private_addresses.rb
+    lib/fog/rackspace/requests/compute/list_public_addresses.rb
+    lib/fog/rackspace/requests/compute/list_servers.rb
+    lib/fog/rackspace/requests/compute/list_servers_detail.rb
+    lib/fog/rackspace/requests/compute/reboot_server.rb
+    lib/fog/rackspace/requests/compute/update_server.rb
+    lib/fog/rackspace/requests/storage/delete_container.rb
+    lib/fog/rackspace/requests/storage/delete_object.rb
+    lib/fog/rackspace/requests/storage/get_container.rb
+    lib/fog/rackspace/requests/storage/get_containers.rb
+    lib/fog/rackspace/requests/storage/get_object.rb
+    lib/fog/rackspace/requests/storage/head_container.rb
+    lib/fog/rackspace/requests/storage/head_containers.rb
+    lib/fog/rackspace/requests/storage/head_object.rb
+    lib/fog/rackspace/requests/storage/put_container.rb
+    lib/fog/rackspace/requests/storage/put_object.rb
+    lib/fog/rackspace/servers.rb
+    lib/fog/rackspace/storage.rb
+    lib/fog/service.rb
+    lib/fog/slicehost.rb
+    lib/fog/slicehost/bin.rb
+    lib/fog/slicehost/compute.rb
+    lib/fog/slicehost/models/compute/flavor.rb
+    lib/fog/slicehost/models/compute/flavors.rb
+    lib/fog/slicehost/models/compute/image.rb
+    lib/fog/slicehost/models/compute/images.rb
+    lib/fog/slicehost/models/compute/server.rb
+    lib/fog/slicehost/models/compute/servers.rb
+    lib/fog/slicehost/parsers/compute/create_slice.rb
+    lib/fog/slicehost/parsers/compute/get_backups.rb
+    lib/fog/slicehost/parsers/compute/get_flavor.rb
+    lib/fog/slicehost/parsers/compute/get_flavors.rb
+    lib/fog/slicehost/parsers/compute/get_image.rb
+    lib/fog/slicehost/parsers/compute/get_images.rb
+    lib/fog/slicehost/parsers/compute/get_slice.rb
+    lib/fog/slicehost/parsers/compute/get_slices.rb
+    lib/fog/slicehost/requests/compute/create_slice.rb
+    lib/fog/slicehost/requests/compute/delete_slice.rb
+    lib/fog/slicehost/requests/compute/get_backups.rb
+    lib/fog/slicehost/requests/compute/get_flavor.rb
+    lib/fog/slicehost/requests/compute/get_flavors.rb
+    lib/fog/slicehost/requests/compute/get_image.rb
+    lib/fog/slicehost/requests/compute/get_images.rb
+    lib/fog/slicehost/requests/compute/get_slice.rb
+    lib/fog/slicehost/requests/compute/get_slices.rb
+    lib/fog/slicehost/requests/compute/reboot_slice.rb
+    lib/fog/ssh.rb
+    lib/fog/terremark.rb
+    lib/fog/terremark/bin.rb
+    lib/fog/terremark/ecloud.rb
+    lib/fog/terremark/models/shared/address.rb
+    lib/fog/terremark/models/shared/addresses.rb
+    lib/fog/terremark/models/shared/network.rb
+    lib/fog/terremark/models/shared/networks.rb
+    lib/fog/terremark/models/shared/server.rb
+    lib/fog/terremark/models/shared/servers.rb
+    lib/fog/terremark/models/shared/task.rb
+    lib/fog/terremark/models/shared/tasks.rb
+    lib/fog/terremark/models/shared/vdc.rb
+    lib/fog/terremark/models/shared/vdcs.rb
+    lib/fog/terremark/parser.rb
+    lib/fog/terremark/parsers/shared/get_catalog.rb
+    lib/fog/terremark/parsers/shared/get_catalog_item.rb
+    lib/fog/terremark/parsers/shared/get_internet_services.rb
+    lib/fog/terremark/parsers/shared/get_network_ips.rb
+    lib/fog/terremark/parsers/shared/get_node_services.rb
+    lib/fog/terremark/parsers/shared/get_organization.rb
+    lib/fog/terremark/parsers/shared/get_organizations.rb
+    lib/fog/terremark/parsers/shared/get_public_ips.rb
+    lib/fog/terremark/parsers/shared/get_tasks_list.rb
+    lib/fog/terremark/parsers/shared/get_vapp_template.rb
+    lib/fog/terremark/parsers/shared/get_vdc.rb
+    lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
+    lib/fog/terremark/parsers/shared/internet_service.rb
+    lib/fog/terremark/parsers/shared/network.rb
+    lib/fog/terremark/parsers/shared/node_service.rb
+    lib/fog/terremark/parsers/shared/public_ip.rb
+    lib/fog/terremark/parsers/shared/task.rb
+    lib/fog/terremark/parsers/shared/vapp.rb
+    lib/fog/terremark/requests/shared/add_internet_service.rb
+    lib/fog/terremark/requests/shared/add_node_service.rb
+    lib/fog/terremark/requests/shared/create_internet_service.rb
+    lib/fog/terremark/requests/shared/delete_internet_service.rb
+    lib/fog/terremark/requests/shared/delete_node_service.rb
+    lib/fog/terremark/requests/shared/delete_public_ip.rb
+    lib/fog/terremark/requests/shared/delete_vapp.rb
+    lib/fog/terremark/requests/shared/deploy_vapp.rb
+    lib/fog/terremark/requests/shared/get_catalog.rb
+    lib/fog/terremark/requests/shared/get_catalog_item.rb
+    lib/fog/terremark/requests/shared/get_internet_services.rb
+    lib/fog/terremark/requests/shared/get_network.rb
+    lib/fog/terremark/requests/shared/get_network_ips.rb
+    lib/fog/terremark/requests/shared/get_node_services.rb
+    lib/fog/terremark/requests/shared/get_organization.rb
+    lib/fog/terremark/requests/shared/get_organizations.rb
+    lib/fog/terremark/requests/shared/get_public_ip.rb
+    lib/fog/terremark/requests/shared/get_public_ips.rb
+    lib/fog/terremark/requests/shared/get_task.rb
+    lib/fog/terremark/requests/shared/get_tasks_list.rb
+    lib/fog/terremark/requests/shared/get_vapp.rb
+    lib/fog/terremark/requests/shared/get_vapp_template.rb
+    lib/fog/terremark/requests/shared/get_vdc.rb
+    lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
+    lib/fog/terremark/requests/shared/power_off.rb
+    lib/fog/terremark/requests/shared/power_on.rb
+    lib/fog/terremark/requests/shared/power_reset.rb
+    lib/fog/terremark/requests/shared/power_shutdown.rb
+    lib/fog/terremark/shared.rb
+    lib/fog/terremark/vcloud.rb
+    lib/fog/vcloud.rb
+    lib/fog/vcloud/bin.rb
+    lib/fog/vcloud/collection.rb
+    lib/fog/vcloud/generators.rb
+    lib/fog/vcloud/model.rb
+    lib/fog/vcloud/models/vdc.rb
+    lib/fog/vcloud/models/vdcs.rb
+    lib/fog/vcloud/requests/get_network.rb
+    lib/fog/vcloud/requests/get_organization.rb
+    lib/fog/vcloud/requests/get_vdc.rb
+    lib/fog/vcloud/requests/get_versions.rb
+    lib/fog/vcloud/requests/login.rb
+    lib/fog/vcloud/terremark/ecloud.rb
+    lib/fog/vcloud/terremark/ecloud/models/catalog.rb
+    lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb
+    lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb
+    lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb
+    lib/fog/vcloud/terremark/ecloud/models/internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/models/internet_services.rb
+    lib/fog/vcloud/terremark/ecloud/models/ip.rb
+    lib/fog/vcloud/terremark/ecloud/models/ips.rb
+    lib/fog/vcloud/terremark/ecloud/models/network.rb
+    lib/fog/vcloud/terremark/ecloud/models/networks.rb
+    lib/fog/vcloud/terremark/ecloud/models/node.rb
+    lib/fog/vcloud/terremark/ecloud/models/nodes.rb
+    lib/fog/vcloud/terremark/ecloud/models/public_ip.rb
+    lib/fog/vcloud/terremark/ecloud/models/public_ips.rb
+    lib/fog/vcloud/terremark/ecloud/models/server.rb
+    lib/fog/vcloud/terremark/ecloud/models/servers.rb
+    lib/fog/vcloud/terremark/ecloud/models/task.rb
+    lib/fog/vcloud/terremark/ecloud/models/tasks.rb
+    lib/fog/vcloud/terremark/ecloud/models/vdc.rb
+    lib/fog/vcloud/terremark/ecloud/models/vdcs.rb
+    lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/requests/add_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_task.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb
+    lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_off.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_on.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb
+    lib/fog/vcloud/terremark/vcloud.rb
+    lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb
+    spec/aws/models/compute/address_spec.rb
+    spec/aws/models/compute/addresses_spec.rb
+    spec/aws/models/compute/flavors_spec.rb
+    spec/aws/models/compute/key_pair_spec.rb
+    spec/aws/models/compute/key_pairs_spec.rb
+    spec/aws/models/compute/security_group_spec.rb
+    spec/aws/models/compute/security_groups_spec.rb
+    spec/aws/models/compute/server_spec.rb
+    spec/aws/models/compute/servers_spec.rb
+    spec/aws/models/compute/snapshot_spec.rb
+    spec/aws/models/compute/snapshots_spec.rb
+    spec/aws/models/compute/volume_spec.rb
+    spec/aws/models/compute/volumes_spec.rb
+    spec/aws/models/storage/directories_spec.rb
+    spec/aws/models/storage/directory_spec.rb
+    spec/aws/models/storage/file_spec.rb
+    spec/aws/models/storage/files_spec.rb
+    spec/aws/requests/compute/describe_images_spec.rb
+    spec/aws/requests/s3/copy_object_spec.rb
+    spec/aws/requests/s3/delete_bucket_spec.rb
+    spec/aws/requests/s3/delete_object_spec.rb
+    spec/aws/requests/s3/get_bucket_location_spec.rb
+    spec/aws/requests/s3/get_bucket_spec.rb
+    spec/aws/requests/s3/get_object_spec.rb
+    spec/aws/requests/s3/get_request_payment_spec.rb
+    spec/aws/requests/s3/get_service_spec.rb
+    spec/aws/requests/s3/head_object_spec.rb
+    spec/aws/requests/s3/put_bucket_spec.rb
+    spec/aws/requests/s3/put_object_spec.rb
+    spec/aws/requests/s3/put_request_payment_spec.rb
+    spec/aws/requests/simpledb/batch_put_attributes_spec.rb
+    spec/aws/requests/simpledb/create_domain_spec.rb
+    spec/aws/requests/simpledb/delete_attributes_spec.rb
+    spec/aws/requests/simpledb/delete_domain_spec.rb
+    spec/aws/requests/simpledb/domain_metadata_spec.rb
+    spec/aws/requests/simpledb/get_attributes_spec.rb
+    spec/aws/requests/simpledb/list_domains_spec.rb
+    spec/aws/requests/simpledb/put_attributes_spec.rb
+    spec/aws/requests/simpledb/select_spec.rb
+    spec/bluebox/models/compute/flavors_spec.rb
+    spec/bluebox/models/compute/server_spec.rb
+    spec/bluebox/models/compute/servers_spec.rb
+    spec/brightbox/models/flavors_spec.rb
+    spec/brightbox/models/server_spec.rb
+    spec/brightbox/models/servers_spec.rb
+    spec/compact_progress_bar_formatter.rb
+    spec/lorem.txt
+    spec/rackspace/models/compute/flavors_spec.rb
+    spec/rackspace/models/compute/server_spec.rb
+    spec/rackspace/models/compute/servers_spec.rb
+    spec/rackspace/requests/storage/delete_container_spec.rb
+    spec/rackspace/requests/storage/delete_object_spec.rb
+    spec/rackspace/requests/storage/get_container_spec.rb
+    spec/rackspace/requests/storage/get_containers_spec.rb
+    spec/rackspace/requests/storage/get_object_spec.rb
+    spec/rackspace/requests/storage/head_container_spec.rb
+    spec/rackspace/requests/storage/head_containers_spec.rb
+    spec/rackspace/requests/storage/head_object_spec.rb
+    spec/rackspace/requests/storage/put_container_spec.rb
+    spec/rackspace/requests/storage/put_object_spec.rb
+    spec/shared_examples/flavors_examples.rb
+    spec/shared_examples/server_examples.rb
+    spec/shared_examples/servers_examples.rb
+    spec/slicehost/models/compute/flavors_spec.rb
+    spec/slicehost/models/compute/server_spec.rb
+    spec/slicehost/models/compute/servers_spec.rb
+    spec/spec_helper.rb
+    spec/vcloud/bin_spec.rb
+    spec/vcloud/models/vdc_spec.rb
+    spec/vcloud/models/vdcs_spec.rb
+    spec/vcloud/requests/get_network_spec.rb
+    spec/vcloud/requests/get_organization_spec.rb
+    spec/vcloud/requests/get_vdc_spec.rb
+    spec/vcloud/requests/get_versions_spec.rb
+    spec/vcloud/requests/login_spec.rb
+    spec/vcloud/spec_helper.rb
+    spec/vcloud/terremark/ecloud/models/internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/models/internet_services_spec.rb
+    spec/vcloud/terremark/ecloud/models/ip_spec.rb
+    spec/vcloud/terremark/ecloud/models/ips_spec.rb
+    spec/vcloud/terremark/ecloud/models/network_spec.rb
+    spec/vcloud/terremark/ecloud/models/networks_spec.rb
+    spec/vcloud/terremark/ecloud/models/node_spec.rb
+    spec/vcloud/terremark/ecloud/models/nodes_spec.rb
+    spec/vcloud/terremark/ecloud/models/public_ip_spec.rb
+    spec/vcloud/terremark/ecloud/models/public_ips_spec.rb
+    spec/vcloud/terremark/ecloud/models/vdc_spec.rb
+    spec/vcloud/terremark/ecloud/models/vdcs_spec.rb
+    spec/vcloud/terremark/ecloud/requests/add_internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/requests/add_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/configure_internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/requests/configure_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/delete_internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/requests/delete_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_internet_services_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_network_ip_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_network_ips_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_network_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_nodes_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_public_ip_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_public_ips_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_vdc_spec.rb
+    spec/vcloud/terremark/ecloud/requests/login_spec.rb
+    spec/vcloud/vcloud_spec.rb
+    tests/aws/helper.rb
+    tests/aws/models/storage/directory_tests.rb
+    tests/aws/requests/compute/address_tests.rb
+    tests/aws/requests/compute/availability_zone_tests.rb
+    tests/aws/requests/compute/instance_tests.rb
+    tests/aws/requests/compute/key_pair_tests.rb
+    tests/aws/requests/compute/region_tests.rb
+    tests/aws/requests/compute/security_group_tests.rb
+    tests/aws/requests/compute/snapshot_tests.rb
+    tests/aws/requests/compute/volume_tests.rb
+    tests/bluebox/helper.rb
+    tests/bluebox/requests/compute/block_tests.rb
+    tests/bluebox/requests/compute/product_tests.rb
+    tests/bluebox/requests/compute/template_tests.rb
+    tests/helper.rb
+    tests/helper_tests.rb
+    tests/helpers/model_helper.rb
+    tests/linode/helper.rb
+    tests/linode/requests/compute/datacenter_tests.rb
+    tests/linode/requests/compute/distribution_tests.rb
+    tests/linode/requests/compute/linode_tests.rb
+    tests/linode/requests/compute/linodeplans_tests.rb
+    tests/rackspace/helper.rb
+    tests/rackspace/requests/compute/address_tests.rb
+    tests/rackspace/requests/compute/flavor_tests.rb
+    tests/rackspace/requests/compute/image_tests.rb
+    tests/rackspace/requests/compute/server_tests.rb
+    tests/slicehost/helper.rb
+    tests/slicehost/requests/compute/backup_tests.rb
+    tests/slicehost/requests/compute/flavor_tests.rb
+    tests/slicehost/requests/compute/image_tests.rb
+    tests/slicehost/requests/compute/slice_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog.rb
new file mode 100644
index 0000000..9dd629d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog.rb
@@ -0,0 +1,96 @@
+require 'base64'
+require 'cgi'
+require 'digest/md5'
+require 'excon'
+require 'formatador'
+require 'json'
+require 'mime/types'
+require 'net/ssh'
+require 'nokogiri'
+require 'tempfile'
+require 'time'
+
+__DIR__ = File.dirname(__FILE__)
+
+$LOAD_PATH.unshift __DIR__ unless
+  $LOAD_PATH.include?(__DIR__) ||
+  $LOAD_PATH.include?(File.expand_path(__DIR__))
+
+require 'fog/attributes'
+require 'fog/collection'
+require 'fog/connection'
+require 'fog/deprecation'
+require 'fog/errors'
+require 'fog/hmac'
+require 'fog/model'
+require 'fog/parser'
+require 'fog/provider'
+require 'fog/service'
+require 'fog/ssh'
+
+module Fog
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.3.1'
+  end
+
+  module Mock
+    @delay = 1
+    def self.delay
+      @delay
+    end
+
+    def self.delay=(new_delay)
+      raise ArgumentError, "delay must be non-negative" unless new_delay >= 0
+      @delay = new_delay
+    end
+
+    def self.not_implemented
+      raise Fog::Errors::MockNotImplemented.new("Contributions welcome!")
+    end
+
+  end
+
+  def self.bin
+    @bin ||= false
+  end
+
+  def self.bin=(new_bin)
+    @bin = new_bin
+  end
+
+  def self.mock!
+    @mocking = true
+  end
+
+  def self.mocking?
+    !!@mocking
+  end
+
+  def self.wait_for(timeout=600, interval=1, &block)
+    duration = 0
+    start = Time.now
+    until yield || duration > timeout
+      sleep(interval)
+      duration = Time.now - start
+    end
+    if duration > timeout
+      false
+    else
+      { :duration => duration }
+    end
+  end
+
+end
+
+require 'fog/aws'
+require 'fog/bluebox'
+require 'fog/brightbox'
+require 'fog/go_grid'
+require 'fog/linode'
+require 'fog/local'
+require 'fog/new_servers'
+require 'fog/rackspace'
+require 'fog/slicehost'
+require 'fog/terremark'
+require 'fog/vcloud'
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/attributes.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/attributes.rb
new file mode 100644
index 0000000..5e75bef
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/attributes.rb
@@ -0,0 +1,179 @@
+module Fog
+  module Attributes
+    module ClassMethods
+
+      def _load(marshalled)
+        new(Marshal.load(marshalled))
+      end
+
+      def aliases
+        @aliases ||= {}
+      end
+
+      def attributes
+        @attributes ||= []
+      end
+
+      def attribute(name, options = {})
+        class_eval <<-EOS, __FILE__, __LINE__
+          attr_reader :#{name}
+        EOS
+        case options[:type]
+        when :boolean
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = case new_#{name}
+              when 'true'
+                true
+              when 'false'
+                false
+              end
+            end
+          EOS
+        when :float
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = new_#{name}.to_f
+            end
+          EOS
+        when :integer
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = new_#{name}.to_i
+            end
+          EOS
+        when :string
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = new_#{name}.to_s
+            end
+          EOS
+        when :time
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              if new_#{name}.nil?|| new_#{name} == "" || new_#{name}.is_a?(Time)
+                @#{name} = new_#{name}
+              else
+                @#{name} = Time.parse(new_#{name})
+              end
+            end
+          EOS
+        when :array
+          class_eval <<-EOS, __FILE__, __LINE__
+          def #{name}=(new_#{name})
+            @#{name} = if new_#{name}.is_a?(Array)
+              new_#{name}
+            else
+              @#{name} = [ new_#{name} ]
+            end
+          end
+          EOS
+        else
+          if squash = options[:squash]
+            class_eval <<-EOS, __FILE__, __LINE__
+              def #{name}=(new_data)
+                if new_data.is_a?(Hash)
+                  if new_data[:#{squash}] || new_data["#{squash}"]
+                    @#{name} = new_data[:#{squash}] || new_data["#{squash}"]
+                  else
+                    @#{name} = [ new_data ]
+                  end
+                else
+                  @#{name} = new_data
+                end
+              end
+            EOS
+          else
+            class_eval <<-EOS, __FILE__, __LINE__
+              attr_writer :#{name}
+            EOS
+          end
+        end
+        @attributes ||= []
+        @attributes |= [name]
+        for new_alias in [*options[:aliases]]
+          aliases[new_alias] = name
+        end
+      end
+
+      def identity(name, options = {})
+        @identity = name
+        self.attribute(name, options)
+      end
+
+      def ignore_attributes(*args)
+        @ignored_attributes = args
+      end
+
+      def ignored_attributes
+        @ignored_attributes ||= []
+      end
+
+    end
+
+    module InstanceMethods
+
+      def _dump
+        Marshal.dump(attributes)
+      end
+
+      def attributes
+        attributes = {}
+        for attribute in self.class.attributes
+          attributes[attribute] = send("#{attribute}")
+        end
+        attributes
+      end
+
+      def identity
+        send(self.class.instance_variable_get('@identity'))
+      end
+
+      def identity=(new_identity)
+        send("#{self.class.instance_variable_get('@identity')}=", new_identity)
+      end
+
+      def merge_attributes(new_attributes = {})
+        for key, value in new_attributes
+          unless self.class.ignored_attributes.include?(key)
+            if aliased_key = self.class.aliases[key]
+              send("#{aliased_key}=", value)
+            else
+              send("#{key}=", value)
+            end
+          end
+        end
+        self
+      end
+
+      def new_record?
+        !identity
+      end
+
+      def requires(*args)
+        missing = []
+        for arg in [:connection] | args
+          missing << arg unless send("#{arg}")
+        end
+        unless missing.empty?
+          if missing.length == 1
+            raise(ArgumentError, "#{missing.first} is required for this operation")
+          else
+            raise(ArgumentError, "#{missing[0...-1].join(", ")} and #{missing[-1]} are required for this operation")
+          end
+        end
+      end
+
+      private
+
+      def remap_attributes(attributes, mapping)
+        for key, value in mapping
+          if attributes.key?(key)
+            attributes[value] = attributes.delete(key)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/aws.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/aws.rb
new file mode 100644
index 0000000..dfebe12
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/aws.rb
@@ -0,0 +1,200 @@
+module Fog
+  module AWS
+
+    extend Fog::Provider
+
+    service_path 'fog/aws'
+    service 'compute'
+    service 'ec2'
+    service 'elb'
+    service 's3'
+    service 'simpledb'
+    service 'storage'
+
+    def self.indexed_param(key, values)
+      params = {}
+      unless key.include?('%d')
+        key << '.%d'
+      end
+      [*values].each_with_index do |value, index|
+        params[format(key, index + 1)] = value
+      end
+      params
+    end
+
+    def self.signed_params(params, options = {})
+      params.merge!({
+        'AWSAccessKeyId'    => options[:aws_access_key_id],
+        'SignatureMethod'   => 'HmacSHA256',
+        'SignatureVersion'  => '2',
+        'Timestamp'         => Time.now.utc.strftime("%Y-%m-%dT%H:%M:%SZ"),
+        'Version'           => options[:version]
+      })
+
+      body = ''
+      for key in params.keys.sort
+        unless (value = params[key]).nil?
+          body << "#{key}=#{CGI.escape(value.to_s).gsub(/\+/, '%20')}&"
+        end
+      end
+      string_to_sign = "POST\n#{options[:host]}\n/\n" << body.chop
+      signed_string = options[:hmac].sign(string_to_sign)
+      body << "Signature=#{CGI.escape(Base64.encode64(signed_string).chomp!).gsub(/\+/, '%20')}"
+
+      body
+    end
+
+    class Mock
+
+      def self.availability_zone
+        "us-east-1" << random_selection('abcd', 1)
+      end
+
+      def self.box_usage
+        sprintf("%0.10f", rand / 100).to_f
+      end
+
+      def self.dns_name_for(ip_address)
+        "ec2-#{ip_address.gsub('.','-')}.compute-1.amazonaws.com"
+      end
+
+      def self.private_dns_name_for(ip_address)
+        "ip-#{ip_address.gsub('.','-')}.ec2.internal"
+      end
+
+      def self.etag
+        hex(32)
+      end
+
+      def self.image
+        path = []
+        (rand(3) + 2).times do
+          path << letters(rand(9) + 8)
+        end
+        {
+          "imageOwnerId"   => letters(rand(5) + 4),
+          "blockDeviceMapping" => [],
+          "productCodes"   => [],
+          "kernelId"       => kernel_id,
+          "ramdiskId"      => ramdisk_id,
+          "imageState"     => "available",
+          "imageId"        => image_id,
+          "architecture"   => "i386",
+          "isPublic"       => true,
+          "imageLocation"  => path.join('/'),
+          "imageType"      => "machine",
+          "rootDeviceType" => ["ebs","instance-store"][rand(2)],
+          "rootDeviceName" => "/dev/sda1"
+        }
+      end
+
+      def self.image_id
+        "ami-#{hex(8)}"
+      end
+
+      def self.key_fingerprint
+        fingerprint = []
+        20.times do
+          fingerprint << hex(2)
+        end
+        fingerprint.join(':')
+      end
+
+      def self.image_id
+        "ami-#{hex(8)}"
+      end
+
+      def self.instance_id
+        "i-#{hex(8)}"
+      end
+
+      def self.ip_address
+        ip = []
+        4.times do
+          ip << numbers(rand(3) + 1).to_i.to_s # remove leading 0
+        end
+        ip.join('.')
+      end
+
+      def self.kernel_id
+        "aki-#{hex(8)}"
+      end
+
+      def self.key_material
+        key_material = ['-----BEGIN RSA PRIVATE KEY-----']
+        20.times do
+          key_material << base64(76)
+        end
+        key_material << base64(67) + '='
+        key_material << '-----END RSA PRIVATE KEY-----'
+        key_material.join("\n")
+      end
+
+      def self.owner_id
+        numbers(12)
+      end
+
+      def self.ramdisk_id
+        "ari-#{hex(8)}"
+      end
+
+      def self.request_id
+        request_id = []
+        request_id << hex(8)
+        3.times do
+          request_id << hex(4)
+        end
+        request_id << hex(12)
+        request_id.join('-')
+      end
+
+      def self.reservation_id
+        "r-#{hex(8)}"
+      end
+
+      def self.snapshot_id
+        "snap-#{hex(8)}"
+      end
+
+      def self.volume_id
+        "vol-#{hex(8)}"
+      end
+
+      private
+
+      def self.random_selection(characters, length)
+        selection = ''
+        length.times do
+          position = rand(characters.length)
+          selection << characters[position..position]
+        end
+        selection
+      end
+
+      def self.letters(length)
+        random_selection(
+          'abcdefghijklmnopqrstuvwxyz',
+          length
+        )
+      end
+
+      def self.numbers(length)
+        max = ('9' * length).to_i
+        rand(max).to_s
+      end
+
+      def self.hex(length)
+        max = ('f' * length).to_i(16)
+        rand(max).to_s(16)
+      end
+
+      def self.base64(length)
+        random_selection(
+          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
+          length
+        )
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/bin.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/bin.rb
new file mode 100644
index 0000000..9a43987
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/bin.rb
@@ -0,0 +1,79 @@
+require 'fog/credentials'
+
+module Fog
+  class << self
+
+    def providers
+      [
+        ::AWS,
+        ::Bluebox,
+        ::Brightbox,
+        ::GoGrid,
+        ::Linode,
+        ::Local,
+        ::NewServers,
+        ::Rackspace,
+        ::Slicehost,
+        ::Terremark
+      ].select {|provider| provider.available?}
+    end
+
+    def modules
+      [
+        ::Vcloud
+      ].select {|_module_| _module_.initialized?}
+    end
+
+  end
+
+  class Bin
+    class << self
+
+      def available?
+        availability = true
+        for service in services
+          begin
+            service = eval(self[service].class.to_s.split('::')[0...-1].join('::'))
+            availability &&= service.requirements.all? {|requirement| Fog.credentials.include?(requirement)}
+          rescue
+            availability = false
+          end
+        end
+
+        if availability
+          for service in services
+            for collection in self[service].collections
+              unless self.respond_to?(collection)
+                self.class_eval <<-EOS, __FILE__, __LINE__
+                  def self.#{collection}
+                    self[:#{service}].#{collection}
+                  end
+                EOS
+              end
+            end
+          end
+        end
+
+        availability
+      end
+
+      def collections
+        services.map {|service| self[service].collections}.flatten.sort_by {|service| service.to_s}
+      end
+
+    end
+  end
+
+end
+
+require 'fog/aws/bin'
+require 'fog/bluebox/bin'
+require 'fog/brightbox/bin'
+require 'fog/go_grid/bin'
+require 'fog/linode/bin'
+require 'fog/local/bin'
+require 'fog/new_servers/bin'
+require 'fog/rackspace/bin'
+require 'fog/slicehost/bin'
+require 'fog/terremark/bin'
+require 'fog/vcloud/bin'
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/bluebox.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/bluebox.rb
new file mode 100644
index 0000000..4cddb50
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/bluebox.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Bluebox
+
+    extend Fog::Provider
+
+    service_path 'fog/bluebox'
+    service :compute
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Bluebox#new is deprecated, use Fog::Bluebox::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Bluebox::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox.rb
new file mode 100644
index 0000000..ae5c945
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox.rb
@@ -0,0 +1,7 @@
+module Fog
+  module Brightbox
+    extend Fog::Provider
+    service_path 'fog/brightbox'
+    service 'compute'
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/bin.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/bin.rb
new file mode 100644
index 0000000..58067f8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/bin.rb
@@ -0,0 +1,19 @@
+class Brightbox < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Brightbox::Compute.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/compute.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/compute.rb
new file mode 100644
index 0000000..cb04ed6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/compute.rb
@@ -0,0 +1,125 @@
+module Fog
+  module Brightbox
+    class Compute < Fog::Service
+
+      AUTHENTICATION_URL = "https://auth.api.gb1.brightbox.com/token"
+      API_URL = "https://api.gb1.brightbox.com/"
+
+      requires :brightbox_client_id, :brightbox_secret
+
+      model_path 'fog/brightbox/models/compute'
+      collection :servers
+      model :server
+      collection :flavors
+      model :flavor
+      collection :images
+      model :image
+      collection :zones
+      model :zone
+      collection :cloud_ips
+      model :cloud_ip
+      collection :users
+      model :user
+
+      request_path 'fog/brightbox/requests/compute'
+      request :create_account
+      request :create_api_client
+      request :create_cloud_ip
+      request :create_image
+      request :create_server
+      request :destroy_api_client
+      request :destroy_cloud_ip
+      request :destroy_image
+      request :destroy_server
+      request :get_account
+      request :get_api_client
+      request :get_cloud_ip
+      request :get_image
+      request :get_interface
+      request :get_server
+      request :get_server_type
+      request :get_user
+      request :get_zone
+      request :list_accounts
+      request :list_api_clients
+      request :list_cloud_ips
+      request :list_images
+      request :list_server_types
+      request :list_servers
+      request :list_users
+      request :list_zones
+      request :map_cloud_ip
+      request :rebuild_server
+      request :reset_ftp_password_account
+      request :resize_server
+      request :restart_server
+      request :shutdown_server
+      request :snapshot_server
+      request :start_server
+      request :stop_server
+      request :unmap_cloud_ip
+      request :update_account
+      request :update_api_client
+      request :update_image
+      request :update_server
+      request :update_user
+
+      class Mock
+
+        def request(options)
+          raise "Not implemented"
+        end
+      end
+
+      class Real
+
+        def initialize(options)
+          @auth_url = options[:brightbox_auth_url] || Fog.credentials[:brightbox_auth_url] || AUTHENTICATION_URL
+          @api_url = options[:brightbox_api_url] || Fog.credentials[:brightbox_api_url] || API_URL
+          @brightbox_client_id = options[:brightbox_client_id] || Fog.credentials[:brightbox_client_id] || nil
+          @brightbox_secret = options[:brightbox_secret] || Fog.credentials[:brightbox_secret] || nil
+          @connection = Fog::Connection.new(@api_url)
+        end
+
+        def request(params)
+          begin
+            get_oauth_token if @oauth_token.nil?
+            response = authenticated_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            get_oauth_token
+            response = authenticated_request(params)
+          end
+          response
+        end
+
+      private
+        def get_oauth_token(options = {})
+          auth_url = options[:brightbox_auth_url] || @auth_url
+
+          connection = Fog::Connection.new(auth_url)
+          @authentication_body = {'client_id' => @brightbox_client_id, 'grant_type' => 'none'}.to_json
+
+          response = connection.request({
+            :path => "/token",
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic " + Base64.encode64("#{@brightbox_client_id}:#{@brightbox_secret}").chomp,
+              'Content-Type' => 'application/json'
+            },
+            :method   => 'POST',
+            :body     => @authentication_body
+          })
+          @oauth_token = JSON.parse(response.body)["access_token"]
+          return @oauth_token
+        end
+
+        def authenticated_request(options)
+          headers = options[:headers] || {}
+          headers.merge!("Authorization" => "OAuth #{@oauth_token}")
+          options[:headers] = headers
+          @connection.request(options)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/cloud_ip.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/cloud_ip.rb
new file mode 100644
index 0000000..c6b7bb6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/cloud_ip.rb
@@ -0,0 +1,38 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIp < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+        attribute :reverse_dns
+        attribute :public_ip
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :interface_id, :aliases => "interface", :squash => "id"
+        attribute :server_id, :aliases => "server", :squash => "id"
+
+        def map(interface_to_map)
+          requires :identity
+          connection.map_cloud_ip(identity, :interface => interface_to_map)
+        end
+
+        def unmap
+          requires :identity
+          connection.unmap_cloud_ip(identity)
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/cloud_ips.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/cloud_ips.rb
new file mode 100644
index 0000000..6f8242d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/cloud_ips.rb
@@ -0,0 +1,34 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/cloud_ip'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIps < Fog::Collection
+
+        model Fog::Brightbox::Compute::CloudIp
+
+        def all
+          data = JSON.parse(connection.list_cloud_ips.body)
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = JSON.parse(connection.get_cloud_ip(identifier).body)
+          new(data) # data is an attribute hash
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def allocate
+          data = JSON.parse(connection.create_cloud_ip.body)
+          new(data)
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/flavor.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/flavor.rb
new file mode 100644
index 0000000..6c5e0ac
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/flavor.rb
@@ -0,0 +1,29 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        # Need to convert units into standardised Fogs values
+        attribute :handle
+        attribute :bits
+        attribute :cores
+        attribute :disk, :aliases => "disk_size"
+        attribute :name
+        attribute :ram
+
+        attribute :resource_type
+        attribute :description
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/flavors.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/flavors.rb
new file mode 100644
index 0000000..9f9709e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/flavor'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Brightbox::Compute::Flavor
+
+        def all
+          data = connection.list_server_types.body
+          load(JSON.parse(data))
+        end
+
+        def get(identifier)
+          response = connection.get_server_type(identifier)
+          new(JSON.parse(response.body))
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/image.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/image.rb
new file mode 100644
index 0000000..84a44a9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/image.rb
@@ -0,0 +1,39 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :source
+        attribute :source_type
+
+        attribute :ancestor_id, :aliases => "ancestor", :squash => "id"
+        attribute :owner_id, :aliases => "owner", :squash => "id"
+        attribute :arch
+
+        attribute :resource_type
+        attribute :description
+        attribute :public
+        attribute :official
+        attribute :virtual_size
+        attribute :disk_size
+        attribute :created_at
+
+        def destroy
+          requires :identity
+          connection.destroy_image(identity)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/images.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/images.rb
new file mode 100644
index 0000000..0cdad49
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/images.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/image'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Brightbox::Compute::Image
+
+        def all
+          data = connection.list_images.body
+          load(JSON.parse(data))
+        end
+
+        def get(identifier)
+          response = connection.get_image(identifier)
+          new(JSON.parse(response.body))
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/server.rb
new file mode 100644
index 0000000..2833ac2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/server.rb
@@ -0,0 +1,103 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Server < Fog::Model
+
+        identity  :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :hostname
+        attribute :created_at, :type => :time
+        attribute :deleted_at, :type => :time
+        attribute :started_at, :type => :time
+        attribute :user_data
+
+        attribute :resource_type
+        attribute :description
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :image_id, :aliases => "image", :squash => "id"
+        attribute :flavor_id, :aliases => "server_type", :squash => "id"
+        attribute :zone_id, :aliases => "zone", :squash => "id"
+
+        # Plural links
+        [:snapshots, :cloud_ips, :interfaces].each do |link|
+          attribute link
+          # attribute :"#{link}_hash", :aliases => "#{link}"
+          # define_method(link) do
+          #   puts "(When correctly scoped...) would do:\nconnection.#{link}"
+          # end
+        end
+
+        def snapshot
+          requires :identity
+          connection.snapshot_server(identity)
+        end
+
+        def reboot(type = "soft")
+          requires :identity
+          connection.restart_server(identity, :type => type)
+          true
+        end
+
+        def start
+          requires :identity
+          connection.start_server(identity)
+          true
+        end
+
+        def stop
+          requires :identity
+          connection.stop_server(identity)
+          true
+        end
+
+        def shutdown
+          requires :identity
+          connection.shutdown_server(identity)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_server(identity)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(@flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(@image_id)
+        end
+
+        def ready?
+          status == 'active'
+        end
+
+        def save
+          requires :image_id
+          options = {
+            :image => @image_id,
+            :server_type => @flavor_id,
+            :name => @name,
+            :zone => @zone_id,
+            :user_data => @user_data
+          }.delete_if {|k,v| v.nil? || v == "" }
+          response = connection.create_server(options)
+          data = JSON.parse(response.body)
+          merge_attributes(data)
+          true
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/servers.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/servers.rb
new file mode 100644
index 0000000..4d761d7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/servers.rb
@@ -0,0 +1,31 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/server'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Brightbox::Compute::Server
+
+        def all
+          # get list of servers
+          data = JSON.parse(connection.list_servers.body)
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          # get server matching id
+          data = JSON.parse(connection.get_server(identifier).body)
+          new(data) # data is an attribute hash
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/user.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/user.rb
new file mode 100644
index 0000000..e3537bd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/user.rb
@@ -0,0 +1,40 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class User < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :resource_type
+        attribute :name
+        attribute :email_address
+        attribute :email_verified
+        attribute :ssh_key
+
+        attribute :account_id, :aliases => "default_account", :squash => "id"
+        attribute :accounts
+
+        def save
+          requires :identity
+
+          options = {
+            :email_address => @email_address,
+            :ssh_key => @ssh_key,
+            :name => @name
+          }
+
+          response = connection.update_user(identity, options)
+          data = JSON.parse(response.body)
+          merge_attributes(data)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/users.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/users.rb
new file mode 100644
index 0000000..4c56ba4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/users.rb
@@ -0,0 +1,29 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/user'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Users < Fog::Collection
+
+        model Fog::Brightbox::Compute::User
+
+        def all
+          data = JSON.parse(connection.list_users.body)
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = JSON.parse(connection.get_user(identifier).body)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/zone.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/zone.rb
new file mode 100644
index 0000000..a2cfab0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/zone.rb
@@ -0,0 +1,21 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :handle
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/zones.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/zones.rb
new file mode 100644
index 0000000..391751b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/models/compute/zones.rb
@@ -0,0 +1,31 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/zone'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zones < Fog::Collection
+
+        model Fog::Brightbox::Compute::Zone
+
+        def all
+          # get list of zones
+          data = JSON.parse(connection.list_zones.body)
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          # get zone matching id
+          data = JSON.parse(connection.get_zone(identifier).body)
+          new(data) # data is an attribute hash
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_account.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_account.rb
new file mode 100644
index 0000000..7dbbfff
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_account(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/accounts",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_account(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_api_client.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_api_client.rb
new file mode 100644
index 0000000..70ca4e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_api_client(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_api_client(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_cloud_ip.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_cloud_ip.rb
new file mode 100644
index 0000000..e71f105
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_cloud_ip(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_cloud_ip(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_image.rb
new file mode 100644
index 0000000..d020b76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_image(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_image(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_server.rb
new file mode 100644
index 0000000..fc70bc7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/create_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_server(options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_server(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_api_client.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_api_client.rb
new file mode 100644
index 0000000..d2ca8a3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_api_client(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
new file mode 100644
index 0000000..38c8dba
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_image.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_image.rb
new file mode 100644
index 0000000..2c48673
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_image(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_server.rb
new file mode 100644
index 0000000..083f7b4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/destroy_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_account.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_account.rb
new file mode 100644
index 0000000..7621cc9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/accounts/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_api_client.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_api_client.rb
new file mode 100644
index 0000000..fd3cd0a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_api_client(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_cloud_ip.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_cloud_ip.rb
new file mode 100644
index 0000000..a368396
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_image.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_image.rb
new file mode 100644
index 0000000..31d67ab
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_image(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_interface.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_interface.rb
new file mode 100644
index 0000000..b6774bd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_interface.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_interface(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/interfaces/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_interface(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_server.rb
new file mode 100644
index 0000000..0c07f10
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_server_type.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_server_type.rb
new file mode 100644
index 0000000..bb39262
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_server_type.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server_type(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server_type(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_user.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_user.rb
new file mode 100644
index 0000000..2703696
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_user(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_user(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_zone.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_zone.rb
new file mode 100644
index 0000000..ad15416
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/get_zone.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_zone(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_accounts.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_accounts.rb
new file mode 100644
index 0000000..71e6ad1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_accounts.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_accounts(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/accounts",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_accounts(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_api_clients.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_api_clients.rb
new file mode 100644
index 0000000..c7bf4f7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_api_clients.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_api_clients(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_api_clients(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_cloud_ips.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_cloud_ips.rb
new file mode 100644
index 0000000..e2a8388
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_cloud_ips.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_cloud_ips(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_cloud_ips(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_images.rb
new file mode 100644
index 0000000..900d058
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_images.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_images(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_server_types.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_server_types.rb
new file mode 100644
index 0000000..728c797
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_server_types.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_server_types(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_server_types(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_servers.rb
new file mode 100644
index 0000000..1806b5d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_servers.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_servers(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_users.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_users.rb
new file mode 100644
index 0000000..bcd933c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_users.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_users(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_users(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_zones.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_zones.rb
new file mode 100644
index 0000000..a9e8738
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/list_zones.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_zones(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_zones(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/map_cloud_ip.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/map_cloud_ip.rb
new file mode 100644
index 0000000..6b5440e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/map_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def map_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/map",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def map_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/rebuild_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/rebuild_server.rb
new file mode 100644
index 0000000..52d0fd5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/rebuild_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def rebuild_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/rebuild",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def rebuild_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
new file mode 100644
index 0000000..005f40c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def reset_ftp_password_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'POST',
+            :path     => "/1.0/accounts/#{identifier}/reset_ftp_password",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reset_ftp_password_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/resize_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/resize_server.rb
new file mode 100644
index 0000000..b22f36a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/resize_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def resize_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/resize",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def resize_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/restart_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/restart_server.rb
new file mode 100644
index 0000000..9010f14
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/restart_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def restart_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/restart",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def restart_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/shutdown_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/shutdown_server.rb
new file mode 100644
index 0000000..082be44
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/shutdown_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def shutdown_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/shutdown",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def shutdown_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/snapshot_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/snapshot_server.rb
new file mode 100644
index 0000000..d3fbbcb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/snapshot_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def snapshot_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/snapshot",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def snapshot_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/start_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/start_server.rb
new file mode 100644
index 0000000..e39bb46
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/start_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def start_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/start",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def start_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/stop_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/stop_server.rb
new file mode 100644
index 0000000..8a2c19d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/stop_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def stop_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/stop",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def stop_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
new file mode 100644
index 0000000..c9e6dc8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def unmap_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/unmap",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def unmap_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_account.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_account.rb
new file mode 100644
index 0000000..0df9d3d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/accounts/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_api_client.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_api_client.rb
new file mode 100644
index 0000000..1f19832
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_api_client(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_image.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_image.rb
new file mode 100644
index 0000000..f86e698
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_image(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_server.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_server.rb
new file mode 100644
index 0000000..45a13ad
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_server(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_user.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_user.rb
new file mode 100644
index 0000000..5c75b2e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/brightbox/requests/compute/update_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_user(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_user(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/collection.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/collection.rb
new file mode 100644
index 0000000..8bace39
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/collection.rb
@@ -0,0 +1,121 @@
+module Fog
+  class Collection < Array
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    Array.public_instance_methods(false).each do |method|
+      class_eval <<-RUBY
+        def #{method}(*args)
+          unless @loaded
+            lazy_load
+          end
+          super
+        end
+      RUBY
+    end
+
+    %w[reject select].each do |method|
+      class_eval <<-RUBY
+        def #{method}(*args)
+          unless @loaded
+            lazy_load
+          end
+          data = super
+          result = self.clone.clear.concat(data)
+        end
+      RUBY
+    end
+
+    def self.model(new_model=nil)
+      if new_model == nil
+        @model
+      else
+        @model = new_model
+      end
+    end
+
+    attr_accessor :connection
+
+    def clear
+      @loaded = true
+      super
+    end
+
+    def create(attributes = {})
+      object = new(attributes)
+      object.save
+      object
+    end
+
+    def initialize(attributes = {})
+      merge_attributes(attributes)
+    end
+
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}\n"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+          data << "\n"
+        end
+        data << "#{Thread.current[:formatador].indentation}["
+        unless self.empty?
+          data << "\n"
+          Thread.current[:formatador].indent do
+            data << self.map {|member| member.inspect}.join(",\n")
+            data << "\n"
+          end
+          data << Thread.current[:formatador].indentation
+        end
+        data << "]\n"
+      end
+      data << "#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def load(objects)
+      clear
+      for object in objects
+        self << new(object)
+      end
+      self
+    end
+
+    def model
+      self.class.instance_variable_get('@model')
+    end
+
+    def new(attributes = {})
+      model.new(
+        attributes.merge(
+          :collection => self,
+          :connection => connection
+        )
+      )
+    end
+
+    def reload
+      clear
+      lazy_load
+      self
+    end
+
+    def table(attributes = nil)
+      Formatador.display_table(self.map {|instance| instance.attributes}, attributes)
+    end
+
+    def to_json
+      self.map {|member| member}.to_json
+    end
+
+    private
+
+    def lazy_load
+      self.all
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/connection.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/connection.rb
new file mode 100644
index 0000000..9a4d819
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/connection.rb
@@ -0,0 +1,35 @@
+module Fog
+  class Connection
+
+    def initialize(url, persistent=false)
+      @excon = Excon.new(url)
+      @persistent = persistent
+    end
+
+    def request(params, &block)
+      unless @persistent
+        reset
+      end
+      unless block_given?
+        if (parser = params.delete(:parser))
+          body = Nokogiri::XML::SAX::PushParser.new(parser)
+          block = lambda { |chunk| body << chunk }
+        end
+      end
+
+      response = @excon.request(params, &block)
+
+      if parser
+        body.finish
+        response.body = parser.response
+      end
+
+      response
+    end
+
+    def reset
+      @excon.reset
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/credentials.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/credentials.rb
new file mode 100644
index 0000000..1485b01
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/credentials.rb
@@ -0,0 +1,58 @@
+require 'yaml'
+module Fog
+  class << self
+
+    def credential=(new_credential)
+      @credential = new_credential
+      @credentials = nil
+    end
+
+    def credential
+      @credential || :default
+    end
+
+    def config_path
+      ENV["FOG_RC"] || '~/.fog'
+    end
+
+    def credentials
+      @credentials ||= begin
+        path = File.expand_path(config_path)
+        credentials = if File.exists?(path)
+          File.open(path) do |file|
+            YAML.load(file.read)
+          end
+        else
+          nil
+        end
+        unless credentials && credentials[credential]
+          print("\n  To run as '#{credential}', add the following to #{config_path}\n")
+          yml = <<-YML
+
+:#{credential}:
+  :aws_access_key_id:     INTENTIONALLY_LEFT_BLANK
+  :aws_secret_access_key: INTENTIONALLY_LEFT_BLANK
+  :bluebox_api_key:       INTENTIONALLY_LEFT_BLANK
+  :bluebox_customer_id:   INTENTIONALLY_LEFT_BLANK
+  :brightbox_client_id:   INTENTIONALLY_LEFT_BLANK
+  :brightbox_secret:      INTENTIONALLY_LEFT_BLANK
+  :local_root:            INTENTIONALLY_LEFT_BLANK
+  :new_servers_password:  INTENTIONALLY_LEFT_BLANK
+  :new_servers_username:  INTENTIONALLY_LEFT_BLANK
+  :public_key_path:       INTENTIONALLY_LEFT_BLANK
+  :private_key_path:      INTENTIONALLY_LEFT_BLANK
+  :rackspace_api_key:     INTENTIONALLY_LEFT_BLANK
+  :rackspace_username:    INTENTIONALLY_LEFT_BLANK
+  :slicehost_password:    INTENTIONALLY_LEFT_BLANK
+  :terremark_username:    INTENTIONALLY_LEFT_BLANK
+  :terremark_password:    INTENTIONALLY_LEFT_BLANK
+YML
+          print(yml)
+          raise(ArgumentError.new("Missing Credentials"))
+        end
+        credentials[credential]
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/deprecation.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/deprecation.rb
new file mode 100644
index 0000000..110d011
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/deprecation.rb
@@ -0,0 +1,17 @@
+module Fog
+  module Deprecation
+
+    def deprecate(older, newer)
+      class_eval <<-EOS, __FILE__, __LINE__
+        def #{older}(*args)
+          location = caller.first
+          warning = "[yellow][WARN] #{self} => ##{older} is deprecated, use ##{newer} instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          send(:#{newer}, *args)
+        end
+      EOS
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/errors.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/errors.rb
new file mode 100644
index 0000000..e42d9a0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/errors.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Errors
+
+    class Error < StandardError
+      attr_accessor :verbose
+
+      def self.slurp(error, message = nil)
+        new_error = new(message)
+        new_error.set_backtrace(error.backtrace)
+        new_error.verbose = error.message
+        new_error
+      end
+    end
+
+    class MockNotImplemented < Fog::Errors::Error; end
+
+    class NotFound < Fog::Errors::Error; end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/go_grid.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/go_grid.rb
new file mode 100644
index 0000000..c211729
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/go_grid.rb
@@ -0,0 +1,18 @@
+module Fog
+  module GoGrid
+
+    extend Fog::Provider
+
+    service_path 'fog/go_grid'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::GoGrid#new is deprecated, use Fog::GoGrid::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Bluebox::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/hmac.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/hmac.rb
new file mode 100644
index 0000000..8051947
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/hmac.rb
@@ -0,0 +1,48 @@
+module Fog
+  class HMAC
+
+    def initialize(type, key)
+      @key = key
+      case type
+      when 'sha1'
+        setup_sha1
+      when 'sha256'
+        setup_sha256
+      end
+    end
+
+    def sign(data)
+      @signer.call(data)
+    end
+
+    private
+
+    def setup_sha1
+      @digest = OpenSSL::Digest::Digest.new('sha1')
+      @signer = lambda do |data|
+        OpenSSL::HMAC.digest(@digest, @key, data)
+      end
+    end
+
+    def setup_sha256
+      begin
+        @digest = OpenSSL::Digest::Digest.new('sha256')
+        @signer = lambda do |data|
+          OpenSSL::HMAC.digest(@digest, @key, data)
+        end
+      rescue RuntimeError => error
+        unless error.message == 'Unsupported digest algorithm (sha256).'
+          raise error
+        else
+          require 'hmac-sha2'
+          @hmac = ::HMAC::SHA256.new(@key)
+          @signer = lambda do |data|
+            @hmac.update(data)
+            @hmac.digest
+          end
+        end
+      end
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/linode.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/linode.rb
new file mode 100644
index 0000000..48eda58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/linode.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Linode
+
+    extend Fog::Provider
+
+    service_path 'fog/linode'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Linode#new is deprecated, use Fog::Linode::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Linode::Compute.new(attributes)
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/local.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/local.rb
new file mode 100644
index 0000000..ffe4eb7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/local.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Local
+
+    extend Fog::Provider
+
+    service_path 'fog/local'
+    service 'storage'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Local#new is deprecated, use Fog::Local::Storage#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Local::Storage.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/model.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/model.rb
new file mode 100644
index 0000000..7eddb11
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/model.rb
@@ -0,0 +1,57 @@
+module Fog
+  class Model
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    attr_accessor :connection
+
+    def collection
+      @collection
+    end
+
+    def initialize(new_attributes = {})
+      merge_attributes(new_attributes)
+    end
+
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "\n#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+        end
+      end
+      data << "\n#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def reload
+      if data = collection.get(identity)
+        new_attributes = data.attributes
+        merge_attributes(new_attributes)
+        self
+      end
+    end
+
+    def to_json
+      attributes.to_json
+    end
+
+    def wait_for(timeout=600, interval=1, &block)
+      reload
+      Fog.wait_for(timeout, interval) do
+        reload or raise Fog::Errors::Error.new("Reload failed, #{self.class} #{self.identity} went away.")
+        instance_eval(&block)
+      end
+    end
+
+    private
+
+    def collection=(new_collection)
+      @collection = new_collection
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/new_servers.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/new_servers.rb
new file mode 100644
index 0000000..b5734b4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/new_servers.rb
@@ -0,0 +1,18 @@
+module Fog
+  module NewServers
+
+    extend Fog::Provider
+
+    service_path 'fog/new_servers'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::NewServers#new is deprecated, use Fog::NewServers::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::NewServers::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/parser.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/parser.rb
new file mode 100644
index 0000000..2cb7df3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/parser.rb
@@ -0,0 +1,93 @@
+module Fog
+  module Parsers
+    class Base < Nokogiri::XML::SAX::Document
+
+      attr_reader :response
+
+      def initialize
+        reset
+      end
+
+      def reset
+        @response = {}
+      end
+
+      def characters(string)
+        @value ||= ''
+        @value << string.strip
+      end
+
+      def start_element(name, attrs = [])
+        @value = nil
+      end
+
+    end
+  end
+end
+
+module Fog
+  class ToHashDocument < Nokogiri::XML::SAX::Document
+
+    def initialize
+      @stack = []
+    end
+
+    def characters(string)
+      @value ||= ''
+      @value << string.strip
+    end
+
+    def end_element(name)
+      last = @stack.pop
+      if last.empty? && @value.empty?
+        @stack.last[name.to_sym] = ''
+      elsif last == {:i_nil=>"true"}
+        @stack.last[name.to_sym] = nil
+      elsif !@value.empty?
+        @stack.last[name.to_sym] = @value
+      end
+      @value = ''
+    end
+
+    def body
+      @stack.first
+    end
+
+    def response
+      body
+    end
+
+    def start_element(name, attributes = [])
+      @value = ''
+      parsed_attributes = {}
+      until attributes.empty?
+        if attributes.first.is_a?(Array)
+          key, value = attributes.shift
+        else
+          key, value = attributes.shift, attributes.shift
+        end
+        parsed_attributes[key.gsub(':','_').to_sym] = value
+      end
+      if @stack.last.is_a?(Array)
+        @stack.last << {name.to_sym => parsed_attributes}
+      else
+        data = if @stack.empty?
+          @stack.push(parsed_attributes)
+          parsed_attributes
+        elsif @stack.last[name.to_sym]
+          unless @stack.last[name.to_sym].is_a?(Array)
+            @stack.last[name.to_sym] = [@stack.last[name.to_sym]]
+          end
+          @stack.last[name.to_sym] << parsed_attributes
+          @stack.last[name.to_sym].last
+        else
+          @stack.last[name.to_sym] = {}
+          @stack.last[name.to_sym].merge!(parsed_attributes)
+          @stack.last[name.to_sym]
+        end
+        @stack.push(data)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/provider.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/provider.rb
new file mode 100644
index 0000000..484a804
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/provider.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Provider
+
+    def service_path(new_path)
+      @service_path = new_path
+    end
+
+    def service(new_service)
+      services << new_service
+      require File.join(@service_path, new_service.to_s)
+    end
+
+    def services
+      @services ||= []
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/rackspace.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/rackspace.rb
new file mode 100644
index 0000000..bf307e9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/rackspace.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Rackspace
+
+    extend Fog::Provider
+
+    service_path 'fog/rackspace'
+    service 'compute'
+    service 'files'
+    service 'servers'
+    service 'storage'
+
+    def self.authenticate(options)
+      rackspace_auth_url = options[:rackspace_auth_url] || "auth.api.rackspacecloud.com"
+      connection = Fog::Connection.new("https://" + rackspace_auth_url)
+      @rackspace_api_key  = options[:rackspace_api_key]
+      @rackspace_username = options[:rackspace_username]
+      response = connection.request({
+        :expects  => 204,
+        :headers  => {
+          'X-Auth-Key'  => @rackspace_api_key,
+          'X-Auth-User' => @rackspace_username
+        },
+        :host     => rackspace_auth_url,
+        :method   => 'GET',
+        :path     => 'v1.0'
+      })
+      response.headers.reject do |key, value|
+        !['X-Server-Management-Url', 'X-Storage-Url', 'X-CDN-Management-Url', 'X-Auth-Token'].include?(key)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/service.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/service.rb
new file mode 100644
index 0000000..a55061f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/service.rb
@@ -0,0 +1,139 @@
+module Fog
+  class Service
+
+    class Error < Fog::Errors::Error; end
+    class NotFound < Fog::Errors::NotFound; end
+
+    module Collections
+
+      def collections
+        service.collections
+      end
+
+      def requests
+        service.requests
+      end
+
+    end
+
+    class << self
+
+      def inherited(child)
+        child.class_eval <<-EOS, __FILE__, __LINE__
+          module Collections
+            include Fog::Service::Collections
+
+            def service
+              #{child}
+            end
+          end
+
+          def self.service
+            #{child}
+          end
+        EOS
+      end
+
+      def new(options={})
+        if Fog.bin
+          default_credentials = Fog.credentials.reject {|key, value| !requirements.include?(key)}
+          options = default_credentials.merge(options)
+        end
+
+        missing = []
+        for requirement in requirements
+          missing << requirement unless options[requirement]
+        end
+        unless missing.empty?
+          if missing.length == 1
+            raise(ArgumentError, [missing.first, "is required for this service"].join(' '))
+          else
+            raise(ArgumentError, [missing[0...-1].join(", "), 'and', missing[-1], 'are required for this service'].join(' '))
+          end
+        end
+
+        setup_requirements
+
+        if Fog.mocking?
+          service::Mock.send(:include, service::Collections)
+          service::Mock.new(options)
+        else
+          service::Real.send(:include, service::Collections)
+          service::Real.new(options)
+        end
+      end
+
+      def setup_requirements
+        if superclass.respond_to?(:setup_requirements)
+          superclass.setup_requirements
+        end
+
+        unless @required
+          for collection in collections
+            require [@model_path, collection].join('/')
+            constant = collection.to_s.split('_').map {|characters| characters[0...1].upcase << characters[1..-1]}.join('')
+            service::Collections.module_eval <<-EOS, __FILE__, __LINE__
+              def #{collection}(attributes = {})
+                #{service}::#{constant}.new({:connection => self}.merge(attributes))
+              end
+            EOS
+          end
+          for model in models
+            require [@model_path, model].join('/')
+          end
+          for request in requests
+            require [@request_path, request].join('/')
+          end
+          @required = true
+        end
+      end
+
+      def model_path(new_path)
+        @model_path = new_path
+      end
+
+      def collection(new_collection)
+        collections << new_collection
+      end
+
+      def collections
+        @collections ||= []
+      end
+
+      def model(new_model)
+        models << new_model
+      end
+
+      def models
+        @models ||= []
+      end
+
+      def request_path(new_path)
+        @request_path = new_path
+      end
+
+      def request(new_request)
+        requests << new_request
+      end
+
+      def requests
+        @requests ||= []
+      end
+
+      def requires(*args)
+        requirements.concat(args)
+      end
+
+      def requirements
+        @requirements ||= []
+      end
+
+      def reset_data(keys=Mock.data.keys)
+        Mock.reset_data(keys)
+      end
+
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/slicehost.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/slicehost.rb
new file mode 100644
index 0000000..26eb780
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/slicehost.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Slicehost
+
+    extend Fog::Provider
+
+    service_path 'fog/slicehost'
+    service :compute
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Slicehost#new is deprecated, use Fog::Bluebox::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Slicehost::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/ssh.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/ssh.rb
new file mode 100644
index 0000000..962cb7d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/ssh.rb
@@ -0,0 +1,117 @@
+module Fog
+  module SSH
+
+    def self.new(address, username, options = {})
+      unless options[:key_data] || options[:keys] || options[:password]
+        raise ArgumentError.new(':key_data, :keys or :password are required to initialize SSH')
+      end
+      if Fog.mocking?
+        Fog::SSH::Mock.new(address, username, options)
+      else
+        Fog::SSH::Real.new(address, username, options)
+      end
+    end
+
+    def self.reset_data(keys=Mock.data.keys)
+      Mock.reset_data(keys)
+    end
+
+    class Mock
+
+      def self.data
+        @data ||= Hash.new do |hash, key|
+          hash[key] = {}
+        end
+      end
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options
+      end
+
+      def run(commands)
+        Fog::Mock.not_implemented
+      end
+
+    end
+
+    class Real
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options.merge(:paranoid => false)
+        @options.merge(:verbose => true)
+      end
+
+      def run(commands)
+        commands = [*commands]
+        results  = []
+        begin
+          Net::SSH.start(@address, @username, @options) do |ssh|
+            commands.each do |command|
+              sudoable_command  = command.sub(/^sudo/, %{sudo -p 'fog sudo password:'})
+              escaped_command   = sudoable_command.sub(/'/, %{'"'"'})
+              result = Result.new(escaped_command)
+              ssh.open_channel do |channel|
+                channel.request_pty
+                channel.exec(%{bash -lc '#{escaped_command}'}) do |channel, success|
+                  unless success
+                    raise "Could not execute command: #{command.inspect}"
+                  end
+
+                  channel.on_data do |channel, data|
+                    result.stdout << data
+                  end
+
+                  channel.on_extended_data do |channel, type, data|
+                    next unless type == 1
+                    result.stderr << data
+                  end
+
+                  channel.on_request('exit-status') do |channel, data|
+                    result.status = data.read_long
+                  end
+
+                  channel.on_request('exit-signal') do |channel, data|
+                    result.status = 255
+                  end
+                end
+              end
+              ssh.loop
+              results << result
+            end
+          end
+        rescue Net::SSH::HostKeyMismatch => exception
+          exception.remember_host!
+          sleep 0.2
+          retry
+        end
+        results
+      end
+
+    end
+
+    class Result
+
+      attr_accessor :command, :stderr, :stdout, :status
+
+      def display_stdout
+        Formatador.display_line(stdout.split("\r\n"))
+      end
+
+      def display_stderr
+        Formatador.display_line(stderr.split("\r\n"))
+      end
+
+      def initialize(command)
+        @command = command
+        @stderr = ''
+        @stdout = ''
+      end
+
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/terremark.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/terremark.rb
new file mode 100644
index 0000000..ec499fe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/terremark.rb
@@ -0,0 +1,11 @@
+require 'fog/terremark/shared'
+require 'fog/terremark/parser'
+require 'fog/terremark/ecloud'
+require 'fog/terremark/vcloud'
+
+module Fog
+  module Terremark
+    ECLOUD_OPTIONS = [:terremark_ecloud_username, :terremark_ecloud_password]
+    VCLOUD_OPTIONS = [:terremark_vcloud_username, :terremark_vcloud_password]
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-brightbox/lib/fog/vcloud.rb b/lib/bbcloud/vendor/fog-brightbox/lib/fog/vcloud.rb
new file mode 100644
index 0000000..bc48d7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-brightbox/lib/fog/vcloud.rb
@@ -0,0 +1,418 @@
+require 'builder'
+require 'fog/vcloud/model'
+require 'fog/vcloud/collection'
+require 'fog/vcloud/generators'
+# ecloud/vcloud requires at the bottom so that the following will be defined
+
+module URI
+  class Generic
+    def host_url
+      @host_url ||= "#{self.scheme}://#{self.host}#{self.port ? ":#{self.port}" : ''}"
+    end
+  end
+end
+
+module Fog
+  class Vcloud < Fog::Service
+
+    requires :username, :password, :versions_uri
+
+    model_path 'fog/vcloud/models'
+    model :vdc
+    collection :vdcs
+
+    request_path 'fog/vcloud/requests'
+    request :login
+    request :get_versions
+    request :get_vdc
+    request :get_organization
+    request :get_network
+
+    class UnsupportedVersion < Exception ; end
+
+    module Shared
+
+      def default_organization_uri
+        @default_organization_uri ||= begin
+          unless @login_results
+            do_login
+          end
+          case @login_results.body[:Org]
+          when Array
+            @login_results.body[:Org].first[:href]
+          when Hash
+            @login_results.body[:Org][:href]
+          else
+            nil
+          end
+        end
+      end
+
+      # login handles the auth, but we just need the Set-Cookie
+      # header from that call.
+      def do_login
+        @login_results = login
+        @cookie = @login_results.headers['Set-Cookie']
+      end
+
+      def supported_versions
+        @supported_versions ||= get_versions(@versions_uri).body[:VersionInfo]
+      end
+
+      def xmlns
+        { "xmlns" => "http://www.vmware.com/vcloud/v0.8",
+          "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance",
+          "xmlns:xsd" => "http://www.w3.org/2001/XMLSchema" }
+      end
+
+      # private
+
+      def ensure_unparsed(uri)
+        if uri.is_a?(String)
+          uri
+        else
+          uri.to_s
+        end
+      end
+
+    end
+
+    class Real
+      include Shared
+      extend Fog::Vcloud::Generators
+
+      attr_accessor :login_uri
+      attr_reader :versions_uri
+
+      def supporting_versions
+        ["0.8"]
+      end
+
+      def initialize(options = {})
+        @connections = {}
+        @versions_uri = URI.parse(options[:versions_uri])
+        @module = options[:module]
+        @version = options[:version]
+        @username = options[:username]
+        @password = options[:password]
+        @persistent = options[:persistent]
+      end
+
+      def default_organization_uri
+        @default_organization_uri ||= begin
+          unless @login_results
+            do_login
+          end
+          case @login_results.body[:Org]
+          when Array
+            @login_results.body[:Org].first[:href]
+          when Hash
+            @login_results.body[:Org][:href]
+          else
+            nil
+          end
+        end
+      end
+
+      def reload
+        @connections.each_value { |k,v| v.reset if v }
+      end
+
+      # If the cookie isn't set, do a get_organizations call to set it
+      # and try the request.
+      # If we get an Unauthorized error, we assume the token expired, re-auth and try again
+      def request(params)
+        unless @cookie
+          do_login
+        end
+        begin
+          do_request(params)
+        rescue Excon::Errors::Unauthorized => e
+          do_login
+          do_request(params)
+        end
+      end
+
+      private
+
+      def ensure_parsed(uri)
+        if uri.is_a?(String)
+          URI.parse(uri)
+        else
+          uri
+        end
+      end
+
+      def supported_version_numbers
+        case supported_versions
+        when Array
+          supported_versions.map { |version| version[:Version] }
+        when Hash
+          [ supported_versions[:Version] ]
+        end
+      end
+
+      def get_login_uri
+        check_versions
+        URI.parse case supported_versions
+        when Array
+          supported_versions.detect {|version| version[:Version] == @version }[:LoginUrl]
+        when Hash
+          supported_versions[:LoginUrl]
+        end
+      end
+
+      # If we don't support any versions the service does, then raise an error.
+      # If the @version that super selected isn't in our supported list, then select one that is.
+      def check_versions
+        if @version
+          unless supported_version_numbers.include?(@version.to_s)
+            raise UnsupportedVersion.new("#{@version} is not supported by the server.")
+          end
+          unless supporting_versions.include?(@version.to_s)
+            raise UnsupportedVersion.new("#{@version} is not supported by #{self.class}")
+          end
+        else
+          unless @version = (supported_version_numbers & supporting_versions).sort.first
+            raise UnsupportedVersion.new("\nService @ #{@versions_uri} supports: #{supported_version_numbers.join(', ')}\n" +
+                                         "#{self.class} supports: #{supporting_versions.join(', ')}")
+          end
+        end
+      end
+
+      # Don't need to  set the cookie for these or retry them if the cookie timed out
+      def unauthenticated_request(params)
+        do_request(params)
+      end
+
+      # Use this to set the Authorization header for login
+      def authorization_header
+        "Basic #{Base64.encode64("#{@username}:#{@password}").chomp!}"
+      end
+
+      def login_uri
+        @login_uri ||= get_login_uri
+      end
+
+      # login handles the auth, but we just need the Set-Cookie
+      # header from that call.
+      def do_login
+        @login_results = login
+        @cookie = @login_results.headers['Set-Cookie']
+      end
+
+      # Actually do the request
+      def do_request(params)
+        # Convert the uri to a URI if it's a string.
+        if params[:uri].is_a?(String)
+          params[:uri] = URI.parse(params[:uri])
+        end
+
+        # Hash connections on the host_url ... There's nothing to say we won't get URI's that go to
+        # different hosts.
+        @connections[params[:uri].host_url] ||= Fog::Connection.new(params[:uri].host_url, @persistent)
+
+        # Set headers to an empty hash if none are set.
+        headers = params[:headers] || {}
+
+        # Add our auth cookie to the headers
+        if @cookie
+          headers.merge!('Cookie' => @cookie)
+        end
+
+        # Make the request
+        response = @connections[params[:uri].host_url].request({
+          :body     => params[:body] || '',
+          :expects  => params[:expects] || 200,
+          :headers  => headers,
+          :method   => params[:method] || 'GET',
+          :path     => params[:uri].path
+        })
+
+        # Parse the response body into a hash
+        #puts response.body
+        unless response.body.empty?
+          if params[:parse]
+            document = Fog::ToHashDocument.new
+            parser = Nokogiri::XML::SAX::PushParser.new(document)
+            parser << response.body
+            parser.finish
+
+            response.body = document.body
+          end
+        end
+
+        response
+      end
+    end
+
+    class Mock
+      include Shared
+
+      def self.base_url
+        "https://fakey.com/api/v0.8"
+      end
+
+      def self.data_reset
+        @mock_data = nil
+      end
+
+      def self.data( base_url = self.base_url )
+        @mock_data ||=
+        {
+          :versions => [
+            { :version => "v0.8", :login_url => "#{base_url}/login", :supported => true }
+          ],
+          :vdc_resources => [
+            {
+              :type => "application/vnd.vmware.vcloud.vApp+xml",
+              :href => "#{base_url}/vapp/61",
+              :name => "Foo App 1"
+            },
+            {
+              :type => "application/vnd.vmware.vcloud.vApp+xml",
+              :href => "#{base_url}/vapp/62",
+              :name => "Bar App 1"
+            },
+            {
+              :type => "application/vnd.vmware.vcloud.vApp+xml",
+              :href => "#{base_url}/vapp/63",
+              :name => "Bar App 2"
+            }
+          ],
+          :organizations =>
+          [
+            {
+              :info => {
+                :href => "#{base_url}/org/1",
+                :name => "Boom Inc.",
+              },
+              :vdcs => [
+
+                { :href => "#{base_url}/vdc/21",
+                  :id => "21",
+                  :name => "Boomstick",
+                  :storage => { :used => "105", :allocated => "200" },
+                  :cpu => { :allocated => "10000" },
+                  :memory => { :allocated => "20480" },
+                  :networks => [
+                    { :id => "31",
+                      :href => "#{base_url}/network/31",
+                      :name => "1.2.3.0/24",
+                      :subnet => "1.2.3.0/24",
+                      :gateway => "1.2.3.1",
+                      :netmask => "255.255.255.0",
+                      :dns => "8.8.8.8",
+                      :features => [
+                        { :type => :FenceMode, :value => "isolated" }
+                      ],
+                      :ips => { "1.2.3.3" => "Broom 1", "1.2.3.4" => "Broom 2", "1.2.3.10" => "Email" }
+                    },
+                    { :id => "32",
+                      :href => "#{base_url}/network/32",
+                      :name => "4.5.6.0/24",
+                      :subnet => "4.5.6.0/24",
+                      :gateway => "4.5.6.1",
+                      :netmask => "255.255.255.0",
+                      :dns => "8.8.8.8",
+                      :features => [
+                        { :type => :FenceMode, :value => "isolated" }
+                      ],
+                      :ips => { }
+                    },
+                  ],
+                  :vms => [
+                    { :href => "#{base_url}/vap/41",
+                      :name => "Broom 1"
+                    },
+                    { :href => "#{base_url}/vap/42",
+                      :name => "Broom 2"
+                    },
+                    { :href => "#{base_url}/vap/43",
+                      :name => "Email!"
+                    }
+                  ]
+                },
+                { :href => "#{base_url}/vdc/22",
+                  :id => "22",
+                  :storage => { :used => "40", :allocated => "150" },
+                  :cpu => { :allocated => "1000" },
+                  :memory => { :allocated => "2048" },
+                  :name => "Rock-n-Roll",
+                  :networks => [
+                    { :id => "33",
+                      :href => "#{base_url}/network/33",
+                      :name => "7.8.9.0/24",
+                      :subnet => "7.8.9.0/24",
+                      :gateway => "7.8.9.1",
+                      :dns => "8.8.8.8",
+                      :netmask => "255.255.255.0",
+                      :features => [
+                        { :type => :FenceMode, :value => "isolated" }
+                      ],
+                      :ips => { "7.8.9.10" => "Master Blaster" }
+                    }
+                  ],
+                  :vms => [
+                    { :href => "#{base_url}/vap/44",
+                      :name => "Master Blaster"
+                    }
+                  ]
+                }
+              ]
+            }
+          ]
+        }
+      end
+
+      def vdc_from_uri(uri)
+        match = Regexp.new(%r:.*/vdc/(\d+):).match(uri.to_s)
+        if match
+          mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == match[1] }
+        end
+      end
+
+      def ip_from_uri(uri)
+        match = Regexp.new(%r:.*/publicIp/(\d+):).match(uri.to_s)
+        if match
+          mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.compact.detect { |public_ip| public_ip[:id] == match[1] }
+        end
+      end
+
+      def initialize(options = {})
+        @versions_uri = URI.parse('https://vcloud.fakey.com/api/versions')
+      end
+
+      def mock_it(status, mock_data, mock_headers = {})
+        response = Excon::Response.new
+
+        #Parse the response body into a hash
+        if mock_data.empty?
+          response.body = mock_data
+        else
+          document = Fog::ToHashDocument.new
+          parser = Nokogiri::XML::SAX::PushParser.new(document)
+          parser << mock_data
+          parser.finish
+          response.body = document.body
+        end
+
+        response.status = status
+        response.headers = mock_headers
+        response
+      end
+
+      def mock_error(expected, status, body='', headers={})
+        raise Excon::Errors::Unauthorized.new("Expected(#{expected}) <=> Actual(#{status})")
+      end
+
+      def mock_data
+        Fog::Vcloud::Mock.data
+      end
+
+    end
+  end
+end
+
+require 'fog/vcloud/terremark/ecloud'
+require 'fog/vcloud/terremark/vcloud'
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/README.rdoc b/lib/bbcloud/vendor/formatador-0.0.15/README.rdoc
new file mode 100644
index 0000000..f851a18
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/README.rdoc
@@ -0,0 +1,63 @@
+= formatador
+
+STDOUT text formatting
+
+== Quick and dirty
+
+You can call class methods to print out single lines like this:
+
+  Formatador.display_line('Hello World')
+
+You use tags, similar to html, to set formatting options:
+
+  Formatador.display_line('[green]Hello World[/]')
+
+  [/] resets everything to normal, colors are supported and [_color_] sets the background color.
+
+== Standard options
+
+* format - and adds color codes if STDOUT.tty? is true
+* display - calls format on the input and prints it
+* display_line - calls display, but adds on a newline (\n)
+* redisplay - Displays text, prepended with \r which will overwrite the last existing line
+
+== Extensions
+
+* display_table: takes an array of hashes. Each hash is a row, with the keys being the headers and values being the data. An optional second argument can specify which headers/columns to include and in what order they should appear.
+* redisplay_progressbar: takes the current and total values as its first two arguments and redisplays a progressbar (until current = total and then it display_lines). An optional third argument represents the start time and will add an elapsed time counter.
+
+== Indentation
+
+By initializing a formatador object you can keep track of indentation:
+
+  formatador = Formatador.new
+  formatador.display_line('one level of indentation')
+  formatador.indent {
+    formatador.display_line('two levels of indentation')
+  }
+  formatador.display_line('one level of indentation')
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2009 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/Rakefile b/lib/bbcloud/vendor/formatador-0.0.15/Rakefile
new file mode 100644
index 0000000..5f393c8
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/Rakefile
@@ -0,0 +1,147 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+require 'rake/testtask'
+Rake::TestTask.new(:test) do |test|
+  test.libs << 'lib' << 'test'
+  test.pattern = 'test/**/test_*.rb'
+  test.verbose = true
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/formatador.gemspec b/lib/bbcloud/vendor/formatador-0.0.15/formatador.gemspec
new file mode 100644
index 0000000..974cdd2
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/formatador.gemspec
@@ -0,0 +1,76 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'formatador'
+  s.version           = '0.0.15'
+  s.date              = '2010-07-19'
+  s.rubyforge_project = 'formatador'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "Ruby STDOUT text formatting"
+  s.description = "STDOUT text formatting"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    README.rdoc
+    Rakefile
+    formatador.gemspec
+    lib/formatador.rb
+    lib/formatador/progressbar.rb
+    lib/formatador/table.rb
+    tests/formatador_tests.rb
+    tests/tests_helper.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador.rb b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador.rb
new file mode 100644
index 0000000..f5a0b22
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador.rb
@@ -0,0 +1,125 @@
+require File.join(File.dirname(__FILE__), 'formatador', 'table')
+require File.join(File.dirname(__FILE__), 'formatador', 'progressbar')
+
+class Formatador
+
+  VERSION = '0.0.15'
+
+  STYLES = {
+    :"\/"             => "0",
+    :reset            => "0",
+    :bold             => "1",
+    :underline        => "4",
+    :blink_slow       => "5",
+    :blink_fast       => "6",
+    :negative         => "7", # invert color/color
+    :normal           => "22",
+    :underline_none   => "24",
+    :blink_off        => "25",
+    :positive         => "27", # revert color/color
+    :black            => "30",
+    :red              => "31",
+    :green            => "32",
+    :yellow           => "33",
+    :blue             => "34",
+    :magenta          => "35",
+    :purple           => "35",
+    :cyan             => "36",
+    :white            => "37",
+    :_black_          => "40",
+    :_red_            => "41",
+    :_green_          => "42",
+    :_yellow_         => "43",
+    :_blue_           => "44",
+    :_magenta_        => "45",
+    :_purple_         => "45",
+    :_cyan_           => "46",
+    :_white_          => "47",
+    :light_black      => "90",
+    :light_red        => "91",
+    :light_green      => "92",
+    :light_yellow     => "93",
+    :light_blue       => "94",
+    :light_magenta    => "95",
+    :light_purple     => "95",
+    :light_cyan       => "96",
+    :_light_black_    => "100",
+    :_light_red_      => "101",
+    :_light_green_    => "102",
+    :_light_yellow_   => "103",
+    :_light_blue_     => "104",
+    :_light_magenta_  => "105",
+    :_light_purple_   => "105",
+    :_light_cyan_     => "106",
+  }
+
+  PARSE_REGEX  = /\[(#{ STYLES.keys.join('|') })\]/ix
+  INDENT_REGEX = /\[indent\]/ix
+
+  def initialize
+    @indent = 1
+  end
+
+  def display(string = '')
+    print(parse("[indent]#{string}"))
+    STDOUT.flush
+    nil
+  end
+
+  def display_line(string = '')
+    display(string)
+    print("\n")
+    nil
+  end
+
+  def display_lines(lines = [])
+    for line in lines
+      display_line(line)
+    end
+    nil
+  end
+
+  def parse(string)
+    if STDOUT.tty?
+      string.gsub(PARSE_REGEX) { "\e[#{STYLES[$1.to_sym]}m" }.gsub(INDENT_REGEX) { indentation }
+    else
+      string.gsub(PARSE_REGEX, '').gsub(INDENT_REGEX) { indentation }
+    end
+  end
+
+  def indent(&block)
+    @indent += 1
+    yield
+    @indent -= 1
+  end
+
+  def indentation
+    '  ' * @indent
+  end
+
+  def redisplay(string = '')
+    print("\r")
+    display("#{string}")
+    nil
+  end
+
+  %w{display display_line display_lines display_table parse redisplay redisplay_progressbar}.each do |method|
+    eval <<-DEF
+      def self.#{method}(*args, &block)
+        new.#{method}(*args, &block)
+      end
+    DEF
+  end
+
+end
+
+if __FILE__ == $0
+
+  Formatador.display_line("[negative]Formatador![/]")
+  Formatador.display_lines([
+    'one',
+    'two'
+  ])
+  Formatador.display_table([], [:foo])
+
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/progressbar.rb b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/progressbar.rb
new file mode 100644
index 0000000..7c386fc
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/progressbar.rb
@@ -0,0 +1,46 @@
+class Formatador
+
+  def redisplay_progressbar(current, total, options = {})
+    options = { :color => 'white', :width => 50 }.merge!(options)
+    data = progressbar(current, total, options)
+    if current < total
+      redisplay(data)
+    else
+      redisplay("#{data}\n")
+      @progressbar_started_at = nil
+    end
+  end
+
+  private
+
+  def progressbar(current, total, options)
+    color = options[:color]
+    started_at = options[:started_at]
+    width = options[:width]
+
+    output = []
+
+    if options[:label]
+      output << options[:label]
+    end
+
+    padding = ' ' * (total.to_s.size - current.to_s.size)
+    output << "[#{color}]#{padding}#{current}/#{total}[/]"
+
+    percent = current.to_f / total.to_f
+    done = '*' * (percent * width).ceil
+    remaining = ' ' * (width - done.length)
+    output << "[_white_]|[/][#{color}][_#{color}_]#{done}[/]#{remaining}[_white_]|[/]"
+
+    if started_at
+      elapsed = Time.now - started_at
+      minutes = (elapsed / 60).round.to_s
+      seconds = (elapsed % 60).round.to_s
+      output << "#{minutes}:#{'0' if seconds.size < 2}#{seconds}"
+    end
+
+    output << ''
+    output.join('  ')
+  end
+
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/table.rb b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/table.rb
new file mode 100644
index 0000000..b6f600f
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/table.rb
@@ -0,0 +1,57 @@
+class Formatador
+
+  def display_table(hashes, keys = nil, &block)
+    headers = keys || []
+    widths = {}
+    if hashes.empty? && keys
+      for key in keys
+        widths[key] = key.to_s.length
+      end
+    else
+      for hash in hashes
+        for key in hash.keys
+          unless keys
+            headers << key
+          end
+          widths[key] = [key.to_s.length, widths[key] || 0, hash[key] && hash[key].to_s.length || 0].max
+        end
+        headers = headers.uniq
+      end
+    end
+
+    if block_given?
+      headers = headers.sort(&block)
+    elsif !keys
+      headers = headers.sort {|x,y| x.to_s <=> y.to_s}
+    end
+
+    split = "+"
+    if headers.empty?
+      split << '--+'
+    else
+      for header in headers
+        split << ('-' * (widths[header] + 2)) << '+'
+      end
+    end
+
+    display_line(split)
+    columns = []
+    for header in headers
+      columns << "[bold]#{header}[/]#{' ' * (widths[header] - header.to_s.length)}"
+    end
+    display_line("| #{columns.join(' | ')} |")
+    display_line(split)
+
+    for hash in hashes
+      columns = []
+      for header in headers
+        datum = hash[header] || ''
+        columns << "#{datum}#{' ' * (widths[header] - datum.to_s.length)}"
+      end
+      display_line("| #{columns.join(' | ')} |")
+      display_line(split)
+    end
+    nil
+  end
+
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/tests/formatador_tests.rb b/lib/bbcloud/vendor/formatador-0.0.15/tests/formatador_tests.rb
new file mode 100644
index 0000000..218686e
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/tests/formatador_tests.rb
@@ -0,0 +1,8 @@
+require File.expand_path(File.dirname(__FILE__) + '/tests_helper')
+
+Shindo.tests("Formatador") do
+  test("fails") do
+    "hey buddy, you should probably rename this file and start specing for real"
+    false
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/tests/tests_helper.rb b/lib/bbcloud/vendor/formatador-0.0.15/tests/tests_helper.rb
new file mode 100644
index 0000000..774ad7b
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/tests/tests_helper.rb
@@ -0,0 +1,5 @@
+$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
+$LOAD_PATH.unshift(File.dirname(__FILE__))
+require 'formatador'
+require 'rubygems'
+require 'shindo'
diff --git a/lib/bbcloud/vendor/gli-1.1.2/.require_paths b/lib/bbcloud/vendor/gli-1.1.2/.require_paths
new file mode 100644
index 0000000..3f37be2
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/.require_paths
@@ -0,0 +1,3 @@
+lib
+lib
+bin
diff --git a/lib/bbcloud/vendor/gli-1.1.2/README.rdoc b/lib/bbcloud/vendor/gli-1.1.2/README.rdoc
new file mode 100644
index 0000000..e3aa403
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/README.rdoc
@@ -0,0 +1,260 @@
+= Git-Like Interface Command Line Parser
+
+Author::  Dave Copeland (mailto:davetron5000 at g mail dot com)
+Copyright:: Copyright (c) 2010 by Dave Copeland
+License:: Distributes under the Apache License, see LICENSE.txt in the source distro
+
+This is a DSL you can use to create a command line interface like git, gem or svn, in that the first argument is a command, and there are global and command specific flags.
+
+== Use
+
+Install if you need to:
+
+    sudo gem install gli
+
+The simplest way to get started is to create a scaffold project
+
+    gli init my_proj command_name other_command_name
+
+This will create a basic scaffold project in <tt>./my_proj</tt> with:
+
+* executable in <tt>./my_proj/bin/my_proj</tt>.  This file demonstrates most of what you need to describe your command line interface.
+* an empty test in <tt>./my_proj/test/tc_nothing.rb</tt> that can bootstrap your tests
+* a gemspec shell
+* a README shell
+* Rakefile that can generate RDoc, package your Gem and run tests
+
+== Supported Platforms
+
+Known to work on
+
+* 1.8.7
+* 1.9.2
+
+Though likely works on various other versions
+
+=== Example
+
+This example demonstrates most of the features of GLI.
+
+This sets you up to use the DSL that GLI defines:
+
+    #!/usr/bin/ruby
+    $: << File.expand_path(File.dirname(__FILE__) + '/../lib') 
+
+    require 'gli'
+
+    include GLI
+
+This sets a description of your program.  This can be as long as you want.
+
+    program_description 'Support program for bootstrapping GLI-based programs'
+
+This sets a config file for your program.  The config file can be used to store default values for command
+line options and command-specific options on a per-user (or per-site) basis.  The format is YAML-based.  
+Using an absolute path will result in the configuraiton file being located there.  Without an absolute path,
+the file will be located relative to the current user's home directory (which is what is being done here).
+
+    config_file '.glirc'
+
+This describes a command line switch "-n" that is global to all commands and specified before
+the command name on the command line.
+
+    desc 'Dry run; don\'t change the disk'
+    switch :n
+
+The following describes a command line flag that is global and has a default value of '<tt>.</tt>' (in GLI parlance,
+a "flag" is a command line switch that takes an option).  It also
+specifies a short and long description of its argument.  This is used to print command line help and to generate
+rdoc documentation.  Note that we
+have specified two different aliases for this flag.  <tt>-r</tt> (because it is listed first) is the default
+one and <tt>--root</tt> (note two-dash syntax) is also supported.  This means that <tt>-r some_dir</tt> and <tt>--root=some_dir</tt> mean
+the same thing to the application, but that your code should look for <tt>:r</tt>.
+
+    desc 'Root dir in which to create project'
+    long_desc 'This is the location where your project ill be created.  A subdirectory named for your project will be created here, and THAT directory will contain the generated files'
+    default_value '.'
+    arg_name 'root_dir'
+    flag [:r,:root]
+
+Next, we specify a command.  Inside the block we can use the same sorts of things as we did above to define flags
+and switches specific to the command.  These must come after the command name.  Also note that we use <tt>arg_name</tt>
+here to describe the arguments this command accepts.
+
+    desc 'Create a new GLI-based project'
+    arg_name 'project_name [command[ command]*]'
+    command [:init,:scaffold] do |c|
+
+      c.desc 'Create an ext dir'
+      c.switch [:e,:ext]
+
+      c.desc 'Overwrite/ignore existing files and directories'
+      c.switch [:force]
+
+Next, while we are still inside the <tt>command</tt> block,
+we specify the actual code to execute when the command is chosen by the user.  We define a block that
+will be given the global options (as a Hash), the command-specific options (as a Hash) and the command
+line arguments.  The hashes keys are symbols based upon the switches and flags.  For a switch or
+flag named "-r", we would use <tt>:r</tt>.
+
+      c.action do |global_options,options,args|
+        if args.length < 1
+          raise 'You must specify the name of your project'
+        end
+        Scaffold.create_scaffold(global_options[:r],
+                                 !options[:notest],
+                                 options[:e],
+                                 args[0],
+                                 args[1..-1],
+                                 ooptions[:force],
+                                 global_options[:n])
+      end
+    end
+
+You can also specify some global code to run before, after and on errors:
+
+    pre do |global_options,command,options,args|
+      puts "After parsing, but before #{command.name} is run"
+      return true
+      # return false if we want to skip command execution for some reason,
+      # such as some global precondition not having been met
+    end
+
+    post do |global_options,command,options,args|
+      puts "After successful execution of #{command.name}"
+    end
+
+    on_error do |ex|
+      puts "We got an error"
+      return true    # does the standard error handling code
+      # return false # this would skip standard error handling code
+    end
+
+Now, we run the program using the arguments the user provided on the command line
+
+    run(ARGV)
+
+Note that by using <tt>gli init</tt> you can create a shell with all of this already there for you.
+
+What this gives you:
+
+* A reasonably useful help system.  <tt>your_program help</tt> will list all the global options and commands (along with command aliases) and <tt>your_program help command_name</tt> will list help for that given command.
+* Error handling when flags do not receive arguments or unknown flags or switches are given
+* Error handling when an unknown command is specified
+* Default values for flags if they are not specified by the user (switches all default to false)
+* An easy way to allow user or site-specific defaults for options via a config file for your app
+* Nice RDoc describing how to use your application (you can see an example in the rdoc version of this file for the <tt>gli</tt> command)
+
+What this doesn't give you:
+
+* A way to indicate required flags
+* A way to indicate a required argument or required number of arguments
+* A way to do default switches to 'true' and therefore accept things like <tt>--no-force</tt>
+* A way to have repeated flags turn into an array or other type-transforming things
+
+== Configuration File
+
+The configuration file format is a very simple means of customizing the execution of your command on a per-user
+or per-site basis.  The idea is that commonly used values that aren't the commands' default can be stored in the configuration
+file so that users do not need to specify them on the command line.  The search order for the value of a particular
+flag then becomes:
+
+1. Command line invocation
+2. Configuration File value
+3. Default value in the application
+
+Note that since there is no way to switch _off_ switches, setting them to default to true in the configuration file
+cannot be "undone" on the command line.  A future version may allow this.
+
+The configuration file format is YAML based and can be bootstrapped via the +initconfig+ command to your application.  
+This command is automatically created and added to your application's commands when you declare that there is a 
+config file.  When invoked, all global options set on the command line are configured 
+inside the configuration file.  Further, a blank area for each
+command of your application is created, to allow the user edit the config file  ith command-specific default values.
+
+    --- 
+    # Global options are here
+    :f: foo
+    :g: blah
+    # Command-specific options are under 'commands'
+    commands: 
+      # defaults for the "doit" command
+      :doit: 
+        :g: bar
+        :s: true
+      # defaults for the "gonow" command
+      :gonow: 
+        :g: foobar
+        :f: barfoo
+
+This allows you to design your application to have it's behavior _entirely_ affected by command line options, with sensible
+defaults stored in a configuration file.
+
+== Generating RDoc
+
+All gli-based applications include a "hidden" command named <tt>rdoc</tt>.  When you execute this command, a file called <tt>yourapp.rdoc</tt>
+is created in the current directory.  This contains a rdoc-formatted helpfile for your command line application.  This can be useful
+in packaging your application to share with others. This is also the only place in which the <tt>long_desc</tt> values are currently
+used.
+
+If your application has a <tt>README.rdoc</tt> already, you can simply add <tt>:include:yourapp.rdoc</tt> to the bottom and it will
+be included when you generate and publish your rdoc (note that it will *not* show up on github).
+
+== Reference
+
+
+[+action+] Specify the action to take when a command is executed from the command line.  This is only usable in a command block on the command object (e.g. <tt>c.action</tt>).  This takes a block that yields three parameters: a hash of global options specified on the commandline, a hash of command-specific options specified on the command line, and an array of arguments parsed after the options were set on the command line.  So, a command like <tt>git --git-dir=/tmp commit -a -m 'Foo bar' foo.c bar.c</tt> would result in the global hash containing <tt>:'git-dir' => '/tmp'</tt>, the options hash containing <tt>:a => true, :m => 'Foo bar'</tt> and the arguments array being <tt>['foo.c', 'bar.c']</tt>
+[+arg_name+] Describe the name of the argument to the next flag or command.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.arg_name</tt>)
+[+config_file+] Name the configuration file for your applicaiton.  This can either be an absolute path to where the applicaiton will find the configuration file, or a relative path, that will be interpretted as relative to the user's home directory.  Default is +nil+, which means no configuration file will be used.  Declaring this creates a special +initconfig+ command that can bootstrap this configuration file for your users.
+[+command+] Declare a command.  This takes a symbol or array of symbols and a block.  The block yields one argument, the command itself.  
+[+default_value+] Indicate the default value of the next flag.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.default_value</tt>)
+[+desc+] Describe the next flag, switch, or command you will declare.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.desc</tt>)
+[+flag+] Declare a flag, which is a command line switch that takes an argument.  This takes either a symbol or an array of symbols.  The first symbol decared is used in your program to determine the flag's value at runtime.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.flag</tt>)
+[+long_desc+] Provide a more lengthy description of the next flag, switch, or command you will declare.  This will appear in command line output for commands when you get help for a command.  For flags and switches, this will only appear in the generated rdoc and *not* on the command line.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.long_desc</tt>)
+[+on_error+] Declare an error handling routine that will be called if any command (or other GLI processing) encouters an exception.  This is a block that will receive the exception that was caught.  All exceptions are routed through this block. If the block evaluates to true, the built-in error handling will be called after, otherwise, nothing will happen.
+[+post+] Declare code to run after every command that didn't experience an error.  This is not available inside a command block.  This takes a block that will receive four arguments: the global argument hash (as in <tt>action</tt>), the command (instance of Command), the command-specific options (as in <tt>action</tt>, and the parsed command line arguments (as in <tt>action</tt>).  
+[+pre+] Declare code to run before every command.  This is not available inside a command block.  This takes a block that will receive four arguments: the global argument hash (as in <tt>action</tt>), the command (instance of Command), the command-specific options (as in <tt>action</tt>, and the parsed command line arguments (as in <tt>action</tt>).  If this block evaluates to false, the command will not be executed and the program will stop.
+[+switch+] Declare a switch, which is a command-line switch taking no argument that indicates a boolean "true" when specified on the command line.  This takes either a symbol or array of symbols.  The first symbol declared is used in your program to determine if the switch was set.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.switch</tt>)
+
+== Interface Generated
+
+The command line interface that is created with the GLI DSL is:
+
+*executable* <i>global options and flags</i> *command* <i>command specific options and flags</i> `arguments`
+
+[switch]    a command line control string that takes no argument.  The <tt>-l</tt> in <tt>ls -l</tt>
+[flag]      a switch that takes an argument.  The <tt>-d' '</tt> in <tt>cut -d' ' file</tt>
+[command]   the command to execute.  The <tt>rebase</tt> in <tt>git rebase</tt>
+[arguments] Anything that's not a switch, flag, or command.  The <tt>main.c</tt> in <tt>git add main.c</tt>
+
+=== Switches
+
+Switches can be specified one at a time in either a long or short format:
+
+    git add -i
+    git add --interactive
+
+Switches can also be combined in their short form:
+
+    ls -l -a    
+    ls -la
+
+=== Flags
+
+Flags can be specified in long or short form, and with or without an equals:
+
+    git merge -s resolve
+    git merge --strategy=resolve
+
+=== Stop Switch
+
+A <tt>--</tt> at any time stops processing and sends the rest of the argument to the command as arguments, even if
+they start with a "--"
+
+:include:gli.rdoc
+
+== Links
+
+* [http://davetron5000.github.com/gli] - RubyDoc
+* [http://www.github.com/davetron5000/gli] - Source on GitHub
+
diff --git a/lib/bbcloud/vendor/gli-1.1.2/bin/gli b/lib/bbcloud/vendor/gli-1.1.2/bin/gli
new file mode 100755
index 0000000..ae16f7f
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/bin/gli
@@ -0,0 +1,64 @@
+#!/usr/bin/ruby
+$: << File.expand_path(File.dirname(__FILE__) + '/../lib') 
+
+require 'gli'
+require 'support/scaffold'
+
+include GLI
+
+desc 'Be verbose'
+switch :v
+
+desc 'Show version'
+switch :version
+
+desc 'Dry run; don''t change the disk'
+switch :n
+
+desc 'Root dir of project'
+long_desc 'This is the directory where the project''s directory will be made, so if you specify a project name ''foo'' and the root dir of ''.'', the directory ''./foo'' will be created'
+default_value '.'
+flag [:r,:root]
+
+desc 'Create a new GLI-based project'
+long_desc <<EOS
+This will create a scaffold command line project that uses GLI
+for command line processing.  Specifically, this will create
+an executable ready to go, as well as a lib and test directory, all
+inside the directory named for your project
+EOS
+arg_name 'project_name [command[ command]*]'
+command [:init,:scaffold] do |c|
+
+  c.desc 'Create an ext dir'
+  c.switch [:e,:ext]
+
+  c.desc 'Do not create a test dir'
+  c.switch [:notest]
+
+  c.desc 'Overwrite/ignore existing files and directories'
+  c.switch [:force]
+
+  c.action do |g,o,args|
+    if args.length < 1
+      raise 'You must specify the name of your project'
+    end
+    Scaffold.create_scaffold(g[:r],!o[:notest],o[:e],args[0],args[1..-1],o[:force],g[:n])
+  end
+end
+
+pre do |global,command,options,args|
+  if (!command || command.name == :help) && global[:version]
+    puts "#{$0} v#{GLI::VERSION}"
+    false
+  else
+    puts "Executing #{command.name}" if global[:v]
+    true
+  end
+end
+
+post do |global,command,options,args|
+  puts "Executed #{command.name}" if global[:v]
+end
+
+run(ARGV)
diff --git a/lib/bbcloud/vendor/gli-1.1.2/gli.rdoc b/lib/bbcloud/vendor/gli-1.1.2/gli.rdoc
new file mode 100644
index 0000000..8c20b5b
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/gli.rdoc
@@ -0,0 +1,45 @@
+= <tt>gli</tt>
+
+    gli [global options] command_name [command-specific options] [--] arguments...
+
+* Use the command +help+ to get a summary of commands
+* Use the command <tt>help command_name</tt> to get a help for +command_name+
+* Use <tt>--</tt> to stop command line argument processing; useful if your arguments have dashes in them
+
+== Global Options
+These options are available for any command and are specified before the name of the command
+
+[<tt>-n</tt>] Dry run; dont change the disk
+[<tt>-r, --root=arg</tt>] Root dir of project <i>( default: <tt>.</tt>)</i>
+
+                          This is the directory where the projects directory will be made, so if you specify a project name foo and the root dir of ., the directory ./foo will be created
+
+[<tt>-v</tt>] Be verbose
+[<tt>--version</tt>] Show version
+== Commands
+[<tt>help</tt>] Shows list of commands or help for one command
+[<tt>init</tt>] Create a new GLI-based project
+
+=== <tt>help [command]</tt>
+
+Shows list of commands or help for one command
+
+=== <tt>init project_name [command[ command]*]</tt>
+
+Create a new GLI-based project
+
+*Aliases*
+* <tt><b>scaffold</b></tt>
+
+This will create a scaffold command line project that uses GLI
+for command line processing.  Specifically, this will create
+an executable ready to go, as well as a lib and test directory, all
+inside the directory named for your project
+
+
+==== Options
+These options are specified *after* the command.
+
+[<tt>-e, --ext</tt>] Create an ext dir
+[<tt>--force</tt>] Overwrite/ignore existing files and directories
+[<tt>--notest</tt>] Do not create a test dir
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli.rb
new file mode 100644
index 0000000..b59a55a
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli.rb
@@ -0,0 +1,323 @@
+require 'gli/command_line_token.rb'
+require 'gli/command.rb'
+require 'gli/switch.rb'
+require 'gli/flag.rb'
+require 'gli/options.rb'
+require 'gli_version.rb'
+require 'support/help.rb'
+require 'support/rdoc.rb'
+require 'support/initconfig.rb'
+require 'etc'
+
+# A means to define and parse a command line interface that works as
+# Git's does, in that you specify global options, a command name, command
+# specific options, and then command arguments.
+module GLI
+  extend self
+
+  @@program_name = $0.split(/\//)[-1]
+  @@post_block = nil
+  @@pre_block = nil
+  @@error_block = nil
+  @@config_file = nil
+
+  # Reset the GLI module internal data structures; mostly for testing
+  def reset
+    switches.clear
+    flags.clear
+    commands.clear
+    @@config_file = nil
+    clear_nexts
+  end
+
+  # describe the next switch, flag, or command.  This should be a
+  # short, one-line description
+  def desc(description); @@next_desc = description; end
+
+  # Provide a longer, more detailed description.  This
+  # will be reformatted and wrapped to fit in 80 columns
+  def long_desc(long_desc); @@next_long_desc = long_desc; end
+
+  # describe the argument name of the next flag
+  def arg_name(name); @@next_arg_name = name; end
+
+  # set the default value of the next flag
+  def default_value(val); @@next_default_value = val; end
+
+  # Create a flag, which is a switch that takes an argument
+  def flag(*names)
+    flag = Flag.new([names].flatten,@@next_desc,@@next_arg_name,@@next_default_value,@@next_long_desc)
+    flags[flag.name] = flag
+    clear_nexts
+  end
+
+  # Create a switch
+  def switch(*names)
+    switch = Switch.new([names].flatten,@@next_desc,@@next_long_desc)
+    switches[switch.name] = switch
+    clear_nexts
+  end
+
+  # Sets the config file.  If not an absolute path
+  # sets the path to the user's home directory
+  def config_file(filename)
+    if filename =~ /^\//
+      @@config_file = filename
+    else
+      @@config_file = Etc.getpwuid.dir + '/' + filename
+    end
+    commands[:initconfig] = InitConfig.new(@@config_file)
+    @@config_file
+  end
+
+  # Define a command.
+  def command(*names)
+    command = Command.new([names].flatten,@@next_desc,@@next_arg_name,@@next_long_desc)
+    commands[command.name] = command
+    yield command
+    clear_nexts
+  end
+
+  # Define a block to run after command line arguments are parsed
+  # but before any command is run.  If this block raises an exception
+  # the command specified will not be executed.
+  # The block will receive the global-options,command,options, and arguments
+  # If this block evaluates to true, the program will proceed; otherwise
+  # the program will end immediately
+  def pre(&a_proc)
+    @@pre_block = a_proc
+  end
+
+  # Define a block to run after command hase been executed, only
+  # if there was not an error.
+  # The block will receive the global-options,command,options, and arguments
+  def post(&a_proc)
+    @@post_block = a_proc
+  end
+
+  # Define a block to run if an error occurs.
+  # The block will receive any Exception that was caught.
+  # It should return false to avoid the built-in error handling (which basically just
+  # prints out a message)
+  def on_error(&a_proc)
+    @@error_block = a_proc
+  end
+
+  # Runs whatever command is needed based on the arguments.
+  def run(args)
+    rdoc = RDocCommand.new
+    commands[:rdoc] = rdoc if !commands[:rdoc]
+    commands[:help] = DefaultHelpCommand.new(rdoc) if !commands[:help]
+    begin
+      config = parse_config
+      global_options,command,options,arguments = parse_options(args,config)
+      proceed = true
+      proceed = @@pre_block.call(global_options,command,options,arguments) if @@pre_block 
+      if proceed
+        command = commands[:help] if !command
+        command.execute(global_options,options,arguments)
+        @@post_block.call(global_options,command,options,arguments) if @@post_block 
+      end
+    rescue Exception => ex
+      regular_error_handling = true
+      regular_error_handling = @@error_block.call(ex) if @@error_block
+
+      if regular_error_handling
+        puts "error: #{ex.message}"
+      end
+    end
+  end
+
+  def parse_config
+    return nil if @@config_file.nil?
+    require 'yaml'
+    if File.exist?(@@config_file)
+      File.open(@@config_file) { |f| YAML::load(f) }
+    else
+      {}
+    end
+  end
+
+  def program_name(override=nil)
+    if override
+      @@program_name = override
+    end
+    @@program_name
+  end
+
+  # Returns an array of four values:
+  #  * global options (as a Hash)
+  #  * Command 
+  #  * command options (as a Hash)
+  #  * arguments (as an Array)
+  def parse_options(args,config=nil)
+    command_configs = {}
+    if config.nil?
+      config = {}
+    else
+      command_configs = config.delete(GLI::InitConfig::COMMANDS_KEY) if !config.nil?
+    end
+    global_options,command,options,arguments = parse_options_helper(args.clone,config,nil,Options.new,Array.new,command_configs)
+    flags.each { |name,flag| global_options[name] = flag.default_value if !global_options[name] }
+    command.flags.each { |name,flag| options[name] = flag.default_value if !options[name] }
+    return [global_options,command,options,arguments]
+  end
+
+  # Finds the index of the first non-flag
+  # argument or -1 if there wasn't one.
+  def find_non_flag_index(args)
+    args.each_index do |i|
+      return i if args[i] =~ /^[^\-]/;
+      return i-1 if args[i] =~ /^\-\-$/;
+    end
+    -1;
+  end
+
+  alias :d :desc
+  alias :f :flag
+  alias :s :switch
+  alias :c :command
+
+  def clear_nexts
+    @@next_desc = nil
+    @@next_arg_name = nil
+    @@next_default_value = nil
+    @@next_long_desc = nil
+  end
+
+  clear_nexts
+
+  def flags; @@flags ||= {}; end
+  def switches; @@switches ||= {}; end
+  def commands; @@commands ||= {}; end
+
+  # Recursive helper for parsing command line options
+  # [args] the arguments that have yet to be processed
+  # [global_options] the global options hash
+  # [command] the Command that has been identified (or nil if not identified yet)
+  # [command_options] options for Command
+  # [arguments] the arguments for Command
+  # [command_configs] the configuration file for all commands, used as defaults
+  #
+  # This works by finding the first non-switch/flag argument, and taking that sublist and trying to pick out
+  # flags and switches.  After this is done, one of the following is true:
+  #   * the sublist is empty - in this case, go again, as there might be more flags to parse
+  #   * the sublist has a flag left in it - unknown flag; we bail
+  #   * the sublist has a non-flag left in it - this is the command (or the start of the arguments list)
+  #
+  # This sort of does the same thing in two phases; in the first phase, the command hasn't been identified, so
+  # we are looking for global switches and flags, ending when we get the command.
+  #
+  # Once the command has been found, we start looking for command-specific flags and switches.
+  # When those have been found, we know the rest of the argument list is arguments for the command
+  def parse_options_helper(args,global_options,command,command_options,arguments,command_configs)
+    non_flag_i = find_non_flag_index(args)
+    all_flags = false
+    if non_flag_i == 0
+      # no flags
+      if !command
+        command_name = args.shift
+        command = find_command(command_name)
+        raise "Unknown command '#{command_name}'" if !command
+        return parse_options_helper(args,
+                                    global_options,
+                                    command,
+                                    default_command_options(command,command_configs),
+                                    arguments,
+                                    command_configs)
+      else
+        return global_options,command,command_options,arguments + args
+      end
+    elsif non_flag_i == -1
+      all_flags = true
+    end
+
+    try_me = args[0..non_flag_i]
+    rest = args[(non_flag_i+1)..args.length]
+    if all_flags
+      try_me = args 
+      rest = []
+    end
+
+    # Suck up whatever options we can
+    switch_hash = switches
+    flag_hash = flags
+    options = global_options
+    if command
+      switch_hash = command.switches
+      flag_hash = command.flags
+      options = command_options
+    end
+
+    switch_hash.each do |name,switch|
+      value = switch.get_value!(try_me)
+      options[name] = value if !options[name]
+    end
+
+    flag_hash.each do |name,flag|
+      value = flag.get_value!(try_me)
+      # So, there's a case where the first time we request the value for a flag,
+      # we get the default and not the user-provided value.  The next time we request
+      # it, we want to override it with the real value.
+      # HOWEVER, sometimes this happens in reverse, so we want to err on taking the
+      # user-provided, non-default value where possible.
+      if value 
+        if options[name]
+          options[name] = value if options[name] == flag.default_value
+        else
+          options[name] = value
+        end
+      end
+    end
+
+    if try_me.empty?
+      return [global_options,command,command_options,arguments] if rest.empty?
+      # If we have no more options we've parsed them all
+      # and rest may have more
+      return parse_options_helper(rest,global_options,command,command_options,arguments,command_configs)
+    else
+      if command
+        check = rest
+        check = rest + try_me if all_flags 
+        check.each() do |arg| 
+          if arg =~ /^\-\-$/
+            try_me.delete arg
+            break 
+          end
+          raise "Unknown argument #{arg}" if arg =~ /^\-/ 
+        end
+        return [global_options,command,command_options,try_me + rest]
+      else
+        # Now we have our command name
+        command_name = try_me.shift
+        raise "Unknown argument #{command_name}" if command_name =~ /^\-/
+
+        command = find_command(command_name)
+        raise "Unknown command '#{command_name}'" if !command
+
+        return parse_options_helper(rest,
+                                    global_options,
+                                    command,
+                                    default_command_options(command,command_configs),
+                                    arguments,
+                                    command_configs)
+      end
+    end
+
+  end
+
+  def default_command_options(command,command_configs)
+    options = (command_configs && command_configs[command.name.to_sym]) || {}
+  end
+
+  def find_command(name)
+    sym = name.to_sym
+    return commands[name.to_sym] if commands[sym]
+    commands.keys.each do |command_name|
+      command = commands[command_name]
+      return command if (command.aliases && command.aliases.include?(sym))
+    end
+    nil
+  end
+
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli/command.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/command.rb
new file mode 100644
index 0000000..22eaa01
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/command.rb
@@ -0,0 +1,74 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # A command to be run, in context of global flags and switches
+  class Command < CommandLineToken
+
+    # Create a new command
+    #
+    # [names] the name or names of this command (symbol or Array of symbols)
+    # [description] description of this command
+    # [arguments_name] description of the arguments, or nil if this command doesn't take arguments
+    # [long_desc] a longer description of the command, possibly with multiple lines and text formatting
+    #
+    def initialize(names,description,arguments_name=nil,long_desc=nil)
+      super(names,description,long_desc)
+      @arguments_description = arguments_name || ''
+      clear_nexts
+    end
+
+    def arguments_description; @arguments_description; end
+
+    def names
+      all_forms
+    end
+
+    def usage
+      usage = name.to_s
+      usage += ' [options]' if !flags.empty? || !switches.empty?
+      usage += ' ' + @arguments_description if @arguments_description
+      usage
+    end
+
+    def flags; @flags ||= {}; end
+    def switches; @switches ||= {}; end
+
+    # describe the next switch or flag
+    def desc(description); @next_desc = description; end
+    # describe the argument name of the next flag
+    def arg_name(name); @next_arg_name = name; end
+    # set the default value of the next flag
+    def default_value(val); @next_default_value = val; end
+
+    def flag(*names)
+      flag = Flag.new([names].flatten,@next_desc,@next_arg_name,@next_default_value)
+      flags[flag.name] = flag
+      clear_nexts
+    end
+
+    # Create a switch
+    def switch(*names)
+      switch = Switch.new([names].flatten,@next_desc)
+      switches[switch.name] = switch
+      clear_nexts
+    end
+
+    def action(&block)
+      @action = block
+    end
+
+    def self.name_as_string(name)
+      name.to_s
+    end
+
+    def clear_nexts
+      @next_desc = nil
+      @next_arg_name = nil
+      @next_default_value = nil
+    end
+
+    def execute(global_options,options,arguments)
+      @action.call(global_options,options,arguments)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli/command_line_token.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/command_line_token.rb
new file mode 100644
index 0000000..be2a08d
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/command_line_token.rb
@@ -0,0 +1,53 @@
+module GLI
+  # Logical element of a command line, mostly so that subclasses can have similar
+  # initialization and interface
+  class CommandLineToken
+    attr_reader :name
+    attr_reader :aliases
+    attr_reader :description
+    attr_reader :long_description
+
+    def initialize(names,description,long_description=nil)
+      @description = description
+      @long_description = long_description
+      @name,@aliases,@names = parse_names(names)
+    end
+
+    def usage
+      all_forms
+    end
+
+    def <=>(other)
+      self.name.to_s <=> other.name.to_s
+    end
+
+    private
+    # Returns a string of all possible forms
+    # of this flag.  Mostly intended for printing
+    # to the user.
+    def all_forms(joiner=', ')
+      forms = all_forms_a
+      forms.join(joiner)
+    end
+
+
+    # Handles dealing with the "names" param, parsing
+    # it into the primary name and aliases list
+    def parse_names(names)
+      names_hash = Hash.new
+      names = names.is_a?(Array) ? names : [names]
+      names.each { |n| names_hash[self.class.name_as_string(n)] = true }
+      name = names.shift
+      aliases = names.length > 0 ? names : nil
+      [name,aliases,names_hash]
+    end
+
+    def all_forms_a
+      forms = [self.class.name_as_string(name)]
+      if aliases
+        forms |= aliases.collect { |a| self.class.name_as_string(a) }.sort { |x,y| y.length <=> x.length }
+      end
+      forms
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli/flag.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/flag.rb
new file mode 100644
index 0000000..e921f06
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/flag.rb
@@ -0,0 +1,66 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # Defines a flag, which is to say a switch that takes an argument
+  class Flag < Switch
+
+    attr_reader :default_value
+
+    def initialize(names,description,argument_name=nil,default=nil,long_desc=nil)
+      super(names,description,long_desc)
+      @argument_name = argument_name || "arg"
+      @default_value = default
+    end
+
+    def get_value!(args)
+      args.each_index() do |index|
+        arg = args[index]
+        present,matched,value = find_me(arg)
+        if present
+          args.delete_at index
+          if !value || value == ''
+            if args[index]
+              value = args[index]
+              args.delete_at index
+              return value
+            else
+              raise "#{matched} requires an argument"
+            end
+          else
+            return value
+          end
+        end
+      end
+      return @default_value
+    end
+
+    def find_me(arg)
+      if @names[arg]
+        return [true,arg,nil] if arg.length == 2
+        # This means we matched the long-form, but there's no argument
+        raise "#{arg} requires an argument via #{arg}=argument"
+      end
+      @names.keys.each() do |name|
+        match_string = "^#{name}=(.*)$"
+        match_data = arg.match(match_string)
+        return [true,name,$1] if match_data;
+      end
+      [false,nil,nil]
+    end
+
+    # Returns a string of all possible forms
+    # of this flag.  Mostly intended for printing
+    # to the user.
+    def all_forms(joiner=', ')
+      forms = all_forms_a
+      string = forms.join(joiner)
+      if forms[-1] =~ /^\-\-/
+        string += '='
+      else
+        string += ' '
+      end
+      string += @argument_name
+      return string
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli/options.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/options.rb
new file mode 100644
index 0000000..2065cc8
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/options.rb
@@ -0,0 +1,14 @@
+require 'ostruct'
+
+class Options < OpenStruct
+
+  def[](k)
+    @table[k.to_sym]
+  end
+
+  def[]=(k, v)
+    @table[k.to_sym] = v
+  end
+
+end
+
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli/switch.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/switch.rb
new file mode 100644
index 0000000..66ebe20
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli/switch.rb
@@ -0,0 +1,56 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # Defines a command line switch
+  class Switch < CommandLineToken
+
+    def initialize(names,description,long_desc=nil)
+      super(names,description,long_desc)
+    end
+
+    # Given the argument list, scans it looking for this switch
+    # returning true if it's in the argumennt list (and removing it from the argument list)
+    def get_value!(args)
+      idx = -1
+      args.each_index do |i|
+        result = find_me(args[i])
+        if result[0]
+          if result[1]
+            args[i] = result[1]
+          else
+            args.delete_at i
+          end
+          return result[0]
+        end
+      end
+      false
+    end
+
+    # Finds the switch in the given arg, returning the arg to keep.
+    # Returns an array of size 2:
+    # [0] true or false if the arg was found
+    # [1] the remaining arg to keep in the command line or nil to remove it
+    def find_me(arg)
+      if @names[arg]
+        return [true,nil]
+      end
+      @names.keys.each() do |name|
+        if name =~ /^-(\w)$/
+          match_string = "^\\-(\\w*)#{$1}(\\w*)$"
+          match_data = arg.match(match_string)
+          if match_data
+            # Note that if [1] and [2] were both empty 
+            # we'd have returned above
+            return [true, "-" + match_data[1] + match_data[2]]
+          end
+        end
+      end
+      [false]
+    end
+
+    def self.name_as_string(name)
+      string = name.to_s
+      string.length == 1 ? "-#{string}" : "--#{string}"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/gli_version.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/gli_version.rb
new file mode 100644
index 0000000..6cd144d
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/gli_version.rb
@@ -0,0 +1,3 @@
+module GLI
+  VERSION = '1.1.2'
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/support/help.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/support/help.rb
new file mode 100644
index 0000000..b95640a
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/support/help.rb
@@ -0,0 +1,118 @@
+require 'gli'
+require 'gli/command'
+
+module GLI
+  class DefaultHelpCommand < Command
+    def initialize(*omit_from_list)
+      @omit_from_list = omit_from_list
+      super(:help,'Shows list of commands or help for one command','[command]')
+    end
+
+    def execute(global_options,options,arguments)
+      if arguments.empty?
+        list_global_flags
+        list_commands
+      else
+        list_one_command_help(arguments[0])
+      end
+    end
+
+    private
+
+    def list_global_flags
+      usage = "usage: #{GLI.program_name} command"
+      all_options = GLI.switches.merge(GLI.flags)
+      if !all_options.empty?
+        usage += ' [options]'
+      end
+      puts usage
+      puts
+      puts 'Options:' if !all_options.empty?
+      output_command_tokens_for_help(all_options)
+      puts if !all_options.empty?
+    end
+
+    def list_commands
+      puts 'Commands:'
+      commands_to_show = GLI.commands.reject{ |name,c| @omit_from_list.include?(c) }
+      output_command_tokens_for_help(commands_to_show,:names)
+    end
+
+    def list_one_command_help(command_name)
+      command = GLI.find_command(command_name)
+      if command
+        puts command.usage
+        description = wrap(command.description,4)
+        puts "    #{description}"
+        if command.long_description
+          puts
+          puts "    #{wrap(command.long_description,4)}"
+        end
+        all_options = command.switches.merge(command.flags)
+        if !all_options.empty?
+          puts
+          puts "Options:"
+          output_command_tokens_for_help(all_options)
+        end
+      else
+        puts "No such command #{command_name}"
+      end
+    end
+
+    def output_command_tokens_for_help(tokens,usage_name=:usage)
+      max = 0
+      tokens.values.each do |token| 
+        len = token.send(usage_name).length
+        if len > max 
+          max = len
+        end
+      end
+      names = tokens.keys.sort { |x,y| x.to_s <=> y.to_s }
+      names.each do |name|
+        token = tokens[name]
+        description = token.description || ''
+        if token.kind_of? Flag 
+          description += " (default: #{token.default_value})" if token.default_value
+        end
+        description = wrap(description,max+7)
+        printf "    %-#{max}s - %s\n",token.send(usage_name),description
+      end
+    end
+  end
+
+  private
+
+  # Wraps the line at the given column length, using the given line padding.
+  # Assumes that the first line doesn't need the padding, as its filled
+  # up with other stuff
+  def wrap(line,pad_length=0,line_length=80)
+    line_padding = sprintf("%#{pad_length}s",'')
+    words = line.split(/\s+/)
+    return line if !words || words.empty?
+    wrapped = ''
+    while wrapped.length + line_padding.length < line_length
+      wrapped += ' ' if wrapped.length > 0
+      word = words.shift
+      if (wrapped.length + line_padding.length + word.length > line_length)
+        words.unshift word
+        break;
+      end
+      wrapped += word
+      return wrapped if words.empty?
+    end
+    wrapped += "\n"
+    this_line = line_padding
+    words.each do |word|
+      if this_line.length + word.length > line_length
+        wrapped += this_line
+        wrapped += "\n"
+        this_line = line_padding + word
+      else
+        this_line += ' ' if this_line.length > line_padding.length
+        this_line += word
+      end
+    end
+    wrapped.chomp!
+    wrapped + "\n" + this_line
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/support/initconfig.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/support/initconfig.rb
new file mode 100644
index 0000000..2c6a190
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/support/initconfig.rb
@@ -0,0 +1,35 @@
+require 'gli'
+require 'gli/command'
+require 'yaml'
+
+module GLI
+  class InitConfig < Command
+    COMMANDS_KEY = 'commands'
+
+    def initialize(config_file_name)
+      @filename = config_file_name
+      super(:initconfig,"Initialize the config file using current global options",nil,'Initializes a configuration file where you can set default options for command line flags, both globally and on a per-command basis.  These defaults override the built-in defaults and allow you to omit commonly-used command line flags when invoking this program')
+
+      self.desc 'force overwrite of existing config file'
+      self.switch :force
+    end
+
+    def execute(global_options,options,arguments)
+      if options[:force] || !File.exist?(@filename)
+        config = global_options
+        config[COMMANDS_KEY] = {}
+        GLI.commands.each do |name,command|
+          if (command != self) && (name != :rdoc) && (name != :help)
+            config[COMMANDS_KEY][name.to_sym] = {} if command != self
+          end
+        end
+        File.open(@filename,'w') do |file|
+          YAML.dump(config,file)
+        end
+      else
+        puts "Not overwriting existing config file #{@filename}"
+        puts 'Use --force to override'
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/support/rdoc.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/support/rdoc.rb
new file mode 100644
index 0000000..6467e75
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/support/rdoc.rb
@@ -0,0 +1,78 @@
+require 'gli'
+require 'fileutils'
+
+module GLI
+  class RDocCommand < Command
+
+    def initialize
+      super(:rdoc,'Generates RDoc for your command line interface')
+    end
+
+    def execute(g,o,a)
+      File.open("#{GLI.program_name}.rdoc",'w') do |file|
+        file << "= <tt>#{GLI.program_name}</tt>\n\n"
+        file << "    "
+        file << GLI.program_name
+        file << " "
+        global_options = GLI.switches.merge(GLI.flags)
+        if (global_options && global_options.length > 0)
+          file << "[global options] "
+        end
+        file << "command_name"
+        file << " [command-specific options]"
+        file << " [--] arguments...\n\n"
+        file << "* Use the command +help+ to get a summary of commands\n"
+        file << "* Use the command <tt>help command_name</tt> to get a help for +command_name+\n"
+        file << "* Use <tt>--</tt> to stop command line argument processing; useful if your arguments have dashes in them\n"
+        file << "\n"
+        if (global_options && global_options.length > 0)
+          file << "== Global Options\n"
+          file << "These options are available for any command and are specified before the name of the command\n\n"
+          output_flags(file,global_options)
+        end
+        file << "== Commands\n"
+        GLI.commands.values.sort.each do |command|
+          next if command == self
+          file << "[<tt>#{command.name}</tt>] #{command.description}\n"
+        end
+        file << "\n"
+
+        GLI.commands.values.sort.each do |command|
+          next if command == self
+          file << "=== <tt>#{command.name} #{command.arguments_description}</tt>\n\n"
+          file << "#{command.description}\n\n"
+          if command.aliases
+            file << "*Aliases*\n"
+            command.aliases.each do |al|
+              file << "* <tt><b>#{al}</b></tt>\n"
+            end 
+            file << "\n"
+          end
+          all_options = command.switches.merge(command.flags)
+          if (all_options && all_options.length > 0)
+            file << "#{command.long_description}\n\n"
+            file << "==== Options\n"
+            file << "These options are specified *after* the command.\n\n"
+            output_flags(file,all_options)
+          end
+        end
+      end
+    end
+
+    def output_flags(file,flags)
+      flags.values.sort.each do |flag|
+        file << "[<tt>#{flag.usage}</tt>] #{flag.description}"
+        if flag.kind_of? Flag
+          file << " <i>( default: <tt>#{flag.default_value}</tt>)</i>" if flag.default_value
+        end
+        file << "\n"
+        if flag.long_description
+          file << "\n"
+          # 12 is 4 for tt, 5 for /tt, 2 for the brackets and 1 for spacing
+          (flag.usage.length + 12).times { file << " " }
+          file << "#{flag.long_description}\n\n"
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.2/lib/support/scaffold.rb b/lib/bbcloud/vendor/gli-1.1.2/lib/support/scaffold.rb
new file mode 100644
index 0000000..02e261d
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.2/lib/support/scaffold.rb
@@ -0,0 +1,233 @@
+require 'gli'
+require 'fileutils'
+
+module GLI
+  class Scaffold
+
+    def self.create_scaffold(root_dir,create_test_dir,create_ext_dir,project_name,commands,force=false,dry_run=false)
+      dirs = [File.join(root_dir,project_name,'lib')]
+      dirs << File.join(root_dir,project_name,'bin')
+      dirs << File.join(root_dir,project_name,'test') if create_test_dir
+      dirs << File.join(root_dir,project_name,'ext') if create_ext_dir
+
+      if mkdirs(dirs,force,dry_run)
+        mk_binfile(root_dir,create_ext_dir,force,dry_run,project_name,commands)
+        mk_readme(root_dir,dry_run,project_name)
+        mk_gemspec(root_dir,dry_run,project_name)
+        mk_rakefile(root_dir,dry_run,project_name,create_test_dir)
+      end
+    end
+
+    def self.mk_readme(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/README.rdoc",'w') do |file|
+        file << "= #{project_name}\n\n"
+        file << "Describe your project here\n\n"
+        file << ":include:#{project_name}.rdoc\n\n"
+      end
+      File.open("#{root_dir}/#{project_name}/#{project_name}.rdoc",'w') do |file|
+        file << "= #{project_name}\n\n"
+        file << "Generate this with\n    #{project_name} rdoc\nAfter you have described your command line interface"
+      end
+    end
+
+    def self.mk_gemspec(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/#{project_name}.gemspec",'w') do |file|
+        file.puts <<EOS
+spec = Gem::Specification.new do |s| 
+  s.name = '#{project_name}'
+  s.version = '0.0.01'
+  s.author = 'Your Name Here'
+  s.email = 'your@email.address.com'
+  s.homepage = 'http://your.website.com'
+  s.platform = Gem::Platform::RUBY
+  s.summary = 'A description of your project'
+# Add your other files here if you make them
+  s.files = %w(
+bin/#{project_name}
+  )
+  s.require_paths << 'lib'
+  s.has_rdoc = true
+  s.extra_rdoc_files = ['README.rdoc','#{project_name}.rdoc']
+  s.rdoc_options << '--title' << 'Git Like Interface' << '--main' << 'README.rdoc' << '-ri'
+  s.bindir = 'bin'
+  s.executables << '#{project_name}'
+end
+EOS
+      end
+    end
+
+    def self.mk_rakefile(root_dir,dry_run,project_name,create_test_dir)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/Rakefile",'w') do |file|
+        file.puts <<EOS
+require 'rake/clean'
+require 'rubygems'
+require 'rake/gempackagetask'
+require 'rake/rdoctask'
+
+Rake::RDocTask.new do |rd|
+  rd.main = "README.rdoc"
+  rd.rdoc_files.include("README.rdoc","lib/**/*.rb","bin/**/*")
+  rd.title = 'Your application title'
+end
+
+spec = eval(File.read('#{project_name}.gemspec'))
+
+Rake::GemPackageTask.new(spec) do |pkg|
+end
+
+EOS
+        if create_test_dir
+          file.puts <<EOS
+require 'rake/testtask'
+Rake::TestTask.new do |t|
+  t.libs << "test"
+  t.test_files = FileList['test/tc_*.rb']
+end
+
+task :default => :test
+EOS
+          File.open("#{root_dir}/#{project_name}/test/tc_nothing.rb",'w') do |test_file|
+            test_file.puts <<EOS
+require 'test/unit'
+require 'test/unit/ui/console/testrunner'
+
+class TC_testNothing < Test::Unit::TestCase
+
+  def setup
+  end
+
+  def teardown
+  end
+
+  def test_the_truth
+    assert true
+  end
+end
+EOS
+          end
+        else
+          file.puts "task :default => :package\n"
+        end
+      end
+    end
+
+    def self.mk_binfile(root_dir,create_ext_dir,force,dry_run,project_name,commands)
+      bin_file = File.join(root_dir,project_name,'bin',project_name)
+      if !File.exist?(bin_file) || force
+        if !dry_run
+          File.open(bin_file,'w') do |file|
+            file.chmod(0755)
+            file.puts '#!/usr/bin/ruby'
+            file.puts '$: << File.expand_path(File.dirname(__FILE__) + \'/../lib\')'
+            file.puts '$: << File.expand_path(File.dirname(__FILE__) + \'/../ext\')' if create_ext_dir
+            file.puts <<EOS
+require 'rubygems'
+require 'gli'
+
+include GLI
+
+desc 'Describe some switch here'
+switch [:s,:switch]
+
+desc 'Describe some flag here'
+default_value 'the default'
+arg_name 'The name of the argument'
+flag [:f,:flagname]
+EOS
+            first = true
+            commands.each do |command|
+              file.puts <<EOS
+
+desc 'Describe #{command} here'
+arg_name 'Describe arguments to #{command} here'
+EOS
+              if first
+                file.puts <<EOS
+command :#{command} do |c|
+  c.desc 'Describe a switch to #{command}'
+  c.switch :s
+
+  c.desc 'Describe a flag to #{command}'
+  c.default_value 'default'
+  c.flag :s
+  c.action do |global_options,options,args|
+
+    # Your command logic here
+     
+    # If you have any errors, just raise them
+    # raise "that command made no sense"
+  end
+end
+EOS
+              else
+                file.puts <<EOS
+command :#{command} do |c|
+  c.action do |global_options,options,args|
+  end
+end
+EOS
+              end
+              first = false
+            end
+            file.puts <<EOS
+
+pre do |global,command,options,args|
+  # Pre logic here
+  # Return true to proceed; false to abourt and not call the
+  # chosen command
+  true
+end
+
+post do |global,command,options,args|
+  # Post logic here
+end
+
+on_error do |exception|
+  # Error logic here
+  # return false to skip default error handling
+  true
+end
+
+GLI.run(ARGV)
+EOS
+            puts "Created #{bin_file}"
+          end
+        end
+      else
+        puts bin_file + " exists; use --force to override"
+        return false
+      end
+      true
+    end
+
+    def self.mkdirs(dirs,force,dry_run)
+      exists = false
+      if !force
+        dirs.each do |dir|
+          if File.exist? dir
+            puts "#{dir} exists; use --force to override"
+            exists = true
+          end
+        end
+      end
+      if !exists
+        dirs.each do |dir|
+          puts "Creating dir #{dir}..."
+          if dry_run
+            $stderr.puts "dry-run; #{dir} not created"
+          else
+            FileUtils.mkdir_p dir
+          end
+        end
+      else
+        puts "Exiting..."
+        return false
+      end
+      true
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/.gemspec b/lib/bbcloud/vendor/hirb-0.3.4/.gemspec
new file mode 100644
index 0000000..482b41b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/.gemspec
@@ -0,0 +1,22 @@
+# -*- encoding: utf-8 -*-
+require 'rubygems' unless Object.const_defined?(:Gem)
+require File.dirname(__FILE__) + "/lib/hirb/version"
+ 
+Gem::Specification.new do |s|
+  s.name        = "hirb"
+  s.version     = Hirb::VERSION
+  s.authors     = ["Gabriel Horner"]
+  s.email       = "gabriel.horner@gmail.com"
+  s.homepage    = "http://tagaholic.me/hirb/"
+  s.summary     = "A mini view framework for console/irb that's easy to use, even while under its influence."
+  s.description = "Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output. Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer two dimensional menus."
+  s.required_rubygems_version = ">= 1.3.6"
+  s.rubyforge_project = 'tagaholic'
+  s.add_development_dependency 'bacon', '>= 1.1.0'
+  s.add_development_dependency 'mocha'
+  s.add_development_dependency 'mocha-on-bacon'
+  s.add_development_dependency 'bacon-bits'
+  s.files = Dir.glob(%w[{lib,test}/**/*.rb bin/* [A-Z]*.{txt,rdoc} ext/**/*.{rb,c} **/deps.rip]) + %w{Rakefile .gemspec}
+  s.extra_rdoc_files = ["README.rdoc", "LICENSE.txt"]
+  s.license = 'MIT'
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/CHANGELOG.rdoc b/lib/bbcloud/vendor/hirb-0.3.4/CHANGELOG.rdoc
new file mode 100644
index 0000000..2648517
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/CHANGELOG.rdoc
@@ -0,0 +1,106 @@
+== 0.3.4
+* Added auto format of array-like objects i.e. ActiveRecord::Relation and Set.
+* Fixed bug when Hirb::Console#table is used without Hirb enabled.
+* Fixed bug when hirb is running within cron and uses tput.
+
+== 0.3.3
+* Added ignore_errors option to ignore view errors and continue with original view.
+* Added support for array menu items.
+* Added support to ObjectTable for objects with an undefined :send method.
+
+== 0.3.2
+* Added irb autocompletions for bond.
+* Fixed tests for ruby 1.9.
+* Changed tests to use bacon.
+* Removed jeweler in Rakefile and pointless $LOAD_PATH manipulation.
+
+== 0.3.1
+* Bug fix on DynamicView.class_to_method to allow overrides of default views.
+* Modified mongo_mapper view to have _id first.
+
+== 0.3.0
+* Added dynamic views.
+* Added default table views for the following database classes/modules:
+  CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+  DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+  Mongoid::Document, Ripple::Document and Sequel::Model.
+* Added Hirb.add_view and Hirb.add_dynamic_view for easier view manipulation.
+* Added :multi_line_nodes option for Tree.
+* Fixed :change_fields option bug in Table.
+* Fixed no headers and nil fields bug in Table.
+* Removed deprecations in Hirb.config_file + View.enable.
+* Removed Views classes and View.format_class.
+* Removed :return_rows option for Table.
+
+== 0.2.10
+* Added multiple options to Menu, most importantly :two_d and :action.
+* Improved table resizing algorithm.
+* Added merging of configs for multiple Hirb.enable calls.
+* Added :max_fields, :hide_empty, :delete_callbacks, :resize, :header_filter
+  and :return_rows options to Table.
+* Added escaping for \t and \r in Table.
+* Renamed Table's :no_newlines option to :escape_special_chars.
+* Removed Table's :field_lengths option.
+* Removed Menu's :validate_one option.
+* Bug fix for table header of a basic array.
+* Deprecating Hirb.config_file + View.enable in next release.
+
+== 0.2.9
+* Added newline filtering and :no_newlines option for table helper.
+* Added default filters for hashes that have hash values.
+* Bug fix for deprecated to_a call.
+
+== 0.2.8
+* Added callbacks to Hirb::Helpers::Table.
+* Added :change_fields option to Hirb::Helpers::Table.
+* Added terminal size detection for jruby.
+* Bug fix for paging long outputs.
+* Bug fix to make unexpected hirb rendering errors more clear.
+
+== 0.2.7
+* 2 ruby 1.9 bug fixes.
+* Bug fix in :fields of Hirb::Helpers::ObjectTable.
+* Made :class option in Hirb::Formatter friendlier to external apps.
+
+== 0.2.6
+* Added :description option and added proc ability to :children_method option for helpers.
+* Bug fix for no ENV['HOME'] on Windows.
+* Bug fix on unaliasing output_method.
+* Bug fix on multiple renders of vertical table.
+
+== 0.2.5
+* Added ability to use Hirb.enable with non-irb ruby shells.
+* Helper configs now recursively merge when inheriting from others via :ancestor option.
+
+== 0.2.4
+* Bug fix on UTF-8 support.
+
+== 0.2.3
+* Added UTF-8 support for Ruby 1.8.x
+* Added :all_fields option to Table helper.
+
+== 0.2.2
+* Added a friendlier default (a vertical table) to incorrectly configured tables.
+* Added vertical table helper thanks to chrononaut.
+* Added detection of :select option from ActiveRecord queries in ActiveRecordTable helper.
+* Added handling anything that responds to :to_a in AutoTable helper.
+
+== 0.2.1
+* Fixed typo in Hirb::Console.view
+
+== 0.2.0
+* Major refactoring with bug fixes and better tests.
+* Improved table algorithm to ensure that tables don't wrap.
+* Added a pager which detects if output should be paged, Hirb::Pager.
+* Added a selection menu, Hirb::Menu
+* Following API changes: Hirb::Helpers::Table.max_width removed and config files don't use
+  the :view key anymore.
+== 0.1.2
+* Added tree views.
+* Added output_method option to Hirb::View.render_output.
+
+== 0.1.1
+* Fixed bug when rendering table with many fields.
+
+== 0.1.0
+* Initial release
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/LICENSE.txt b/lib/bbcloud/vendor/hirb-0.3.4/LICENSE.txt
new file mode 100644
index 0000000..5b44505
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/LICENSE.txt
@@ -0,0 +1,22 @@
+The MIT LICENSE
+
+Copyright (c) 2010 Gabriel Horner
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/README.rdoc b/lib/bbcloud/vendor/hirb-0.3.4/README.rdoc
new file mode 100644
index 0000000..bd97980
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/README.rdoc
@@ -0,0 +1,182 @@
+To read a linked version of this README, {click here}[http://tagaholic.me/hirb/doc/].
+
+== Description
+
+Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output.
+Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable
+views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options
+for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems
+i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager
+only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer
+{two dimensional menus}[http://tagaholic.me/2010/02/16/two-dimensional-console-menus-with-hirb.html].
+
+== Install
+
+Install the gem with:
+
+    sudo gem install hirb
+
+== View Tutorials
+
+* To create and configure views, see Hirb::View or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/View.html].
+* To create dynamic views, see Hirb::DynamicView or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/DynamicView.html].
+
+== Printing Ascii Tables
+
+To print ascii tables from an array of arrays, hashes or any objects:
+
+  puts Hirb::Helper::AutoTable.render(ARRAY_OF_OBJECTS)
+
+Hirb will intelligently pick up on field names from an array of hashes and create properly-aligned
+fields from an array of arrays. See
+{here}[http://tagaholic.me/2009/10/15/boson-and-hirb-interactions.html#hirbs_handy_tables] for examples.
+
+== Rails Example
+
+Let's load and enable the view framework:
+  $ script/console
+  Loading local environment (Rails 2.3.5)
+  >> require 'hirb'
+  => true
+  >> Hirb.enable
+  => nil
+
+The default configuration provides table views for ActiveRecord::Base descendants.
+If a class isn't configured, Hirb reverts to irb's default echo mode.
+  >> Hirb::Formatter.dynamic_config['ActiveRecord::Base']
+  => {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+
+  # Tag is a model class and descendant of ActiveRecord::Base
+  >> Tag.last
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | id  | created_at              | description | name          | namespace | predicate | value |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml | gem       | tags      | yaml  |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  1 row in set
+
+  >> Hirb::Formatter.dynamic_config['String']
+  => nil
+  >> 'plain ol irb'
+  => 'plain ol irb'
+  >> Hirb::Formatter.dynamic_config['Symbol']
+  => nil
+  >> :blah
+  => :blah
+
+From above you can see there are no views configured for a String or a Symbol so Hirb defaults to
+irb's echo mode. On the other hand, Tag has a view thanks to being a descendant of ActiveRecord::Base
+and there being an :ancestor option.
+
+Having seen hirb display views based on an output object's class, let's see it handle an array of objects:
+
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | id  | created_at              | description | name              | namespace | predicate | value    |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml     | gem       | tags      | yaml     |
+  | 906 | 2009-03-06 08:47:04 UTC |             | gem:tags=nomonkey | gem       | tags      | nomonkey |
+  | 905 | 2009-03-04 00:30:10 UTC |             | article:tags=ruby | article   | tags      | ruby     |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  3 rows in set
+
+At any time you can disable Hirb if you really like irb's lovely echo mode:
+  >> Hirb.disable
+  => nil
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  => [#<Tag id: 907, name: "gem:tags=yaml", description: nil, created_at: "2009-03-06 21:10:41",
+  namespace: "gem", predicate: "tags", value: "yaml">, #<Tag id: 906, name: "gem:tags=nomonkey",
+  description: nil, created_at: "2009-03-06 08:47:04", namespace: "gem", predicate: "tags", value:
+  "nomonkey">, #<Tag id: 905, name: "article:tags=ruby", description: nil, created_at: "2009-03-04
+  00:30:10", namespace: "article", predicate: "tags", value: "ruby">]
+
+== Views: Anytime, Anywhere
+While preconfigured tables are great for database records, sometimes you just want to create
+tables/views for any output object:
+  
+  #These examples don't need to have Hirb::View enabled.
+  >> Hirb.disable
+  => nil
+
+  # Imports table() and view()
+  >> extend Hirb::Console
+  => main
+
+  # Create a table of Dates comparing them with different formats.
+  >> table [Date.today, Date.today.next_month], :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+  +------------+--------+-----------+-------+--------------------------+
+  | to_s       | ld     | ajd       | amjd  | asctime                  |
+  +------------+--------+-----------+-------+--------------------------+
+  | 2009-03-11 | 155742 | 4909803/2 | 54901 | Wed Mar 11 00:00:00 2009 |
+  | 2009-04-11 | 155773 | 4909865/2 | 54932 | Sat Apr 11 00:00:00 2009 |
+  +------------+--------+-----------+-------+--------------------------+
+  2 rows in set
+
+  # Same table as the previous method. However view() will be able to call any helper.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+If these console methods weren't convenient enough, try:
+
+  # Imports view() to all objects.
+  >> require 'hirb/import_object'
+  =>true
+  # Yields same table as above examples.
+  >> [Date.today, Date.today.next_month].view :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+Although views by default are printed to STDOUT, they can be easily modified to write anywhere:
+  # Setup views to write to file 'console.log'.
+  >> Hirb::View.render_method = lambda {|output| File.open("console.log", 'w') {|f| f.write(output) } }
+
+  # Writes to file with same table output as above example.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+  # Doesn't write to file because Symbol doesn't have a view and thus defaults to irb's echo mode.
+  >> :blah
+  =>:blah
+
+  # Go back to printing Hirb views to STDOUT.
+  >> Hirb::View.reset_render_method
+
+== Pager
+
+Hirb has both pager and formatter functionality enabled by default.
+If you want to turn off the functionality of either you can pass that in at startup:
+
+  Hirb.enable :pager=>false
+  Hirb.enable :formatter=>false
+
+or toggle their state at runtime:
+
+  Hirb::View.toggle_pager
+  Hirb::View.toggle_formatter
+
+== Sharing Helpers and Views
+If you have tested helpers you'd like to share, fork Hirb and put them under lib/hirb/helpers. To share
+views for certain classes, put them under lib/hirb/views. Please submit views for gems that have a nontrivial
+number of users.
+
+== Limitations
+If using Wirble, you should call Hirb after it since they both override irb's default output.
+
+== Motivation
+Table code from http://gist.github.com/72234 and {my console app's needs}[http://github.com/cldwalker/tag-tree].
+
+== Credits
+* Chrononaut for vertical table helper.
+* crafterm, spastorino, xaviershay, bogdan and joshua for patches.
+
+== Bugs/Issues
+Please report them {on github}[http://github.com/cldwalker/hirb/issues].
+
+== Links
+* http://tagaholic.me/2009/03/13/hirb-irb-on-the-good-stuff.html
+* http://tagaholic.me/2009/03/18/ruby-class-trees-rails-plugin-trees-with-hirb.html
+* http://tagaholic.me/2009/06/19/page-irb-output-and-improve-ri-with-hirb.html
+
+== Todo
+* Consider generating views based on methods an object responds to.
+* Provide helper methods to all views.
+* Consider adding a template helper.
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/Rakefile b/lib/bbcloud/vendor/hirb-0.3.4/Rakefile
new file mode 100644
index 0000000..a88c05a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/Rakefile
@@ -0,0 +1,35 @@
+require 'rake'
+require 'fileutils'
+
+def gemspec
+  @gemspec ||= eval(File.read('.gemspec'), binding, '.gemspec')
+end
+
+desc "Build the gem"
+task :gem=>:gemspec do
+  sh "gem build .gemspec"
+  FileUtils.mkdir_p 'pkg'
+  FileUtils.mv "#{gemspec.name}-#{gemspec.version}.gem", 'pkg'
+end
+
+desc "Install the gem locally"
+task :install => :gem do
+  sh %{gem install pkg/#{gemspec.name}-#{gemspec.version}}
+end
+
+desc "Generate the gemspec"
+task :generate do
+  puts gemspec.to_ruby
+end
+
+desc "Validate the gemspec"
+task :gemspec do
+  gemspec.validate
+end
+
+desc 'Run tests'
+task :test do |t|
+  sh 'bacon -q -Ilib -I. test/*_test.rb'
+end
+
+task :default => :test
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/bond/completions/hirb.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/bond/completions/hirb.rb
new file mode 100644
index 0000000..ca9a642
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/bond/completions/hirb.rb
@@ -0,0 +1,15 @@
+complete(:methods=>%w{Hirb::View.enable Hirb.enable}) {
+  %w{config_file output_method output width height formatter pager pager_command}
+}
+complete(:methods=>%w{Hirb::Helpers::Table.render table}) {
+  %w{fields headers max_fields max_width resize number change_fields}+
+  %w{filters header_filter filter_any filter_classes vertical all_fields}+
+  %w{description escape_special_chars table_class hide_empty}
+}
+complete(:method=>"Hirb::Helpers::Tree.render") {
+  %w{type validate indent limit description multi_line_nodes value_method children_method}
+}
+complete(:methods=>%w{Hirb::Menu.render menu}) {
+  %w{helper_class prompt ask directions readline two_d default_field action multi_action} +
+    %w{action_object command reopen}
+}
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb.rb
new file mode 100644
index 0000000..e3f77ab
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb.rb
@@ -0,0 +1,81 @@
+# Needed by Hirb::String to handle multibyte characters
+$KCODE = 'u' if RUBY_VERSION < '1.9'
+
+require 'hirb/util'
+require 'hirb/string'
+require 'hirb/formatter' # must come before helpers/auto_table
+require 'hirb/dynamic_view'
+require 'hirb/helpers'
+require 'hirb/views'
+require 'hirb/view'
+require 'hirb/console'
+require 'hirb/pager'
+require 'hirb/menu'
+require 'hirb/version'
+
+# Most of Hirb's functionality is in Hirb::View.
+# For a tutorial  on configuring and creating views see Hirb::View. For a tutorial on dynamic views see Hirb::DynamicView.
+#
+# == Config Files
+# Hirb can have multiple config files defined by config_files(). These config files
+# have the following top level keys:
+# [*:output*] This hash is used by the formatter object. See Hirb::Formatter.config for its format.
+# [*:width*]  Width of the terminal/console. Defaults to Hirb::View::DEFAULT_WIDTH or possibly autodetected when Hirb is enabled.
+# [*:height*]  Height of the terminal/console. Defaults to Hirb::View::DEFAULT_HEIGHT or possibly autodetected when Hirb is enabled.
+# [*:formatter*] Boolean which determines if the formatter is enabled. Defaults to true.
+# [*:pager*] Boolean which determines if the pager is enabled. Defaults to true.
+# [*:pager_command*] Command to be used for paging. Command can have options after it i.e. 'less -r'.
+#                    Defaults to common pagers i.e. less and more if detected.
+# [*:ignore_errors*] Boolean which ignores internal view errors and continues with original view
+#                    (i.e. #inspect for irb). Defaults to false.
+module Hirb
+  class <<self
+    attr_accessor :config_files, :config
+
+    # Enables view functionality. See Hirb::View.enable for details.
+    def enable(options={}, &block)
+      View.enable(options, &block)
+    end
+
+    # Disables view functionality. See Hirb::View.disable for details.
+    def disable
+      View.disable
+    end
+
+    # Adds views. See Hirb::View.add for details.
+    def add_view(view, options, &block)
+      View.add(view, options, &block)
+    end
+
+    # Adds views. See Hirb::DynamicView.add for details.
+    def add_dynamic_view(view, options, &block)
+      DynamicView.add(view, options, &block)
+    end
+
+    # Array of config files which are merged sequentially to produce config.
+    # Defaults to config/hirb.yml and ~/.hirb_yml
+    def config_files
+      @config_files ||= default_config_files
+    end
+
+    #:stopdoc:
+    def default_config_files
+      [File.join(Util.find_home, ".hirb.yml")] +
+        (File.exists?('config/hirb.yml') ? ['config/hirb.yml'] : [])
+    end
+
+    def read_config_file(file=config_file)
+      File.exists?(file) ? YAML::load_file(file) : {}
+    end
+
+    def config(reload=false)
+      if (@config.nil? || reload)
+        @config = config_files.inject({}) {|acc,e|
+          Util.recursive_hash_merge(acc,read_config_file(e))
+        }
+      end
+      @config
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/console.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/console.rb
new file mode 100644
index 0000000..fefb134
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/console.rb
@@ -0,0 +1,43 @@
+module Hirb
+  # This module is meant to be extended to provide methods for use in a console/irb shell.
+  # For example:
+  #    >> extend Hirb::Console
+  #    >> view 'some string', :class=>Some::String::Formatter
+  #    >> table [[:row1], [:row2]]
+  module Console
+    class<<self
+      # A console version of render_output() which takes its same options but allows for shorthand. All options are passed to
+      # the helper except for the formatter options. Formatter options are :class, :method and :output_method.
+      # Examples:
+      #   render_output output, :class=>:tree :type=>:directory
+      #   # is the same as:
+      #   render_output output, :class=>:tree, :options=> {:type=>:directory}
+      #
+      def render_output(output, options={})
+        View.load_config unless View.config_loaded?
+        View.render_output(output, options.merge(:console=>true))
+      end
+
+      # Takes same arguments and options as render_output() but returns formatted output instead of rendering it.
+      def format_output(output, options={}, &block)
+        View.load_config unless View.config_loaded?
+        View.formatter.format_output(output, options.merge(:console=>true), &block)
+      end
+    end
+
+    # Renders a table for the given object. Takes same options as Hirb::Helpers::Table.render.
+    def table(output, options={})
+      Console.render_output(output, options.merge(:class=>"Hirb::Helpers::AutoTable"))
+    end
+
+    # Renders any specified view for the given object. Takes same options as Hirb::View.render_output.
+    def view(output, options={})
+      Console.render_output(output, options)
+    end
+
+    # Renders a menu given an array using Hirb::Menu.render.
+    def menu(output, options={}, &block)
+      Console.format_output(output, options.merge(:class=>"Hirb::Menu"), &block)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/dynamic_view.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/dynamic_view.rb
new file mode 100644
index 0000000..31929f6
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/dynamic_view.rb
@@ -0,0 +1,113 @@
+module Hirb
+  # This module extends a Helper with the ability to have dynamic views for configured output classes.
+  # After a Helper has extended this module, it can use it within a render() by calling
+  # dynamic_options() to get dynamically generated options for the object it's rendering. See Hirb::Helpers::AutoTable as an example.
+  #
+  # == Dynamic Views
+  # Whereas normal views are generated from helpers with static helper options, dynamic views are generated from helpers and
+  # dynamically generated helper options. Let's look at an example for Rails' ActiveRecord classes:
+  #
+  #   Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj|
+  #    {:fields=>obj.class.column_names} }
+  #
+  # From this dynamic view definition, _any_ ActiveRecord model class will render a table with the correct fields, since the fields
+  # are extracted from the output object's class at runtime. Note that dynamic view definitions should return a hash of helper options.
+  #
+  # To define multiple dynamic views, create a Views module where each method ending in '\_view' maps to a class/module:
+  #
+  #   module Hirb::Views::ORM
+  #     def data_mapper__resource_view(obj)
+  #       {:fields=>obj.class.properties.map {|e| e.name }}
+  #     end
+  #
+  #     def sequel__model_view(obj)
+  #       {:fields=>obj.class.columns}
+  #     end
+  #   end
+  #
+  #   Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+  #
+  # In this example, 'data_mapper__resource_view' maps to DataMapper::Resource and 'sequel__model_view' maps to Sequel::Model.
+  # Note that when mapping method names to class names, '__' maps to '::' and '_' signals the next letter to be capitalized.
+  module DynamicView
+    # Add dynamic views to output class(es) for a given helper. If defining one view, the first argument is the output class
+    # and a block defines the dynamic view. If defining multiple views, the first argument should be a Views::* module where
+    # each method in the module ending in _view defines a view for an output class. To map output classes to method names in
+    # a Views module, translate'::' to '__' and a capital letter translates to a '_' and a lowercase letter.
+    # ==== Options:
+    # [*:helper*] Required option. Helper class that view(s) use to format. Hirb::Helpers::AutoTable is the only valid
+    #             helper among default helpers. Can be given in aliased form i.e. :auto_table -> Hirb::Helpers::AutoTable.
+    #
+    # Examples:
+    #    Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+    #    Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj| {:fields=>obj.class.column_names} }
+    def self.add(view, options, &block)
+      raise ArgumentError, ":helper option is required" unless options[:helper]
+      helper = Helpers.helper_class options[:helper]
+      unless helper.is_a?(Module) && class << helper; self.ancestors; end.include?(self)
+        raise ArgumentError, ":helper option must be a helper that has extended DynamicView"
+      end
+      mod = block ? generate_single_view_module(view, &block) : view
+      raise ArgumentError, "'#{mod}' must be a module" unless mod.is_a?(Module)
+      helper.add_module mod
+    end
+
+    def self.generate_single_view_module(output_mod, &block) #:nodoc:
+      meth = class_to_method output_mod.to_s
+      view_mod = meth.capitalize
+      Views::Single.send(:remove_const, view_mod) if Views::Single.const_defined?(view_mod)
+      mod = Views::Single.const_set(view_mod, Module.new)
+      mod.send(:define_method, meth, block)
+      mod
+    end
+
+    def self.class_to_method(mod) #:nodoc:
+      mod.gsub(/(?!^)([A-Z])/) {|e| '_'+e }.gsub('::_', '__').downcase + '_view'
+    end
+
+    # Returns a hash of options based on dynamic views defined for the object's ancestry. If no config is found returns nil.
+    def dynamic_options(obj)
+      view_methods.each do |meth|
+        if obj.class.ancestors.map {|e| e.to_s }.include?(method_to_class(meth))
+          begin
+            return send(meth, obj)
+          rescue
+            raise "View failed to generate for '#{method_to_class(meth)}' "+
+              "while in '#{meth}' with error:\n#{$!.message}"
+          end
+        end
+      end
+      nil
+    end
+
+    #:stopdoc:
+    def add_module(mod)
+      new_methods = mod.instance_methods.select {|e| e.to_s =~ /_view$/ }.map {|e| e.to_s}
+      return if new_methods.empty?
+      extend mod
+      view_methods.replace(view_methods + new_methods).uniq!
+      update_config(new_methods)
+    end
+
+    def update_config(meths)
+      output_config = meths.inject({}) {|t,e|
+        t[method_to_class(e)] = {:class=>self, :ancestor=>true}; t
+      }
+      Formatter.dynamic_config.merge! output_config
+    end
+
+    def method_to_class(meth)
+      view_method_classes[meth] ||= Util.camelize meth.sub(/_view$/, '').gsub('__', '/')
+    end
+
+    def view_method_classes
+      @view_method_classes ||= {}
+    end
+    #:startdoc:
+
+    # Stores view methods that a Helper has been given via DynamicView.add
+    def view_methods
+      @view_methods ||= []
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/formatter.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/formatter.rb
new file mode 100644
index 0000000..7c1569f
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/formatter.rb
@@ -0,0 +1,116 @@
+module Hirb
+  # A Formatter object formats an output object (using Formatter.format_output) into a string based on the views defined
+  # for its class and/or ancestry.
+  class Formatter
+    class<<self
+      # This config is used by Formatter.format_output to lazily load dynamic views defined with Hirb::DynamicView.
+      # This hash has the same format as Formatter.config.
+      attr_accessor :dynamic_config
+    end
+    self.dynamic_config = {}
+
+    def initialize(additional_config={}) #:nodoc:
+      @klass_config = {}
+      @config = additional_config || {}
+    end
+
+    # A hash of Ruby class strings mapped to view hashes. A view hash must have at least a :method, :output_method
+    # or :class option for a view to be applied to an output. A view hash has the following keys:
+    # [*:method*] Specifies a global (Kernel) method to do the formatting.
+    # [*:class*] Specifies a class to do the formatting, using its render() class method. If a symbol it's converted to a corresponding
+    #            Hirb::Helpers::* class if it exists.
+    # [*:output_method*] Specifies a method or proc to call on output before passing it to a helper. If the output is an array, it's applied
+    #                    to every element in the array.
+    # [*:options*] Options to pass the helper method or class.
+    # [*:ancestor*] Boolean which when true causes subclasses of the output class to inherit its config. This doesn't effect the current
+    #               output class. Defaults to false. This is used by ActiveRecord classes.
+    # 
+    #   Examples:
+    #     {'WWW::Delicious::Element'=>{:class=>'Hirb::Helpers::ObjectTable', :ancestor=>true, :options=>{:max_width=>180}}}
+    #     {'Date'=>{:class=>:auto_table, :ancestor=>true}}
+    #     {'Hash'=>{:method=>:puts}}
+    def config
+      @config
+    end
+
+    # Adds the view for the given class and view hash config. See Formatter.config for valid keys for view hash.
+    def add_view(klass, view_config)
+      @klass_config.delete(klass)
+      @config[klass.to_s] = view_config
+      true
+    end
+
+    # This method looks for an output object's view in Formatter.config and then Formatter.dynamic_config.
+    # If a view is found, a stringified view is returned based on the object. If no view is found, nil is returned. The options this
+    # class takes are a view hash as described in Formatter.config. These options will be merged with any existing helper
+    # config hash an output class has in Formatter.config. Any block given is passed along to a helper class.
+    def format_output(output, options={}, &block)
+      output_class = determine_output_class(output)
+      options = parse_console_options(options) if options.delete(:console)
+      options = Util.recursive_hash_merge(klass_config(output_class), options)
+      _format_output(output, options, &block)
+    end
+
+    #:stopdoc:
+    def _format_output(output, options, &block)
+      output = options[:output_method] ? (output.is_a?(Array) ?
+        output.map {|e| call_output_method(options[:output_method], e) } :
+        call_output_method(options[:output_method], output) ) : output
+      args = [output]
+      args << options[:options] if options[:options] && !options[:options].empty?
+      if options[:method]
+        send(options[:method],*args)
+      elsif options[:class] && (helper_class = Helpers.helper_class(options[:class]))
+        helper_class.render(*args, &block)
+      elsif options[:output_method]
+        output
+      end
+    end
+
+    def parse_console_options(options) #:nodoc:
+      real_options = [:method, :class, :output_method].inject({}) do |h, e|
+        h[e] = options.delete(e) if options[e]; h
+      end
+      real_options.merge! :options=>options
+    end
+
+    def determine_output_class(output)
+      output.respond_to?(:to_a) ? Array(output)[0].class : output.class
+    end
+
+    def call_output_method(output_method, output)
+      output_method.is_a?(Proc) ? output_method.call(output) : output.send(output_method)
+    end
+
+    # Internal view options built from user-defined ones. Options are built by recursively merging options from oldest
+    # ancestors to the most recent ones.
+    def klass_config(output_class)
+      @klass_config[output_class] ||= build_klass_config(output_class)
+    end
+
+    def build_klass_config(output_class)
+      output_ancestors = output_class.ancestors.map {|e| e.to_s}.reverse
+      output_ancestors.pop
+      hash = output_ancestors.inject({}) {|h, klass|
+        add_klass_config_if_true(h, klass) {|c,klass| c[klass] && c[klass][:ancestor] }
+      }
+      add_klass_config_if_true(hash, output_class.to_s) {|c,klass| c[klass] }
+    end
+
+    def add_klass_config_if_true(hash, klass)
+      if yield(@config, klass)
+        Util.recursive_hash_merge hash, @config[klass]
+      elsif yield(self.class.dynamic_config, klass)
+        @config[klass] = self.class.dynamic_config[klass].dup # copy to local
+        Util.recursive_hash_merge hash, self.class.dynamic_config[klass]
+      else
+        hash
+      end
+    end
+
+    def reset_klass_config
+      @klass_config = {}
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers.rb
new file mode 100644
index 0000000..4c8bbd6
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers.rb
@@ -0,0 +1,17 @@
+module Hirb
+  module Helpers #:nodoc:
+    @helper_classes ||= {}
+    def self.helper_class(klass)
+      @helper_classes[klass.to_s] ||= begin
+        if (helper_class = constants.find {|e| e.to_s == Util.camelize(klass.to_s)})
+          klass = "Hirb::Helpers::#{helper_class}"
+        end
+        Util.any_const_get(klass)
+      end
+    end
+  end
+end
+
+%w{table object_table auto_table tree parent_child_tree vertical_table}.each do |e|
+  require "hirb/helpers/#{e}"
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/auto_table.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/auto_table.rb
new file mode 100644
index 0000000..ed31357
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/auto_table.rb
@@ -0,0 +1,24 @@
+# This helper wraps around the other table helpers i.e. Hirb::Helpers::Table while
+# providing default helper options via Hirb::DynamicView. Using these default options, this
+# helper supports views for the following modules/classes:
+# ActiveRecord::Base, CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+# DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+# Mongoid::Document, Ripple::Document, Sequel::Model.
+class Hirb::Helpers::AutoTable < Hirb::Helpers::Table
+  extend Hirb::DynamicView
+
+  # Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:table_class] Explicit table class to use for rendering. Defaults to
+  #                Hirb::Helpers::ObjectTable if output is not an Array or Hash. Otherwise
+  #                defaults to Hirb::Helpers::Table.
+  def self.render(output, options={})
+    output = Array(output)
+    (defaults = dynamic_options(output[0])) && (options = defaults.merge(options))
+    klass = options.delete(:table_class) || (
+      !(output[0].is_a?(Hash) || output[0].is_a?(Array)) ?
+      Hirb::Helpers::ObjectTable : Hirb::Helpers::Table)
+    klass.render(output, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/object_table.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/object_table.rb
new file mode 100644
index 0000000..6227dac
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/object_table.rb
@@ -0,0 +1,14 @@
+class Hirb::Helpers::ObjectTable < Hirb::Helpers::Table
+  # Rows are any ruby objects. Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:fields] Methods of the object to represent as columns. Defaults to [:to_s].
+  def self.render(rows, options ={})
+    options[:fields] ||= [:to_s]
+    options[:headers] ||= {:to_s=>'value'} if options[:fields] == [:to_s]
+    item_hashes = options[:fields].empty? ? [] : Array(rows).inject([]) {|t,item|
+      t << options[:fields].inject({}) {|h,f| h[f] = item.__send__(f); h}
+    }
+    super(item_hashes, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/parent_child_tree.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/parent_child_tree.rb
new file mode 100644
index 0000000..d056057
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/parent_child_tree.rb
@@ -0,0 +1,24 @@
+class Hirb::Helpers::ParentChildTree < Hirb::Helpers::Tree
+  class <<self
+    # Starting with the given node, this builds a tree by recursively calling a children method.
+    # Takes same options as Hirb::Helper::Table.render with some additional ones below.
+    # ==== Options:
+    # [:value_method] Method or proc to call to display as a node's value. If not given, uses :name if node
+    #                 responds to :name or defaults to :object_id.
+    # [:children_method] Method or proc to call to obtain a node's children. Default is :children.
+    def render(root_node, options={})
+      value_method = options[:value_method] || (root_node.respond_to?(:name) ? :name : :object_id)
+      @value_method = value_method.is_a?(Proc) ? value_method : lambda {|n| n.send(value_method) }
+      children_method = options[:children_method] || :children
+      @children_method = children_method.is_a?(Proc) ? children_method : lambda {|n| n.send(children_method)}
+      @nodes = []
+      build_node(root_node, 0)
+      super(@nodes, options)
+    end
+
+    def build_node(node, level) #:nodoc:
+      @nodes << {:value=>@value_method.call(node), :level=>level}
+      @children_method.call(node).each {|e| build_node(e, level + 1)}
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table.rb
new file mode 100644
index 0000000..de51309
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table.rb
@@ -0,0 +1,323 @@
+require 'hirb/helpers/table/filters'
+require 'hirb/helpers/table/resizer'
+
+module Hirb
+# Base Table class from which other table classes inherit.
+# By default, a table is constrained to a default width but this can be adjusted
+# via the max_width option or Hirb::View.width.
+# Rows can be an array of arrays or an array of hashes.
+#
+# An array of arrays ie [[1,2], [2,3]], would render:
+#   +---+---+
+#   | 0 | 1 |
+#   +---+---+
+#   | 1 | 2 |
+#   | 2 | 3 |
+#   +---+---+
+#
+# By default, the fields/columns are the numerical indices of the array.
+# 
+# An array of hashes ie [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], would render:
+#   +-----+--------+
+#   | age | weight |
+#   +-----+--------+
+#   | 10  | 100    |
+#   | 80  | 500    |
+#   +-----+--------+
+#
+# By default, the fields/columns are the keys of the first hash.
+#
+# === Custom Callbacks
+# Callback methods can be defined to add your own options that modify rows right before they are rendered.
+# Here's an example that allows for searching with a :query option:
+#   module Query
+#     # Searches fields given a query hash
+#     def query_callback(rows, options)
+#       return rows unless options[:query]
+#       options[:query].map {|field,query|
+#         rows.select {|e| e[field].to_s =~ /#{query}/i }
+#       }.flatten.uniq
+#     end
+#   end
+#   Hirb::Helpers::Table.send :include, Query
+#
+#   >> puts Hirb::Helpers::Table.render [{:name=>'batman'}, {:name=>'robin'}], :query=>{:name=>'rob'}
+#   +-------+
+#   | name  |
+#   +-------+
+#   | robin |
+#   +-------+
+#   1 row in set
+#
+# Callback methods:
+# * must be defined in Helpers::Table and end in '_callback'.
+# * should expect rows and a hash of render options. Rows will be an array of hashes.
+# * are expected to return an array of hashes.
+# * are invoked in alphabetical order.
+# For a thorough example, see {Boson::Pipe}[http://github.com/cldwalker/boson/blob/master/lib/boson/pipe.rb].
+#--
+# derived from http://gist.github.com/72234
+ class Helpers::Table
+  BORDER_LENGTH = 3 # " | " and "-+-" are the borders
+  MIN_FIELD_LENGTH = 3
+  class TooManyFieldsForWidthError < StandardError; end
+
+  class << self
+    
+    # Main method which returns a formatted table.
+    # ==== Options:
+    # [*:fields*] An array which overrides the default fields and can be used to indicate field order.
+    # [*:headers*] A hash of fields and their header names. Fields that aren't specified here default to their name.
+    #              When set to false, headers are hidden. Can also be an array but only for array rows.
+    # [*:max_fields*] A hash of fields and their maximum allowed lengths. Maximum length can also be a percentage of the total width
+    #                 (decimal less than one). When a field exceeds it's maximum then it's
+    #                 truncated and has a ... appended to it. Fields that aren't specified have no maximum.
+    # [*:max_width*] The maximum allowed width of all fields put together including field borders. Only valid when :resize is true.
+    #                Default is Hirb::View.width.
+    # [*:resize*] Resizes table to display all columns in allowed :max_width. Default is true. Setting this false will display the full
+    #             length of each field.
+    # [*:number*] When set to true, numbers rows by adding a :hirb_number column as the first column. Default is false.
+    # [*:change_fields*] A hash to change old field names to new field names. This can also be an array of new names but only for array rows.
+    #                    This is useful when wanting to change auto-generated keys to more user-friendly names i.e. for array rows.
+    # [*:filters*] A hash of fields and their filters, applied to every row in a field. A filter can be a proc, an instance method
+    #              applied to the field value or a Filters method. Also see the filter_classes attribute below.
+    # [*:header_filter*] A filter, like one in :filters, that is applied to all headers after the :headers option.
+    # [*:filter_any*] When set to true, any cell defaults to being filtered by its class in :filter_classes.
+    #                 Default Hirb::Helpers::Table.filter_any().
+    # [*:filter_classes*] Hash which maps classes to filters. Default is Hirb::Helpers::Table.filter_classes().
+    # [*:vertical*] When set to true, renders a vertical table using Hirb::Helpers::VerticalTable. Default is false.
+    # [*:all_fields*] When set to true, renders fields in all rows. Valid only in rows that are hashes. Default is false.
+    # [*:description*] When set to true, renders row count description at bottom. Default is true.
+    # [*:escape_special_chars*] When set to true, escapes special characters \n,\t,\r so they don't disrupt tables. Default is false for
+    #                           vertical tables and true for anything else.
+    # Examples:
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]]
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]], :max_fields=>{0=>10}, :header_filter=>:capitalize
+    #    Hirb::Helpers::Table.render [['a',1], ['b',2]], :change_fields=>%w{letters numbers}, :max_fields=>{'numbers'=>0.4}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}]
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :headers=>{:weight=>"Weight(lbs)"}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :filters=>{:age=>[:to_f]}
+    def render(rows, options={})
+      options[:vertical] ? Helpers::VerticalTable.render(rows, options) :
+      new(rows, options).render
+    rescue TooManyFieldsForWidthError
+      $stderr.puts "", "** Error: Too many fields for the current width. Configure your width " +
+        "and/or fields to avoid this error. Defaulting to a vertical table. **"
+      Helpers::VerticalTable.render(rows, options)
+    end
+
+    # A hash which maps a cell value's class to a filter. This serves to set a default filter per field if all of its
+    # values are a class in this hash. By default, Array values are comma joined and Hashes are inspected.
+    # See the :filter_any option to apply this filter per value.
+    attr_accessor :filter_classes
+    # Boolean which sets the default for :filter_any option.
+    attr_accessor :filter_any
+    # Holds last table object created
+    attr_accessor :last_table
+  end
+  self.filter_classes = { Array=>:comma_join, Hash=>:inspect }
+
+  #:stopdoc:
+  attr_accessor :width, :max_fields, :field_lengths, :fields
+  def initialize(rows, options={})
+    raise ArgumentError, "Table must be an array of hashes or array of arrays" unless rows.is_a?(Array) &&
+      (rows[0].is_a?(Hash) or rows[0].is_a?(Array) or rows.empty?)
+    @options = {:description=>true, :filters=>{}, :change_fields=>{}, :escape_special_chars=>true,
+      :filter_any=>Helpers::Table.filter_any, :resize=>true}.merge(options)
+    @fields = set_fields(rows)
+    @rows = set_rows(rows)
+    @headers = set_headers
+    if @options[:number]
+      @headers[:hirb_number] = "number"
+      @fields.unshift :hirb_number
+    end
+    Helpers::Table.last_table = self
+  end
+
+  def set_fields(rows)
+    @options[:change_fields] = array_to_indices_hash(@options[:change_fields]) if @options[:change_fields].is_a?(Array)
+    return @options[:fields].dup if @options[:fields]
+
+    fields = if rows[0].is_a?(Hash)
+      keys = @options[:all_fields] ? rows.map {|e| e.keys}.flatten.uniq : rows[0].keys
+      keys.sort {|a,b| a.to_s <=> b.to_s}
+    else
+      rows[0].is_a?(Array) ? (0..rows[0].length - 1).to_a : []
+    end
+
+    @options[:change_fields].each do |oldf, newf|
+      (index = fields.index(oldf)) && fields[index] = newf
+    end
+    fields
+  end
+
+  def set_rows(rows)
+    rows = Array(rows)
+    if rows[0].is_a?(Array)
+      rows = rows.inject([]) {|new_rows, row|
+        new_rows << array_to_indices_hash(row)
+      }
+    end
+    @options[:change_fields].each do |oldf, newf|
+      rows.each {|e| e[newf] = e.delete(oldf) if e.key?(oldf) }
+    end
+    rows = filter_values(rows)
+    rows.each_with_index {|e,i| e[:hirb_number] = (i + 1).to_s} if @options[:number]
+    deleted_callbacks = Array(@options[:delete_callbacks]).map {|e| "#{e}_callback" }
+    (methods.grep(/_callback$/).map {|e| e.to_s} - deleted_callbacks).sort.each do |meth|
+      rows = send(meth, rows, @options.dup)
+    end
+    validate_values(rows)
+    rows
+  end
+
+  def set_headers
+    headers = @fields.inject({}) {|h,e| h[e] = e.to_s; h}
+    if @options.has_key?(:headers)
+      headers = @options[:headers].is_a?(Hash) ? headers.merge(@options[:headers]) :
+        (@options[:headers].is_a?(Array) ? array_to_indices_hash(@options[:headers]) : @options[:headers])
+    end
+    if @options[:header_filter]
+      headers.each {|k,v|
+        headers[k] = call_filter(@options[:header_filter], v)
+      }
+    end
+    headers
+  end
+
+  def render
+    body = []
+    unless @rows.length == 0
+      setup_field_lengths
+      body += render_header
+      body += render_rows
+      body += render_footer
+    end
+    body << render_table_description if @options[:description]
+    body.join("\n")
+  end
+
+  def render_header
+    @headers ? render_table_header : [render_border]
+  end
+
+  def render_footer
+    [render_border]
+  end
+
+  def render_table_header
+    title_row = '| ' + @fields.map {|f|
+      format_cell(@headers[f], @field_lengths[f])
+    }.join(' | ') + ' |'
+    [render_border, title_row, render_border]
+  end
+  
+  def render_border
+    '+-' + @fields.map {|f| '-' * @field_lengths[f] }.join('-+-') + '-+'
+  end
+  
+  def format_cell(value, cell_width)
+    text = String.size(value) > cell_width ?
+      (
+      (cell_width < 5) ? String.slice(value, 0, cell_width) : String.slice(value, 0, cell_width - 3) + '...'
+      ) : value
+    String.ljust(text, cell_width)
+  end
+
+  def render_rows
+    @rows.map do |row|
+      row = '| ' + @fields.map {|f|
+        format_cell(row[f], @field_lengths[f])
+      }.join(' | ') + ' |'
+    end
+  end
+  
+  def render_table_description
+    (@rows.length == 0) ? "0 rows in set" :
+      "#{@rows.length} #{@rows.length == 1 ? 'row' : 'rows'} in set"
+  end
+  
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+    if @options[:resize]
+      raise TooManyFieldsForWidthError if @fields.size > self.actual_width.to_f / MIN_FIELD_LENGTH
+      Resizer.resize!(self)
+    else
+      enforce_field_constraints
+    end
+  end
+
+  def enforce_field_constraints
+    max_fields.each {|k,max| @field_lengths[k] = max if @field_lengths[k].to_i > max }
+  end
+
+  def max_fields
+    @max_fields ||= (@options[:max_fields] ||= {}).each {|k,v|
+      @options[:max_fields][k] = (actual_width * v.to_f.abs).floor if v.to_f.abs < 1
+    }
+  end
+
+  def actual_width
+    @actual_width ||= self.width - (@fields.size * BORDER_LENGTH + 1)
+  end
+
+  def width
+    @width ||= @options[:max_width] || View.width
+  end
+
+  # find max length for each field; start with the headers
+  def default_field_lengths
+    field_lengths = @headers ? @headers.inject({}) {|h,(k,v)| h[k] = String.size(v); h} :
+      @fields.inject({}) {|h,e| h[e] = 1; h }
+    @rows.each do |row|
+      @fields.each do |field|
+        len = String.size(row[field])
+        field_lengths[field] = len if len > field_lengths[field].to_i
+      end
+    end
+    field_lengths
+  end
+
+  def set_filter_defaults(rows)
+    @filter_classes.each do |klass, filter|
+      @fields.each {|field|
+        if rows.all? {|r| r[field].class == klass }
+          @options[:filters][field] ||= filter
+        end
+      }
+    end
+  end
+
+  def filter_values(rows)
+    @filter_classes = Helpers::Table.filter_classes.merge @options[:filter_classes] || {}
+    set_filter_defaults(rows) unless @options[:filter_any]
+    rows.map {|row|
+      @fields.inject({}) {|new_row,f|
+        (filter = @options[:filters][f]) || (@options[:filter_any] && (filter = @filter_classes[row[f].class]))
+        new_row[f] = filter ? call_filter(filter, row[f]) : row[f]
+        new_row
+      }
+    }
+  end
+
+  def call_filter(filter, val)
+    filter.is_a?(Proc) ? filter.call(val) :
+      val.respond_to?(Array(filter)[0]) ? val.send(*filter) : Filters.send(filter, val)
+  end
+
+  def validate_values(rows)
+    rows.each {|row|
+      @fields.each {|f|
+        row[f] = row[f].to_s || ''
+        row[f] = row[f].gsub(/(\t|\r|\n)/) {|e| e.dump.gsub('"','') } if @options[:escape_special_chars]
+      }
+    }
+  end
+  
+  # Converts an array to a hash mapping a numerical index to its array value.
+  def array_to_indices_hash(array)
+    array.inject({}) {|hash,e|  hash[hash.size] = e; hash }
+  end
+  #:startdoc:
+end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table/filters.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table/filters.rb
new file mode 100644
index 0000000..46ba518
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table/filters.rb
@@ -0,0 +1,10 @@
+class Hirb::Helpers::Table
+  # Contains filter methods used by :filters option. To define a custom filter, simply open this module and create a method
+  # that take one argument, the value you will be filtering.
+  module Filters
+    extend self
+    def comma_join(arr) #:nodoc:
+      arr.join(', ')
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table/resizer.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table/resizer.rb
new file mode 100644
index 0000000..eadbc12
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/table/resizer.rb
@@ -0,0 +1,82 @@
+class Hirb::Helpers::Table
+  # Resizes a table's fields to the table's max width.
+  class Resizer
+    # Modifies field_lengths to fit within width. Also enforces a table's max_fields.
+    def self.resize!(table)
+      obj = new(table)
+      obj.resize
+      obj.field_lengths
+    end
+
+    #:stopdoc:
+    attr_reader :field_lengths
+    def initialize(table)
+      @table, @width, @field_size = table, table.actual_width, table.fields.size
+      @field_lengths = table.field_lengths
+      @original_field_lengths = @field_lengths.dup
+    end
+
+    def resize
+      adjust_long_fields || default_restrict_field_lengths
+      @table.enforce_field_constraints
+      add_extra_width
+    end
+
+    # Simple algorithm which allows smaller fields to be displayed while
+    # restricting longer fields to an average_long_field
+    def adjust_long_fields
+      while (total_length = sum(@field_lengths.values)) > @width
+        average_field = total_length / @field_size.to_f
+        long_lengths = @field_lengths.values.select {|e| e > average_field }
+        return false if long_lengths.empty?
+
+        # adjusts average long field by ratio with @width
+        average_long_field = sum(long_lengths)/long_lengths.size * @width/total_length
+        @field_lengths.each {|f,length|
+          @field_lengths[f] = average_long_field if length > average_long_field
+        }
+      end
+      true
+    end
+
+    # Produces a field_lengths which meets the @width requirement
+    def default_restrict_field_lengths
+      original_total_length = sum @original_field_lengths.values
+      # set fields by their relative weight to original length
+      new_lengths = @original_field_lengths.inject({}) {|t,(k,v)|
+        t[k] = (v / original_total_length.to_f * @width).to_i; t  }
+
+      # set all fields the same if relative doesn't work
+      unless new_lengths.values.all? {|e| e > MIN_FIELD_LENGTH} && (sum(new_lengths.values) <= @width)
+        new_lengths = @field_lengths.inject({}) {|t,(k,v)| t[k] = @width / @field_size; t }
+      end
+      @field_lengths.each {|k,v| @field_lengths[k] = new_lengths[k] }
+    end
+
+    def add_extra_width
+      added_width = 0
+      extra_width = @width - sum(@field_lengths.values)
+      unmaxed_fields = @field_lengths.keys.select {|f| !remaining_width(f).zero? }
+      # order can affect which one gets the remainder so let's keep it consistent
+      unmaxed_fields = unmaxed_fields.sort_by {|e| e.to_s}
+
+      unmaxed_fields.each_with_index do |f, i|
+        extra_per_field = (extra_width - added_width) / (unmaxed_fields.size - i)
+        add_to_field = remaining_width(f) < extra_per_field ? remaining_width(f) : extra_per_field
+        added_width += add_to_field
+        @field_lengths[f] += add_to_field
+      end
+    end
+
+    def remaining_width(field)
+      (@remaining_width ||= {})[field] ||= begin
+        (@table.max_fields[field] || @original_field_lengths[field]) - @field_lengths[field]
+      end
+    end
+
+    def sum(arr)
+      arr.inject {|t,e| t += e }
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/tree.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/tree.rb
new file mode 100644
index 0000000..2697423
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/tree.rb
@@ -0,0 +1,181 @@
+# Base tree class which given an array of nodes produces different types of trees.
+# The types of trees currently are:
+# * basic:
+#    0
+#      1
+#        2
+#        3
+#      4
+# 
+# * directory:
+#    0
+#    |-- 1
+#    |   |-- 2
+#    |   `-- 3
+#    `-- 4
+# 
+# * number:
+#    1. 0
+#      1. 1
+#        1. 2
+#        2. 3
+#      2. 4 
+# 
+# Tree nodes can be given as an array of arrays or an array of hashes.
+# To render the above basic tree with an array of hashes:
+#   Hirb::Helpers::Tree.render([{:value=>0, :level=>0}, {:value=>1, :level=>1}, {:value=>2, :level=>2}, 
+#     {:value=>3, :level=>2}, {:value=>4, :level=>1}])
+# Note from the hash keys that :level refers to the depth of the tree while :value refers to the text displayed
+# for a node.
+#
+# To render the above basic tree with an array of arrays:
+#   Hirb::Helpers::Tree.render([[0,0], [1,1], [2,2], [2,3], [1,4]])
+# Note that the each array pair consists of the level and the value for the node.
+class Hirb::Helpers::Tree
+  class ParentlessNodeError < StandardError; end
+
+  class <<self
+    # Main method which renders a tree.
+    # ==== Options:
+    # [:type] Type of tree. Either :basic, :directory or :number. Default is :basic.
+    # [:validate] Boolean to validate tree. Checks to see if all nodes have parents. Raises ParentlessNodeError if
+    #             an invalid node is found. Default is false.
+    # [:indent] Number of spaces to indent between levels for basic + number trees. Default is 4.
+    # [:limit] Limits the level or depth of a tree that is displayed. Root node is level 0.
+    # [:description] Displays brief description about tree ie how many nodes it has.
+    # [:multi_line_nodes] Handles multi-lined nodes by indenting their newlines. Default is false.
+    #  Examples:
+    #     Hirb::Helpers::Tree.render([[0, 'root'], [1, 'child']], :type=>:directory)
+    def render(nodes, options={})
+      new(nodes, options).render
+    end
+  end
+
+  # :stopdoc:
+  attr_accessor :nodes
+  
+  def initialize(input_nodes, options={})
+    @options = options
+    @type = options[:type] || :basic
+    if input_nodes[0].is_a?(Array)
+      @nodes = input_nodes.map {|e| Node.new(:level=>e[0], :value=>e[1]) }
+    else
+      @nodes = input_nodes.map {|e| Node.new(e)}
+    end
+    @nodes.each_with_index {|e,i| e.merge!(:tree=>self, :index=>i)}
+    @nodes.each {|e| e[:value] = e[:value].to_s }
+    validate_nodes if options[:validate]
+    self
+  end
+
+  def render
+    body = render_tree
+    body += render_description if @options[:description]
+    body
+  end
+  
+  def render_description
+    "\n\n#{@nodes.length} #{@nodes.length == 1 ? 'node' : 'nodes'} in tree"
+  end
+
+  def render_tree
+    @indent = ' ' * (@options[:indent] || 4 )
+    @nodes = @nodes.select {|e| e[:level] <= @options[:limit] } if @options[:limit]
+    case @type.to_s
+    when 'directory' then render_directory
+    when 'number'    then render_number
+    else render_basic
+    end
+  end
+
+  def render_nodes
+    value_indent = @options[:multi_line_nodes] ? @indent : nil
+    @nodes.map {|e| yield(e) + e.value(value_indent) }.join("\n")
+  end
+
+  def render_directory
+    mark_last_nodes_per_level
+    render_nodes {|e|
+      value = ''
+      unless e.root?
+        value << e.render_parent_characters
+        value << (e[:last_node] ? "`-- " : "|-- ")
+      end
+      value
+    }
+  end
+  
+  def render_number
+    counter = {}
+    @nodes.each {|e|
+      parent_level_key = "#{(e.parent ||{})[:index]}.#{e[:level]}"
+      counter[parent_level_key] ||= 0
+      counter[parent_level_key] += 1
+      e[:pre_value] = "#{counter[parent_level_key]}. "
+    }
+    render_nodes {|e| @indent * e[:level] + e[:pre_value] }
+  end
+
+  def render_basic
+    render_nodes {|e| @indent * e[:level] }
+  end
+
+  def validate_nodes
+    @nodes.each do |e|
+      raise ParentlessNodeError if (e[:level] > e.previous[:level]) && (e[:level] - e.previous[:level]) > 1
+    end
+  end
+  
+  # walks tree accumulating last nodes per unique parent+level
+  def mark_last_nodes_per_level
+    @nodes.each {|e| e.delete(:last_node)}
+    last_node_hash = @nodes.inject({}) {|h,e|
+      h["#{(e.parent ||{})[:index]}.#{e[:level]}"] = e; h
+    }
+    last_node_hash.values.uniq.each {|e| e[:last_node] = true}
+  end
+  #:startdoc:
+  class Node < ::Hash #:nodoc:
+    class MissingLevelError < StandardError; end
+    class MissingValueError < StandardError; end
+    
+    def initialize(hash)
+      super
+      raise MissingLevelError unless hash.has_key?(:level)
+      raise MissingValueError unless hash.has_key?(:value)
+      replace(hash)
+    end
+
+    def value(indent=nil)
+      indent ? self[:value].gsub("\n", "\n#{indent * self[:level]}") : self[:value]
+    end
+
+    def parent
+      self[:tree].nodes.slice(0 .. self[:index]).reverse.detect {|e| e[:level] < self[:level]}
+    end
+
+    def next
+      self[:tree].nodes[self[:index] + 1]
+    end
+
+    def previous
+      self[:tree].nodes[self[:index] - 1]
+    end
+
+    def root?; self[:level] == 0; end
+
+    # refers to characters which connect parent nodes 
+    def render_parent_characters
+      parent_chars = []
+      get_parents_character(parent_chars)
+      parent_chars.reverse.map {|level| level + ' ' * 3 }.join('')
+    end
+
+    def get_parents_character(parent_chars)
+      if self.parent
+        parent_chars << (self.parent[:last_node] ? ' ' : '|') unless self.parent.root?
+        self.parent.get_parents_character(parent_chars)
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/vertical_table.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/vertical_table.rb
new file mode 100644
index 0000000..1f18f3e
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/helpers/vertical_table.rb
@@ -0,0 +1,37 @@
+class Hirb::Helpers::VerticalTable < Hirb::Helpers::Table
+
+  # Renders a vertical table using the same options as Hirb::Helpers::Table.render except for the ones below
+  # and :max_fields, :vertical and :max_width which aren't used.
+  # ==== Options:
+  # [:hide_empty] Boolean which hides empty values (nil or '') from being displayed. Default is false.
+  def self.render(rows, options={})
+    new(rows, {:escape_special_chars=>false, :resize=>false}.merge(options)).render
+  end
+
+  #:stopdoc:
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+  end
+
+  def render_header; []; end
+  def render_footer; []; end
+
+  def render_rows
+    i = 0
+    longest_header = Hirb::String.size @headers.values.sort_by {|e| Hirb::String.size(e) }.last
+    stars = "*" * [(longest_header + (longest_header / 2)), 3].max
+    @rows.map do |row|
+      row = "#{stars} #{i+1}. row #{stars}\n" +
+      @fields.map {|f|
+        if !@options[:hide_empty] || (@options[:hide_empty] && !row[f].empty?)
+          "#{Hirb::String.rjust(@headers[f], longest_header)}: #{row[f]}"
+        else
+          nil
+        end
+      }.compact.join("\n")
+      i+= 1
+      row
+    end
+  end
+  #:startdoc:
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/import_object.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/import_object.rb
new file mode 100644
index 0000000..8bd0f1f
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/import_object.rb
@@ -0,0 +1,10 @@
+module Hirb
+  module ObjectMethods
+    # Takes same options as Hirb::View.render_output.
+    def view(*args)
+      Hirb::Console.render_output(*(args.unshift(self)))
+    end
+  end
+end
+
+Object.send :include, Hirb::ObjectMethods
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/menu.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/menu.rb
new file mode 100644
index 0000000..ffafd14
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/menu.rb
@@ -0,0 +1,221 @@
+module Hirb
+  # This class provides a menu using Hirb's table helpers by default to display choices.
+  # Menu choices (syntax at Hirb::Util.choose_from_array) refer to rows. However, when in
+  # two_d mode, choices refer to specific cells by appending a ':field' to a choice.
+  # A field name can be an abbreviated. Menus can also have an action mode, which turns the
+  # menu prompt into a commandline that executes the choices as arguments and uses methods as
+  # actions/commands.
+  class Menu
+    class Error < StandardError; end
+
+    # Detects valid choices and optional field/column
+    CHOSEN_REGEXP = /^(\d([^:]+)?)(?::)?(\S+)?/
+    CHOSEN_ARG = '%s'
+    DIRECTIONS = "Specify individual choices (4,7), range of choices (1-3) or all choices (*)."
+
+
+    # This method will return an array unless it's exited by simply pressing return, which returns nil.
+    # If given a block, the block will yield if and with any menu items are chosen.
+    # All options except for the ones below are passed to render the menu.
+    #
+    # ==== Options:
+    # [*:helper_class*]  Helper class to render menu. Helper class is expected to implement numbering given a :number option.
+    #                    To use a very basic menu, set this to false. Defaults to Hirb::Helpers::AutoTable.
+    # [*:prompt*]  String for menu prompt. Defaults to "Choose: ".
+    # [*:ask*] Always ask for input, even if there is only one choice. Default is true.
+    # [*:directions*] Display directions before prompt. Default is true.
+    # [*:readline*] Use readline to get user input if available. Input strings are added to readline history. Default is false.
+    # [*:two_d*] Turn menu into a 2 dimensional (2D) menu by allowing user to pick values from table cells. Default is false.
+    # [*:default_field*] Default field for a 2D menu. Defaults to first field in a table.
+    # [*:action*] Turn menu into an action menu by letting user pass menu choices as an argument to a method/command.
+    #             A menu choice's place amongst other arguments is preserved. Default is false.
+    # [*:multi_action*] Execute action menu multiple times iterating over the menu choices. Default is false.
+    # [*:action_object*] Object that takes method/command calls. Default is main.
+    # [*:command*] Default method/command to call when no command given.
+    # [*:reopen*] Reopens $stdin with given file or with /dev/tty when set to true. Use when
+    #             $stdin is already reading in piped data.
+    # Examples:
+    #     >> extend Hirb::Console
+    #     => self
+    #     >> menu [1,2,3], :prompt=> "So many choices, so little time: "
+    #     >> menu [{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:a,b], :two_d=>true)
+    def self.render(output, options={}, &block)
+      new(options).render(output, &block)
+    rescue Error=>e
+      $stderr.puts "Error: #{e.message}"
+    end
+
+    #:stopdoc:
+    def initialize(options={})
+      @options = {:helper_class=>Hirb::Helpers::AutoTable, :prompt=>"Choose: ", :ask=>true,
+        :directions=>true}.merge options
+      @options[:reopen] = '/dev/tty' if @options[:reopen] == true
+    end
+
+    def render(output, &block)
+      @output = Array(output)
+      return [] if @output.size.zero?
+      chosen = choose_from_menu
+      block.call(chosen) if block && chosen.size > 0
+      @options[:action] ? execute_action(chosen) : chosen
+    end
+
+    def get_input
+      prompt = pre_prompt + @options[:prompt]
+      prompt = DIRECTIONS+"\n"+prompt if @options[:directions]
+      $stdin.reopen @options[:reopen] if @options[:reopen]
+
+      if @options[:readline] && readline_loads?
+        get_readline_input(prompt)
+      else
+        print prompt
+        $stdin.gets.chomp.strip
+      end
+    end
+
+    def get_readline_input(prompt)
+      input = Readline.readline prompt
+      Readline::HISTORY << input
+      input
+    end
+
+    def pre_prompt
+      prompt = ''
+      prompt << "Default field: #{default_field}\n" if @options[:two_d] && default_field
+      prompt << "Default command: #{@options[:command]}\n" if @options[:action] && @options[:command]
+      prompt
+    end
+
+    def choose_from_menu
+      return unasked_choice if @output.size == 1 && !@options[:ask]
+
+      if (helper_class = Util.any_const_get(@options[:helper_class]))
+        View.render_output(@output, :class=>@options[:helper_class], :options=>@options.merge(:number=>true))
+      else
+        @output.each_with_index {|e,i| puts "#{i+1}: #{e}" }
+      end
+
+      parse_input get_input
+    end
+
+    def unasked_choice
+      return @output unless @options[:action]
+      raise(Error, "Default command and field required for unasked action menu") unless default_field && @options[:command]
+      @new_args = [@options[:command], CHOSEN_ARG]
+      map_tokens([[@output, default_field]])
+    end
+
+    def execute_action(chosen)
+      return nil if chosen.size.zero?
+      if @options[:multi_action]
+        chosen.each {|e| invoke command, add_chosen_to_args(e) }
+      else
+        invoke command, add_chosen_to_args(chosen)
+      end
+    end
+
+    def invoke(cmd, args)
+      action_object.send(cmd, *args)
+    end
+
+    def parse_input(input)
+      if (@options[:two_d] || @options[:action])
+        tokens = input_to_tokens(input)
+        map_tokens(tokens)
+      else
+        Util.choose_from_array(@output, input)
+      end
+    end
+
+    def map_tokens(tokens)
+      if return_cell_values?
+        @output[0].is_a?(Hash) ? tokens.map {|arr,f| arr.map {|e| e[f]} }.flatten :
+          tokens.map {|arr,f|
+            arr.map {|e| e.is_a?(Array) && f.is_a?(Integer) ? e[f] : e.send(f) }
+          }.flatten
+      else
+        tokens.map {|e| e[0] }.flatten
+      end
+    end
+
+    def return_cell_values?
+      @options[:two_d]
+    end
+
+    def input_to_tokens(input)
+      @new_args = []
+      tokens = (@args = split_input_args(input)).map {|word| parse_word(word) }.compact
+      cleanup_new_args
+      tokens
+    end
+
+    def parse_word(word)
+      if word[CHOSEN_REGEXP]
+        @new_args << CHOSEN_ARG
+        field = $3 ? unalias_field($3) : default_field ||
+          raise(Error, "No default field/column found. Fields must be explicitly picked.")
+        [Util.choose_from_array(@output, word), field ]
+      else
+        @new_args << word
+        nil
+      end
+    end
+
+    def cleanup_new_args
+      if @new_args.all? {|e| e == CHOSEN_ARG }
+        @new_args = [CHOSEN_ARG]
+      else
+        i = @new_args.index(CHOSEN_ARG) || raise(Error, "No rows chosen")
+        @new_args.delete(CHOSEN_ARG)
+        @new_args.insert(i, CHOSEN_ARG)
+      end
+    end
+
+    def add_chosen_to_args(items)
+      args = @new_args.dup
+      args[args.index(CHOSEN_ARG)] = items
+      args
+    end
+
+    def command
+      @command ||= begin
+        cmd = (@new_args == [CHOSEN_ARG]) ? nil : @new_args.shift
+        cmd ||= @options[:command] || raise(Error, "No command given for action menu")
+      end
+    end
+
+    def action_object
+      @options[:action_object] || eval("self", TOPLEVEL_BINDING)
+    end
+
+    def split_input_args(input)
+      input.split(/\s+/)
+    end
+
+    def default_field
+      @default_field ||= @options[:default_field] || fields[0]
+    end
+
+    # Has to be called after displaying menu
+    def fields
+      @fields ||= @options[:fields] || (@options[:ask] && table_helper_class? && Helpers::Table.last_table ?
+        Helpers::Table.last_table.fields[1..-1] : [])
+    end
+
+    def table_helper_class?
+      @options[:helper_class].is_a?(Class) && @options[:helper_class] < Helpers::Table
+    end
+
+    def unalias_field(field)
+      fields.sort_by {|e| e.to_s }.find {|e| e.to_s[/^#{field}/] } || raise(Error, "Invalid field '#{field}'")
+    end
+
+    def readline_loads?
+      require 'readline'
+      true
+    rescue LoadError
+      false
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/pager.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/pager.rb
new file mode 100644
index 0000000..8ff1250
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/pager.rb
@@ -0,0 +1,95 @@
+module Hirb
+  # This class provides class methods for paging and an object which can conditionally page given a terminal size that is exceeded.
+  class Pager
+    class<<self
+      # Pages using a configured or detected shell command.
+      def command_pager(output, options={})
+        basic_pager(output) if valid_pager_command?(options[:pager_command])
+      end
+
+      def pager_command(*commands) #:nodoc:
+        @pager_command = (!@pager_command.nil? && commands.empty?) ? @pager_command : 
+          begin
+            commands = [ENV['PAGER'], 'less', 'more', 'pager'] if commands.empty?
+            commands.compact.uniq.find {|e| Util.command_exists?(e[/\w+/]) }
+          end
+      end
+
+      # Pages with a ruby-only pager which either pages or quits.
+      def default_pager(output, options={})
+        pager = new(options[:width], options[:height])
+        while pager.activated_by?(output, options[:inspect])
+          puts pager.slice!(output, options[:inspect])
+          return unless continue_paging?
+        end
+        puts output
+        puts "=== Pager finished. ==="
+      end
+
+      #:stopdoc:
+      def valid_pager_command?(cmd)
+        cmd ? pager_command(cmd) : pager_command
+      end
+
+      private
+      def basic_pager(output)
+        pager = IO.popen(pager_command, "w")
+        begin
+          save_stdout = STDOUT.clone
+          STDOUT.reopen(pager)
+          STDOUT.puts output
+        rescue Errno::EPIPE
+        ensure
+         STDOUT.reopen(save_stdout)
+         save_stdout.close
+         pager.close
+        end
+      end
+
+      def continue_paging?
+        puts "=== Press enter/return to continue or q to quit: ==="
+        !$stdin.gets.chomp[/q/i]
+      end
+      #:startdoc:
+    end
+
+    attr_reader :width, :height
+
+    def initialize(width, height, options={})
+      resize(width, height)
+      @pager_command = options[:pager_command] if options[:pager_command]
+    end
+
+    # Pages given string using configured pager.
+    def page(string, inspect_mode)
+      if self.class.valid_pager_command?(@pager_command)
+        self.class.command_pager(string, :pager_command=>@pager_command)
+      else
+        self.class.default_pager(string, :width=>@width, :height=>@height, :inspect=>inspect_mode)
+      end
+    end
+
+    def slice!(output, inspect_mode=false) #:nodoc:
+      effective_height = @height - 2 # takes into account pager prompt
+      if inspect_mode
+        sliced_output = String.slice(output, 0, @width * effective_height)
+        output.replace String.slice(output, @width * effective_height, String.size(output))
+        sliced_output
+      else
+        # could use output.scan(/[^\n]*\n?/) instead of split
+        sliced_output = output.split("\n").slice(0, effective_height).join("\n")
+        output.replace output.split("\n").slice(effective_height..-1).join("\n")
+        sliced_output
+      end
+    end
+
+    # Determines if string should be paged based on configured width and height.
+    def activated_by?(string_to_page, inspect_mode=false)
+      inspect_mode ? (String.size(string_to_page) > @height * @width) : (string_to_page.count("\n") > @height)
+    end
+
+    def resize(width, height) #:nodoc:
+      @width, @height = View.determine_terminal_size(width, height)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/string.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/string.rb
new file mode 100644
index 0000000..0d96585
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/string.rb
@@ -0,0 +1,44 @@
+module Hirb
+  # Provides string helpers to deal with UTF-8 and ruby 1.8.x
+  module String
+    extend self
+    # :stopdoc:
+    if RUBY_VERSION < '1.9'
+      def size(string)
+        string.scan(/./).length
+      end
+
+      def ljust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? string + " " * leftover : string
+      end
+
+      def rjust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? " " * leftover + string : string
+      end
+
+      def slice(string, start, finish)
+        string.scan(/./).slice(start, finish).join('')
+      end
+    else
+      def size(string)
+        string.length
+      end
+
+      def ljust(string, desired_length)
+        string.ljust(desired_length)
+      end
+
+      def rjust(string, desired_length)
+        string.rjust(desired_length)
+      end
+
+      def slice(*args)
+        string = args.shift
+        string.slice(*args)
+      end
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/util.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/util.rb
new file mode 100644
index 0000000..2db4b65
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/util.rb
@@ -0,0 +1,96 @@
+module Hirb
+  # Group of handy utility functions used throughout Hirb.
+  module Util
+    extend self
+    # Returns a constant like Module#const_get no matter what namespace it's nested in.
+    # Returns nil if the constant is not found.
+    def any_const_get(name)
+      return name if name.is_a?(Module)
+      begin
+        klass = Object
+        name.split('::').each {|e|
+          klass = klass.const_get(e)
+        }
+        klass
+      rescue
+         nil
+      end
+    end
+
+    # Recursively merge hash1 with hash2.
+    def recursive_hash_merge(hash1, hash2)
+      hash1.merge(hash2) {|k,o,n| (o.is_a?(Hash)) ? recursive_hash_merge(o,n) : n}
+    end
+
+    # From Rails ActiveSupport, converting undescored lowercase to camel uppercase.
+    def camelize(string)
+      string.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
+    end
+
+    # Used by Hirb::Menu to select items from an array. Array counting starts at 1. Ranges of numbers are specified with a '-' or '..'.
+    # Multiple ranges can be comma delimited. Anything that isn't a valid number is ignored. All elements can be returned with a '*'.
+    # Examples:
+    #    1-3,5-6 -> [1,2,3,5,6]
+    #    *   -> all elements in array
+    #    ''  -> [] 
+    def choose_from_array(array, input, options={})
+      options = {:splitter=>","}.merge(options)
+      return array if input.strip == '*'
+      result = []
+      input.split(options[:splitter]).each do |e|
+        if e =~ /-|\.\./
+          min,max = e.split(/-|\.\./)
+          slice_min = min.to_i - 1
+          result.push(*array.slice(slice_min, max.to_i - min.to_i + 1))
+        elsif e =~ /\s*(\d+)\s*/
+          index = $1.to_i - 1
+          next if index < 0
+          result.push(array[index]) if array[index]
+        end
+      end
+      result
+    end
+
+    # Determines if a shell command exists by searching for it in ENV['PATH'].
+    def command_exists?(command)
+      ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
+    end
+
+    # Returns [width, height] of terminal when detected, nil if not detected.
+    # Think of this as a simpler version of Highline's Highline::SystemExtensions.terminal_size()
+    def detect_terminal_size
+      if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
+        [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
+      elsif (RUBY_PLATFORM =~ /java/ || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
+        [`tput cols`.to_i, `tput lines`.to_i]
+      elsif STDIN.tty? && command_exists?('stty')
+        `stty size`.scan(/\d+/).map { |s| s.to_i }.reverse
+      else
+        nil
+      end
+    rescue
+      nil
+    end
+
+    # Captures STDOUT of anything run in its block and returns it as string.
+    def capture_stdout(&block)
+      original_stdout = $stdout
+      $stdout = fake = StringIO.new
+      begin
+        yield
+      ensure
+        $stdout = original_stdout
+      end
+      fake.string
+    end
+
+    # From Rubygems, determine a user's home.
+    def find_home
+      ['HOME', 'USERPROFILE'].each {|e| return ENV[e] if ENV[e] }
+      return "#{ENV['HOMEDRIVE']}#{ENV['HOMEPATH']}" if ENV['HOMEDRIVE'] && ENV['HOMEPATH']
+      File.expand_path("~")
+    rescue
+      File::ALT_SEPARATOR ? "C:/" : "/"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/version.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/version.rb
new file mode 100644
index 0000000..9115328
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/version.rb
@@ -0,0 +1,3 @@
+module Hirb
+  VERSION = '0.3.4'
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/view.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/view.rb
new file mode 100644
index 0000000..a2cfb92
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/view.rb
@@ -0,0 +1,284 @@
+module Hirb
+  # This class is responsible for managing all view-related functionality.
+  #
+  # == Create a View
+  # Let's create a simple view for Hash objects:
+  #   $ irb -rubygems
+  #   >> require 'hirb'
+  #   =>true
+  #   >> Hirb.enable
+  #   =>nil
+  #   >> require 'yaml'
+  #   =>true
+  #
+  #   # A view method is the smallest view
+  #   >> def yaml(output); output.to_yaml; end
+  #   => nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :method=>:yaml
+  #   => true
+  #
+  #   # Hashes now appear as yaml
+  #   >> {:a=>1, :b=>{:c=>3}}
+  #   ---
+  #   :a : 1
+  #   :b : 
+  #     :c : 3
+  #   => true
+  #
+  # Another way of creating a view is a Helper class:
+  #
+  #   # Create yaml view class
+  #   >> class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   =>nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :class=>Hirb::Helpers::Yaml
+  #   =>true
+  #
+  #   # Hashes appear as yaml like above ...
+  #
+  # == Configure a View
+  # To configure the above Helper class as a view, either pass Hirb.enable a hash:
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable :output=>{"Hash"=>{:class=>"Hirb::Helpers::Yaml"}}
+  #
+  # Or create a config file at config/hirb.yml or ~/.hirb.yml:
+  #   # The config file for the yaml example would look like:
+  #   # ---
+  #   # :output :
+  #   #   Hash :
+  #   #    :class : Hirb::Helpers::Yaml
+  #
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable
+  #
+  # For more about configuring Hirb, see the Config Files section in Hirb.
+  module View
+    DEFAULT_WIDTH = 120
+    DEFAULT_HEIGHT = 40
+    class<<self
+      attr_accessor :render_method
+      attr_reader :config
+
+      # This activates view functionality i.e. the formatter, pager and size detection. If irb exists, it overrides irb's output
+      # method with Hirb::View.view_output. When called multiple times, new configs are merged into the existing config.
+      # If using Wirble, you should call this after it. The view configuration can be specified in a hash via a config file,
+      # or as options to this method. In addition to the config keys mentioned in Hirb, options also take the following keys:
+      # ==== Options:
+      # * config_file: Name of config file(s) that are merged into existing config
+      # * output_method: Specify an object's class and instance method (separated by a period) to be realiased with
+      #   hirb's view system. The instance method should take a string to be output. Default is IRB::Irb.output_value
+      #   if using irb.
+      # Examples:
+      #   Hirb.enable
+      #   Hirb.enable :formatter=>false, :output_method=>"Mini.output"
+      def enable(options={}, &block)
+        Array(options.delete(:config_file)).each {|e|
+          @new_config_file = true
+          Hirb.config_files << e
+        }
+        enable_output_method(options.delete(:output_method))
+        merge_or_load_config options
+        resize(config[:width], config[:height])
+        @enabled = true
+      end
+
+      # Indicates if Hirb::View is enabled.
+      def enabled?
+        @enabled || false
+      end
+
+      # Disable's Hirb's output and revert's irb's output method if irb exists.
+      def disable
+        @enabled = false
+        unalias_output_method(@output_method) if @output_method
+        false
+      end
+
+      # Toggles pager on or off. The pager only works while Hirb::View is enabled.
+      def toggle_pager
+        config[:pager] = !config[:pager]
+      end
+
+      # Toggles formatter on or off.
+      def toggle_formatter
+        config[:formatter] = !config[:formatter]
+      end
+
+      # Resizes the console width and height for use with the table and pager i.e. after having resized the console window. *nix users
+      # should only have to call this method. Non-*nix users should call this method with explicit width and height. If you don't know
+      # your width and height, in irb play with "a"* width to find width and puts "a\n" * height to find height.
+      def resize(width=nil, height=nil)
+        config[:width], config[:height] = determine_terminal_size(width, height)
+        pager.resize(config[:width], config[:height])
+      end
+      
+      # This is the main method of this class. When view is enabled, this method searches for a formatter it can use for the output and if
+      # successful renders it using render_method(). The options this method takes are helper config hashes as described in 
+      # Hirb::Formatter.format_output(). Returns true if successful and false if no formatting is done or if not enabled.
+      def view_output(output, options={})
+        enabled? && config[:formatter] && render_output(output, options)
+      rescue Exception=>e
+        if config[:ignore_errors]
+          $stderr.puts "Hirb Error: #{e.message}"
+          false
+        else
+          index = (obj = e.backtrace.find {|f| f =~ /^\(eval\)/}) ? e.backtrace.index(obj) : e.backtrace.length
+          $stderr.puts "Hirb Error: #{e.message}", e.backtrace.slice(0,index).map {|e| "    " + e }
+          true
+        end
+      end
+
+      # Captures STDOUT and renders it using render_method(). The main use case is to conditionally page captured stdout.
+      def capture_and_render(&block)
+        render_method.call Util.capture_stdout(&block)
+      end
+
+      # A lambda or proc which handles the final formatted object.
+      # Although this pages/puts the object by default, it could be set to do other things
+      # i.e. write the formatted object to a file.
+      def render_method
+        @render_method ||= default_render_method
+      end
+
+      # Resets render_method back to its default.
+      def reset_render_method
+        @render_method = default_render_method
+      end
+      
+      # Current console width
+      def width
+        config && config[:width] ? config[:width] : DEFAULT_WIDTH
+      end
+
+      # Current console height
+      def height
+        config && config[:height] ? config[:height] : DEFAULT_HEIGHT
+      end
+
+      # Current formatter config, storing a hash of all static views
+      def formatter_config
+        formatter.config
+      end
+
+      # Adds a view when View is enabled. See Formatter.add_view for more details.
+      def add(klass, view_config)
+        if enabled?
+          formatter.add_view(klass, view_config)
+        else
+          puts "View must be enabled to add a view"
+        end
+      end
+
+      #:stopdoc:
+      def enable_output_method(meth)
+        if (meth ||= Object.const_defined?(:IRB) ? "IRB::Irb.output_value" : false) && !@output_method
+          @output_method = meth
+          alias_output_method(@output_method)
+        end
+      end
+
+      def unalias_output_method(output_method)
+        klass, klass_method = output_method.split(".")
+        eval %[
+          ::#{klass}.class_eval do
+            alias_method :#{klass_method}, :non_hirb_view_output
+          end
+        ]
+        @output_method = nil
+      end
+
+      def alias_output_method(output_method)
+        klass, klass_method = output_method.split(".")
+        eval %[
+          ::#{klass}.class_eval do
+            alias_method :non_hirb_view_output, :#{klass_method}
+            if '#{klass}' == "IRB::Irb"
+              def #{klass_method} #:nodoc:
+                Hirb::View.view_output(@context.last_value) || Hirb::View.page_output(@context.last_value.inspect, true) ||
+                  non_hirb_view_output
+              end
+            else
+              def #{klass_method}(output_string) #:nodoc:
+                Hirb::View.view_output(output_string) || Hirb::View.page_output(output_string.inspect, true) ||
+                  non_hirb_view_output(output_string)
+              end
+            end
+          end
+        ]
+      end
+
+      def render_output(output, options={})
+        if (formatted_output = formatter.format_output(output, options))
+          render_method.call(formatted_output)
+          true
+        else
+          false
+        end
+      end
+
+      def determine_terminal_size(width, height)
+        detected  = (width.nil? || height.nil?) ? Util.detect_terminal_size || [] : []
+        [width || detected[0] || DEFAULT_WIDTH , height || detected[1] || DEFAULT_HEIGHT]
+      end
+
+      def page_output(output, inspect_mode=false)
+        if enabled? && config[:pager] && pager.activated_by?(output, inspect_mode)
+          pager.page(output, inspect_mode)
+          true
+        else
+          false
+        end
+      end
+
+      def pager
+        @pager ||= Pager.new(config[:width], config[:height], :pager_command=>config[:pager_command])
+      end
+
+      def pager=(value); @pager = value; end
+
+      def formatter(reload=false)
+        @formatter = reload || @formatter.nil? ? Formatter.new(config[:output]) : @formatter
+      end
+
+      def formatter=(value); @formatter = value; end
+
+      def merge_or_load_config(additional_config={})
+        if @config && (@new_config_file || !additional_config.empty?)
+          Hirb.config = nil
+          load_config Util.recursive_hash_merge(@config, additional_config)
+          @new_config_file = false
+        elsif !@enabled
+          load_config(additional_config)
+        end
+      end
+
+      def load_config(additional_config={})
+        @config = Util.recursive_hash_merge default_config, additional_config
+        formatter(true)
+        true
+      end
+
+      def config_loaded?; !!@config; end
+
+      def config
+        @config
+      end
+      
+      def default_render_method
+        lambda {|output| page_output(output) || puts(output) }
+      end
+
+      def default_config
+        Util.recursive_hash_merge({:pager=>true, :formatter=>true}, Hirb.config || {})
+      end
+      #:startdoc:
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views.rb
new file mode 100644
index 0000000..330a802
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views.rb
@@ -0,0 +1,8 @@
+module Hirb
+  # Namespace for Helpers defining multiple views in a module i.e. via DynamicView.
+  module Views
+    module Single #:nodoc:
+    end
+  end
+end
+%w{rails orm mongo_db couch_db misc_db}.each {|e| require "hirb/views/#{e}" }
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/couch_db.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/couch_db.rb
new file mode 100644
index 0000000..ad4ef11
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/couch_db.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::CouchDb #:nodoc:
+  def default_couch(obj)
+    {:fields=>([:_id] + obj.class.properties.map {|e| e.name }) }
+  end
+
+  alias_method :couch_rest__extended_document_view, :default_couch
+  alias_method :couch_foo__base_view, :default_couch
+  alias_method :couch_potato__persistence_view, :default_couch
+end
+
+Hirb::DynamicView.add Hirb::Views::CouchDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/misc_db.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/misc_db.rb
new file mode 100644
index 0000000..48f8d1b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/misc_db.rb
@@ -0,0 +1,15 @@
+module Hirb::Views::MiscDb #:nodoc:
+  def friendly__document_view(obj)
+    {:fields=>obj.class.attributes.keys - [:id]}
+  end
+
+  def ripple__document_view(obj)
+    {:fields=>obj.class.properties.keys}
+  end
+
+  def d_b_i__row_view(obj)
+    {:fields=>obj.column_names, :table_class=>Hirb::Helpers::Table}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::MiscDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/mongo_db.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/mongo_db.rb
new file mode 100644
index 0000000..a79d35b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/mongo_db.rb
@@ -0,0 +1,14 @@
+module Hirb::Views::MongoDb #:nodoc:
+  def mongoid__document_view(obj)
+    {:fields=>['_id'] + obj.class.fields.keys}
+  end
+
+  def mongo_mapper__document_view(obj)
+    fields = obj.class.column_names
+    fields.delete('_id') && fields.unshift('_id')
+    {:fields=>fields}
+  end
+  alias_method :mongo_mapper__embedded_document_view, :mongo_mapper__document_view
+end
+
+Hirb::DynamicView.add Hirb::Views::MongoDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/orm.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/orm.rb
new file mode 100644
index 0000000..ded4b9b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/orm.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::ORM #:nodoc:
+  def data_mapper__resource_view(obj)
+    {:fields=>obj.class.properties.map {|e| e.name }}
+  end
+
+  def sequel__model_view(obj)
+    {:fields=>obj.class.columns}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::ORM, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/rails.rb b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/rails.rb
new file mode 100644
index 0000000..03105ff
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/lib/hirb/views/rails.rb
@@ -0,0 +1,19 @@
+module Hirb::Views::Rails #:nodoc:
+  def active_record__base_view(obj)
+    {:fields=>get_active_record_fields(obj)}
+  end
+
+  def get_active_record_fields(obj)
+    fields = obj.class.column_names.map {|e| e.to_sym }
+    # if query used select
+    if obj.attributes.keys.sort != obj.class.column_names.sort
+      selected_columns = obj.attributes.keys
+      sorted_columns = obj.class.column_names.dup.delete_if {|e| !selected_columns.include?(e) }
+      sorted_columns += (selected_columns - sorted_columns)
+      fields = sorted_columns.map {|e| e.to_sym}
+    end
+    fields
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::Rails, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/auto_table_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/auto_table_test.rb
new file mode 100644
index 0000000..8e90d9a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/auto_table_test.rb
@@ -0,0 +1,30 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "auto table" do
+  it "converts nonarrays to arrays and renders" do
+    require 'set'
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    +-------+
+    3 rows in set
+    TABLE
+    Helpers::AutoTable.render(::Set.new([1,2,3])).should == expected_table
+  end
+
+  it "renders hash" do
+    expected_table = <<-TABLE.unindent
+    +---+-------+
+    | 0 | 1     |
+    +---+-------+
+    | a | 12345 |
+    +---+-------+
+    1 row in set
+    TABLE
+    Helpers::AutoTable.render({:a=>12345}).should == expected_table
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/console_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/console_test.rb
new file mode 100644
index 0000000..b34a0ef
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/console_test.rb
@@ -0,0 +1,27 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Console" do
+  it "#table is called without Hirb enabled" do
+    extend Hirb::Console
+    reset_config
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 5     |
+    | 3     |
+    +-------+
+    2 rows in set
+    TABLE
+    capture_stdout {
+      table([5,3], :fields=>[:to_s])
+    }.should == expected_table +"\n"
+  end
+
+  it ".render_output sets config if it wasn't before" do
+    reset_config
+    View.expects(:render_output)
+    Console.render_output('blah')
+    View.config.is_a?(Hash).should == true
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/deps.rip b/lib/bbcloud/vendor/hirb-0.3.4/test/deps.rip
new file mode 100644
index 0000000..89eacd3
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/deps.rip
@@ -0,0 +1,4 @@
+bacon >=1.1.0
+mocha >=0
+mocha-on-bacon >=0
+bacon-bits >=0
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/dynamic_view_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/dynamic_view_test.rb
new file mode 100644
index 0000000..2523684
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/dynamic_view_test.rb
@@ -0,0 +1,94 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "DynamicView" do
+  def output_expects(output, expects)
+    Helpers::ObjectTable.expects(:render).with(output, expects)
+    Helpers::AutoTable.render(output)
+  end
+
+  describe "add" do
+    before_all { View.load_config }
+
+    it "raises error if no :helper option" do
+      lambda { Hirb.add_dynamic_view 'Blah', {} }.should.raise(ArgumentError).
+        message.should =~ /:helper.*required/
+    end
+
+    it "raises error if :helper option not a dynamic_view module" do
+      lambda { Hirb.add_dynamic_view('Blah', :helper=>:table) {|obj| } }.
+        should.raise(ArgumentError).message.should =~ /:helper.*must/
+    end
+
+    it "raises error if views module not a module" do
+      lambda { Hirb.add_dynamic_view 'Blah', :helper=>:auto_table }.should.raise(ArgumentError).
+        message.should =~ /must be a module/
+    end
+
+    it "adds a view with block" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "when adding views with a block, second view for same class overrides first one" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>[:blah]}
+      end
+      output_expects [Date.new], :fields=>[:blah]
+    end
+  end
+
+  it "class_to_method and method_to_class convert to each other" do
+    ["DBI::Row", "Hirb::View"].each do |e|
+      Helpers::AutoTable.method_to_class(DynamicView.class_to_method(e).downcase).should == e
+    end
+  end
+
+  it "class_to_method converts correctly" do
+    DynamicView.class_to_method("DBI::Row").should == 'd_b_i__row_view'
+  end
+
+  describe "dynamic_view" do
+    def define_view(mod_name= :Blah, &block)
+      mod = Views.const_set(mod_name, Module.new)
+      mod_block = block_given? ? block : lambda {|obj| {:fields=>obj.class::DAYNAMES}}
+      mod.send(:define_method, :date_view, mod_block)
+      Hirb.add_dynamic_view mod, :helper=>:auto_table
+    end
+
+    before_all { View.load_config }
+    before { Formatter.dynamic_config = {} }
+    after { Views.send(:remove_const, :Blah) }
+
+    it "sets a view's options" do
+      define_view
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "does override existing formatter dynamic_config" do
+      Formatter.dynamic_config["Date"] = {:class=>Helpers::Table}
+      define_view
+      Formatter.dynamic_config["Date"].should == {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+    end
+
+    it "raises a readable error when error occurs in a view" do
+      define_view {|obj| raise 'blah' }
+      lambda { Helpers::AutoTable.render([Date.new]) }.should.raise(RuntimeError).
+        message.should =~ /'Date'.*date_view.*\nblah/
+    end
+
+    it "another view can reuse an old view's options" do
+      define_view
+      define_view(:Blah2) do |obj|
+        {:fields=>obj.class::DAYNAMES + ['blah']}
+      end
+      output_expects [Date.new], :fields=>(Date::DAYNAMES + ['blah'])
+    end
+    after_all { reset_config }
+  end
+  after_all { Formatter.dynamic_config = {} }
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/formatter_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/formatter_test.rb
new file mode 100644
index 0000000..c96c5e8
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/formatter_test.rb
@@ -0,0 +1,171 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Formatter" do
+  def set_formatter(hash={})
+    @formatter = Formatter.new(hash)
+  end
+
+  describe "klass_config" do
+    it "recursively merges ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2], :options=>{:fields=>[:to_s]}},
+        "Object"=>{:method=>:object_output, :ancestor=>true, :options=>{:vertical=>true}},
+        "Kernel"=>{:method=>:default_output}
+      expected_result = {:method=>:object_output, :args=>[1, 2], :ancestor=>true, :options=>{:fields=>[:to_s], :vertical=>true}}
+      @formatter.klass_config(::String).should == expected_result
+    end
+
+    it "doesn't merge ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2]}, "Object"=>{:method=>:object_output},
+       "Kernel"=>{:method=>:default_output}
+      @formatter.klass_config(::String).should == {:args=>[1, 2]}
+    end
+
+    it "returns hash when nothing found" do
+      set_formatter.klass_config(::String).should == {}
+    end
+
+    describe "with dynamic_config" do
+      def set_formatter(hash={})
+        @formatter = Formatter.new(hash)
+      end
+      after { Formatter.dynamic_config = {}}
+
+      it "merges ancestor options and sets local config" do
+        Formatter.dynamic_config = {"Object"=>{:method=>:blah}, "Kernel"=>{:args=>[1,2], :ancestor=>true}}
+        set_formatter.klass_config(::String).should == {:args=>[1,2], :ancestor=>true}
+        @formatter.config['Kernel'].should == {:args=>[1,2], :ancestor=>true}
+      end
+
+      it "uses local config over dynamic_config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter "String"=>{:args=>[1,2]}
+        @formatter.klass_config(::String).should == {:args=>[1,2]}
+      end
+
+      it "uses dynamic_config and sets local config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter.klass_config(::String).should == {:method=>:blah}
+        @formatter.config['String'].should == {:method=>:blah}
+      end
+    end
+  end
+
+  describe "formatter methods:" do
+    before_all { eval "module ::Dooda; end" }
+
+    it "add_view sets formatter config" do
+      @formatter = set_formatter
+      @formatter.add_view ::Dooda, :class=>"DoodaView"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView"}
+    end
+
+    it "add_view overwrites existing formatter config" do
+      @formatter = set_formatter "Dooda"=>{:class=>"DoodaView"}
+      @formatter.add_view ::Dooda, :class=>"DoodaView2"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView2"}
+    end
+
+    it "parse_console_options passes all options except for formatter options into :options" do
+      @formatter = set_formatter
+      options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :blah=>'blah'}
+      expected_options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :options=>{:blah=>'blah'}}
+      @formatter.parse_console_options(options).should == expected_options
+    end
+  end
+
+  describe "format_output" do
+    def view_output(*args, &block); View.view_output(*args, &block); end
+    def render_method(*args); View.render_method(*args); end
+
+    def enable_with_output(value)
+      Hirb.enable :output=>value
+    end
+
+    before_all {
+      eval %[module ::Commify
+        def self.render(strings)
+          strings = Array(strings)
+          strings.map {|e| e.split('').join(',')}.join("\n")
+        end
+      end]
+      reset_config
+    }
+    before { View.formatter = nil; reset_config }
+    after { Hirb.disable }
+    
+    it "formats with method option" do
+      eval "module ::Kernel; def commify(string); string.split('').join(','); end; end"
+      enable_with_output "String"=>{:method=>:commify}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option as symbol" do
+      enable_with_output "String"=>{:class=>:auto_table}
+      Helpers::AutoTable.expects(:render)
+      view_output('dude')
+    end
+
+    it "formats arrays" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output(['dude'])
+    end
+
+    it "formats array-like objects" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      require 'set'
+      view_output Set.new(['dude'])
+    end
+    
+    it "formats with options option" do
+      eval "module ::Blahify; def self.render(*args); end; end"
+      enable_with_output "String"=>{:class=>"Blahify", :options=>{:fields=>%w{a b}}}
+      Blahify.expects(:render).with('dude', :fields=>%w{a b})
+      view_output('dude')
+    end
+    
+    it "doesn't format and returns false when no format method found" do
+      Hirb.enable
+      render_method.expects(:call).never
+      view_output(Date.today).should == false
+    end
+    
+    it "formats with output_method option as method" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats with output_method option as proc" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>lambda {|e| e.chop}}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats output array with output_method option" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with("d,u,d\nm,a")
+      view_output(['dude', 'man'])
+    end
+
+    it "formats with explicit class option" do
+      enable_with_output 'String'=>{:class=>"Blahify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude', :class=>"Commify")
+    end
+    
+    it "formats with explicit options option merges with existing options" do
+      enable_with_output "String"=>{:class=>"Commify", :options=>{:fields=>%w{f1 f2}}}
+      Commify.expects(:render).with('dude', :max_width=>10, :fields=>%w{f1 f2})
+      view_output('dude', :options=>{:max_width=>10})
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/hirb_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/hirb_test.rb
new file mode 100644
index 0000000..58edc95
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/hirb_test.rb
@@ -0,0 +1,39 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Hirb" do
+  before_all { Hirb.config_files = nil }
+  before { Hirb.config = nil }
+
+  it "config converts yaml when config file exists" do
+    yaml_data = {:blah=>'blah'}
+    File.stubs('exists?').returns(true)
+    Hirb.config_files = ['ok']
+    YAML::expects(:load_file).returns(yaml_data)
+    Hirb.config.should == yaml_data
+  end
+  
+  it "config defaults to hash when no config file" do
+    File.stubs('exists?').returns(false)
+    Hirb.config.should == {}
+  end
+  
+  it "config reloads if given explicit reload" do
+    Hirb.config
+    Hirb.expects(:read_config_file).returns({})
+    Hirb.config(true)
+  end
+
+  it "config reads multiple config files and merges them" do
+    Hirb.config_files = %w{one two}
+    Hirb.expects(:read_config_file).times(2).returns({:output=>{"String"=>:auto_table}}, {:output=>{"Array"=>:auto_table}})
+    Hirb.config.should == {:output=>{"Array"=>:auto_table, "String"=>:auto_table}}
+    Hirb.config_files = nil
+  end
+
+  it "config_file sets correctly when no ENV['HOME']" do
+    Hirb.config_files = nil
+    home = ENV.delete('HOME')
+    Hirb.config_files[0].class.should == String
+    ENV["HOME"] = home
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/import_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/import_test.rb
new file mode 100644
index 0000000..0a75368
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/import_test.rb
@@ -0,0 +1,9 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "import" do
+  it "require import_object extends Object" do
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == false
+    require 'hirb/import_object'
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == true
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/menu_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/menu_test.rb
new file mode 100644
index 0000000..d8f57db
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/menu_test.rb
@@ -0,0 +1,239 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Menu" do
+  before_all { View.instance_variable_set("@config", :width=>Hirb::View::DEFAULT_WIDTH) }
+
+  def menu(*args, &block)
+    # testing via menu's main use case (through console) instead of Menu.render
+    @console ||= Object.new.extend(Hirb::Console)
+    @console.menu(*args, &block)
+  end
+
+  def basic_menu(*args, &block)
+    menu_input('1')
+    capture_stdout { menu(*args, &block).should == [1] }
+  end
+
+  def menu_input(input='')
+    $stdin.expects(:gets).returns(input)
+  end
+
+  describe "menu" do
+    it "by default renders table menu" do
+      expected_menu = <<-MENU.unindent
+      +--------+-------+
+      | number | value |
+      +--------+-------+
+      | 1      | 1     |
+      | 2      | 2     |
+      | 3      | 3     |
+      +--------+-------+
+      3 rows in set
+      MENU
+      basic_menu([1,2,3]).include?(expected_menu).should == true
+    end
+
+    it "with block renders" do
+      menu_input "1,2"
+      expected_result = [1,2]
+      capture_stdout { 
+        menu([1,2,3]) {|e| e.should == expected_result }.should == expected_result
+      }
+    end
+
+    it "with block and no chosen doesn't call block" do
+      menu_input ""
+      block = lambda {|e| @called = true }
+      capture_stdout {
+        menu([1,2,3], &block).should == []
+      }
+      assert !@called
+    end
+
+    it "with valid helper_class option renders" do
+      Helpers::Table.expects(:render)
+      basic_menu [1,2,3], :helper_class=>"Hirb::Helpers::Table"
+    end
+
+    it "with invalid helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>"SomeHelper").include?(expected_menu).should == true
+    end
+
+    it "with false helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>false).include?(expected_menu).should == true
+    end
+
+    it "prints prompt option" do
+      prompt = "Input or else ..."
+      basic_menu([1,2,3], :prompt=>prompt).include?(prompt).should == true
+    end
+
+    it "converts non-array inputs to array" do
+      Helpers::AutoTable.expects(:render).with([1], anything)
+      basic_menu 1
+    end
+
+    it "with false ask option returns one choice without asking" do
+      $stdin.expects(:gets).never
+      menu([1], :ask=>false).should == [1]
+    end
+
+    it "with no items to choose from always return without asking" do
+      $stdin.expects(:gets).never
+      menu([], :ask=>false).should == []
+      menu([], :ask=>true).should == []
+    end
+
+    it "with directions option turns off directions" do
+      menu_input('blah')
+      capture_stdout { menu([1], :directions=>false) }.should.not =~ /range.*all/
+    end
+
+    it "with true reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/tty')
+      basic_menu [1], :reopen=>true
+    end
+
+    it "with string reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/blah')
+      basic_menu [1], :reopen=>'/dev/blah'
+    end
+  end
+
+  def two_d_menu(options={})
+    if options[:invokes] || options[:invoke]
+      cmd = options[:command] || 'p'
+      (options[:invokes] || [options[:invoke]]).each {|e|
+        Menu.any_instance.expects(:invoke).with(cmd, e)
+      }
+    end
+
+    capture_stdout {
+      return menu(options[:output] || [{:a=>1, :bro=>2}, {:a=>3, :bro=>4}],
+       {:two_d=>true}.merge(options))
+    }
+  end
+
+  describe "2d menu" do
+    it "with default field from last_table renders" do
+      menu_input "1"
+      two_d_menu.should == [1]
+    end
+
+    it "with default field from fields option renders" do
+      menu_input "1"
+      two_d_menu(:fields=>[:bro, :a]).should == [2]
+    end
+
+    it "with default field option renders" do
+      menu_input "1"
+      two_d_menu(:default_field=>:bro).should == [2]
+    end
+
+    it "with non-table helper class renders" do
+      menu_input "1"
+      two_d_menu(:helper_class=>false, :fields=>[:a,:bro]).should == [1]
+    end
+
+    it "with no default field prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:fields=>[]) }.should =~ /No default.*found/
+    end
+
+    it "with invalid field prints error" do
+      menu_input "1:z"
+      capture_stderr { two_d_menu }.should =~ /Invalid.*'z'/
+    end
+
+    it "with choice from abbreviated field" do
+      menu_input "2:b"
+      two_d_menu.should == [4]
+    end
+
+    it "with choices from multiple fields renders" do
+      menu_input "1 2:bro"
+      two_d_menu.should == [1,4]
+    end
+  end
+
+  describe "action menu" do
+    it "invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :invoke=>[[1,4]])
+    end
+
+    it "with 1d invokes" do
+      menu_input "p 1"
+      two_d_menu(:action=>true, :two_d=>nil, :invoke=>[[{:a=>1, :bro=>2}]])
+    end
+
+    it "with non-choice arguments invokes" do
+      menu_input "p arg1 1"
+      two_d_menu :action=>true, :invoke=>['arg1', [1]]
+    end
+
+    it "with multiple choice arguments flattens them into arg" do
+      menu_input "p arg1 1 2:bro arg2"
+      two_d_menu :action=>true, :invoke=>['arg1', [1,4], 'arg2']
+    end
+
+    it "with nothing chosen prints error" do
+      menu_input "cmd"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No rows chosen/
+    end
+
+    it "with no command given prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No command given/
+    end
+
+    it "with array menu items" do
+      menu_input "p 1"
+      two_d_menu :action=>true, :output=>[['some', 'choice'], ['and', 'another']],
+        :invokes=>[[['some']]]
+    end
+
+    it "with multi_action option invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :multi_action=>true, :invokes=>[[1], [4]])
+    end
+
+    it "with command option invokes" do
+      menu_input "1"
+      two_d_menu(:action=>true, :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with command option and empty input doesn't invoke action and exists silently" do
+      Menu.any_instance.expects(:invoke).never
+      menu_input ""
+      two_d_menu(:action=>true, :command=>'p').should == nil
+    end
+
+    it "with action_object option invokes" do
+      obj = mock(:blah=>true)
+      menu_input "blah 1"
+      two_d_menu(:action=>true, :action_object=>obj)
+    end
+
+    it "with ask false and defaults invokes" do
+      two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :default_field=>:a,
+        :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with ask false and no defaults prints error" do
+      capture_stderr {
+        two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :command=>'p')
+      }.should =~ /Default.*required/
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/object_table_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/object_table_test.rb
new file mode 100644
index 0000000..c0ef8f2
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/object_table_test.rb
@@ -0,0 +1,79 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "object table" do
+  def table(*args)
+    Helpers::ObjectTable.render(*args)
+  end
+
+  before_all {
+    @pets = [stub(:name=>'rufus', :age=>7, :to_s=>'rufus'), stub(:name=>'alf', :age=>101, :to_s=>'alf')]
+  }
+  it "renders" do
+    expected_table = <<-TABLE.unindent
+    +-------+-----+
+    | name  | age |
+    +-------+-----+
+    | rufus | 7   |
+    | alf   | 101 |
+    +-------+-----+
+    2 rows in set
+    TABLE
+    table(@pets, :fields=>[:name, :age]).should == expected_table
+  end
+  
+  it "with no options defaults to to_s field" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | rufus |
+    | alf   |
+    +-------+
+    2 rows in set
+    TABLE
+    table(@pets).should == expected_table
+  end
+
+  it "renders simple arrays" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    | 4     |
+    +-------+
+    4 rows in set
+    TABLE
+    table([1,2,3,4]).should == expected_table
+  end
+
+  it "renders simple arrays with custom header" do
+    expected_table = <<-TABLE.unindent
+    +-----+
+    | num |
+    +-----+
+    | 1   |
+    | 2   |
+    | 3   |
+    | 4   |
+    +-----+
+    4 rows in set
+    TABLE
+    table([1,2,3,4], :headers=>{:to_s=>'num'}).should == expected_table
+  end
+
+  it "with empty fields" do
+    expected_table = <<-TABLE.unindent
+    0 rows in set
+    TABLE
+    table(@pets, :fields => []).should == expected_table
+  end
+
+  it "doesn't raise error for objects that don't have :send defined" do
+    object = Object.new
+    class<<object; self; end.send :undef_method, :send
+    should.not.raise(NoMethodError) { table([object], :fields=>[:to_s]) }
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/pager_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/pager_test.rb
new file mode 100644
index 0000000..4878e12
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/pager_test.rb
@@ -0,0 +1,162 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Pager" do
+  def pager; View.pager; end
+
+  def create_pageable_string(inspect_mode=false, size={})
+    size = {:width=>pager.width, :height=>pager.height}.merge(size)
+    seed = inspect_mode ? "a" : "a\n"
+    if inspect_mode
+      seed * (size[:width] * size[:height] + 1)
+    else
+      seed * (size[:height] + 1)
+    end
+  end
+
+  it "command_pager sets pager_command when command exists" do
+    Util.expects(:command_exists?).returns(true)
+    Pager.expects(:basic_pager)
+    Pager.command_pager 'blah', :pager_command=>'less'
+  end
+
+  it "command_pager doesn't set pager_command when command doesn't exist" do
+    Util.expects(:command_exists?).returns(false)
+    Pager.expects(:basic_pager).never
+    Pager.command_pager 'blah', :pager_command=>'moreless'
+  end
+
+  describe "default_pager" do
+    before_all { reset_config; Hirb.enable :pager=>true }
+    before { View.pager = nil; Pager.stubs(:pager_command).returns(nil) }
+
+    it "pages once in normal mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string, false) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in normal mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a\n", false) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+
+    it "pages once in inspect mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string(true), true) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in inspect mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a", true) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+    after_all { Hirb.disable }
+  end
+
+  describe "pager" do
+    before_all { reset_config; Hirb.enable }
+    before { View.pager = nil; View.formatter = nil }
+
+    def irb_eval(string)
+      context_stub = stub(:last_value=>string)
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    # this mode is called within @irb.output_value
+    describe "in inspect_mode" do
+      it "activates when output is wide enough" do
+        output = create_pageable_string(true)
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "doesn't activate when output isn't wide enough" do
+        pager.expects(:page).never
+        View.expects(:render_output).returns(false)
+        irb_eval("a")
+      end
+
+      it "activates with an explicit width" do
+        View.config[:width] = 10
+        output = create_pageable_string true, :width=>10
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "activates default_pager when pager command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string(true)
+        Pager.expects(:default_pager).with(output.inspect, anything)
+        View.expects(:render_output).returns(false)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    # this mode is called within View.render_output
+    describe "in normal mode" do
+      it "activates when output is long enough" do
+        output = create_pageable_string
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "doesn't activate when output isn't long enough" do
+        output = "a\n"
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).never
+        capture_stdout { irb_eval(output) }
+      end
+
+      it "activates with an explicit height" do
+        View.config[:height] = 100
+        output = create_pageable_string false, :height=>100
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "activates default_pager when pager_command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string
+        Pager.expects(:default_pager).with(output, anything)
+        View.formatter.expects(:format_output).returns(output)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    it "activates pager_command with valid pager_command option" do
+      View.config[:pager_command] = "less"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "activates pager_command with pager_command option that has command options" do
+      View.config[:pager_command] = "less -r"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).with('less').returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "doesn't activate pager_command with invalid pager_command option" do
+      View.config[:pager_command] = "moreless"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(false)
+      Pager.expects(:default_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+  end
+  after_all { Hirb.disable }
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/resizer_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/resizer_test.rb
new file mode 100644
index 0000000..55160a7
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/resizer_test.rb
@@ -0,0 +1,62 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Resizer" do
+  def table(options)
+    @table = Helpers::Table.new [options[:field_lengths].keys.inject({}) {|t,e| t[e] = '1'; t}]
+    @table.field_lengths = options[:field_lengths]
+    @table.width = options[:width]
+    @table.max_fields = options[:max_fields] if options[:max_fields]
+    @width, @field_lengths = @table.width, @table.field_lengths
+    @table
+  end
+
+  it "resize ensures columns total doesn't exceed max width" do
+    table :field_lengths=>{:f1=>135, :f2=>45, :f3=>4, :f4=>55}, :width=>195
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+  end
+
+  it "resize sets columns by relative lengths" do
+    table :field_lengths=>{:a=>30, :b=>30, :c=>40}, :width=>60
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.uniq.size.should.not == 1
+  end
+
+  it "resize sets all columns roughly equal when adusting long fields don't work" do
+    table :field_lengths=>{:field1=>10, :field2=>15, :field3=>100}, :width=>20
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.each {|e| e.should <= 4 }
+  end
+
+  describe "add_extra_width and max_fields" do
+    def table_and_resize(options={})
+      defaults = {:field_lengths=>{:f1=>135, :f2=>30, :f3=>4, :f4=>100}, :width=>195, :max_fields=>{:f1=>80, :f4=>30} }
+      @table = table defaults.merge(options)
+      # repeated from table since instance variables aren't copied b/n contexts
+      @width, @field_lengths = @table.width, @table.field_lengths
+      Helpers::Table::Resizer.resize! @table
+    end
+
+    it "doesn't add to already maxed out field" do
+      table_and_resize
+      @field_lengths[:f3].should == 4
+    end
+
+    it "restricted before adding width" do
+      table_and_resize
+      @field_lengths[:f4].should <= 30
+    end
+
+    it "adds to restricted field" do
+      table_and_resize
+      @field_lengths[:f1].should <= 80
+    end
+
+    it "adds to unrestricted field" do
+      table_and_resize :field_lengths=>{:f1=>135, :f2=>70, :f3=>4, :f4=>100}
+      @field_lengths[:f2].should == 70
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/table_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/table_test.rb
new file mode 100644
index 0000000..1247a42
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/table_test.rb
@@ -0,0 +1,550 @@
+# encoding: UTF-8
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Table" do
+  def table(*args)
+    Helpers::Table.render(*args)
+  end
+  before_all { reset_config }
+  
+  describe "basic table" do
+    it "renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}]).should == expected_table
+    end
+    
+    it "with no headers renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 | 2 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>2}], :headers=>false).should == expected_table
+    end
+
+    it "with no headers and nil fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 |   |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>nil}], :headers=>false).should == expected_table
+    end
+
+    it "with string keys renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}]).should == expected_table
+    end
+
+    it "with array only rows renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]]).should == expected_table
+    end
+
+    it "with too many fields defaults to vertical table" do
+      rows = [Array.new(25, "A"* 10)]
+      Helpers::VerticalTable.expects(:render).with(rows, anything)
+      capture_stderr { table(rows)}.should =~ /Error/
+    end
+
+    it "with no rows renders" do
+      table([]).should == "0 rows in set"
+    end
+
+    it "with invalid rows raises an argumenterror" do
+      lambda { table(:a=>1) }.should.raise(ArgumentError).message.should =~ /Table must/
+    end
+
+    it "renders utf8" do
+      expected_table = <<-TABLE.unindent
+      +--------------------+
+      | name               |
+      +--------------------+
+      | ｱｲｳｴｵｶｷ            |
+      | ｸｹｺｻｼｽｾｿﾀﾁﾂﾃ       |
+      | Tata l'asticote    |
+      | toto létoile PAOLI |
+      +--------------------+
+      4 rows in set
+      TABLE
+      table([{:name=>"ｱｲｳｴｵｶｷ"}, {:name=>"ｸｹｺｻｼｽｾｿﾀﾁﾂﾃ"}, {:name=>"Tata l'asticote"}, {:name=>"toto létoile PAOLI"}]).should == expected_table
+    end
+
+    it "stringifies newlines and tabs and renders" do
+      expected_table = <<-TABLE.unindent
+      +-----+---+
+      | a   | b |
+      +-----+---+
+      | 1#{'\n'} | 2 |
+      | 3#{'\t'} | 4 |
+      +-----+---+
+      2 rows in set
+      TABLE
+      value = [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+      table(value).should == expected_table
+      value.should == [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+    end
+
+    it "with a field of only array values renders values comma joined" do
+      expected_table = <<-TABLE.unindent
+      +----+------+
+      | a  | b    |
+      +----+------+
+      | 1  | 1, 2 |
+      | ok | 3, 4 |
+      +----+------+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>[1,2]}, {:a=>'ok', :b=>[3,4]}]).should == expected_table
+    end
+
+    it "with filter class default doesn't override explicit filters" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | a    | 1     |
+      +------+-------+
+      1 row in set
+      TABLE
+      table([{:name=>'a', :value=>{:b=>1}}], :filters=>{:value=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with" do
+    it "fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | a |
+      +---+---+
+      | 2 | 1 |
+      | 4 | 3 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :a]).should == expected_table
+    end
+    
+    it "fields option and array only rows" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 2 |
+      +---+---+
+      | 1 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([[1,2,3]], :fields=>[0,2]).should == expected_table
+    end
+
+    it "fields and number options copies fields option and does not modify it" do
+      options = {:fields=>[:f1], :number=>true}
+      table([{:f1=>1, :f2=>2}], options)
+      options[:fields].should == [:f1]
+    end
+  
+    it "invalid fields option renders empty columns" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | c |
+      +---+---+
+      | 2 |   |
+      | 4 |   |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :c]).should == expected_table
+    end
+  
+    it "invalid field in max_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10,:c=>10}).should == expected_table
+    end
+  
+    it "max_fields option with fields less than 3 characters renders" do
+      expected_table = <<-TABLE.unindent
+      +----+---+
+      | a  | b |
+      +----+---+
+      | AA | 2 |
+      +----+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>2}, :resize=>false).should == expected_table
+    end
+  
+    it "max_fields option without resize renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10}, :resize=>false).should == expected_table
+    end
+
+    it "max_fields option with percentage renders" do
+      expected_table = <<-TABLE.unindent
+      +------------------+---+
+      | a                | b |
+      +------------------+---+
+      | AAAAAAAAAAAAA... | 2 |
+      +------------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>'0.15'}).should == expected_table
+    end
+  
+    it "max_width option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :max_width=>30).should == expected_table
+    end
+
+    it "resize option false renders full table" do
+      expected_table = <<-TABLE.unindent
+      +----------------------------------------------------+---+------------+
+      | a                                                  | b | c          |
+      +----------------------------------------------------+---+------------+
+      | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | 2 | CCCCCCCCCC |
+      +----------------------------------------------------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :resize=>false).should == expected_table
+    end
+    
+    it "global width renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      View.load_config
+      View.resize(30)
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}]).should == expected_table
+      reset_config
+    end
+
+    it "headers option and headers longer than fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---------+---------+
+      | a | field B | field C |
+      +---+---------+---------+
+      | A | 2       | C       |
+      +---+---------+---------+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2, :c=>"C"}], :headers=>{:b=>"field B", :c=>"field C"}).should == expected_table
+    end
+  
+    it "headers option and headers shortened by max_fields renders" do
+      expected_table = <<-TABLE.unindent
+      +-------+---+
+      | fi... | b |
+      +-------+---+
+      | A     | 2 |
+      +-------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2}], :headers=>{:a=>"field A"}, :max_fields=>{:a=>5}, :resize=>false).should == expected_table
+    end
+    
+    it "headers option as an array renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]], :headers=>['A', 'B']).should == expected_table
+    end
+
+    it "header_filter option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 2 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=> 2, :b=>3}], :header_filter=>:capitalize).should == expected_table
+    end
+
+    it "filters option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+
+      | 0         | 1 |
+      +-----------+---+
+      | s,o,m,e   | 2 |
+      | t,h,i,n,g | 1 |
+      +-----------+---+
+      2 rows in set
+      TABLE
+      table([['some', {:num=>2}], ['thing', {:num=>1}]], :filters=>{0=>lambda {|e| e.split("").join(",")},
+        1=>[:[], :num]}).should == expected_table
+    end
+
+    it "filters option calls Filters method and renders" do
+      module ::Hirb::Helpers::Table::Filters
+        def semicolon_join(arr); arr.join('; '); end
+      end
+
+      expected_table = <<-TABLE.unindent
+      +------+------------------------------+
+      | 0    | 1                            |
+      +------+------------------------------+
+      | some | unsightly; unreadable; array |
+      +------+------------------------------+
+      1 row in set
+      TABLE
+      table([[['some'], %w{unsightly unreadable array}]], :filters=>{1=>:semicolon_join}).should == expected_table
+    end
+
+    it "number option renders" do
+      expected_table = <<-TABLE.unindent
+      +--------+---+---+
+      | number | 0 | 1 |
+      +--------+---+---+
+      | 1      | a | b |
+      | 2      | c | d |
+      +--------+---+---+
+      2 rows in set
+      TABLE
+      table([['a','b'], ['c', 'd']], :number=>true).should == expected_table
+    end
+
+    it "description option false renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | a | b |
+      | c | d |
+      +---+---+
+      TABLE
+      table([['a','b'], ['c', 'd']], :description=>false).should == expected_table
+    end
+
+    it "vertical option renders vertical table" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table with newlines" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      and one
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>"4\nand one"}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table successively" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      options = {:vertical=>true}
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+    end
+
+    it "hide_empty and vertical options renders" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      b: 2
+      *** 2. row ***
+      a: 3
+      2 rows in set
+      TABLE
+      table([{:a=>'', :b=>2}, {:a=>3, :b=>nil}], :hide_empty=>true, :vertical=>true).should == expected_table
+    end
+
+    it "all_fields option renders all fields" do
+      expected_table = <<-TABLE.unindent
+      +---+---+---+
+      | a | b | c |
+      +---+---+---+
+      | 1 | 2 |   |
+      | 3 |   | 4 |
+      +---+---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :c=>4}], :all_fields=>true).should == expected_table
+    end
+
+    it "change_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>{0=>'name', 1=>'value'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value']).should == expected_table
+    end
+
+    it "change_fields and fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+
+      | name |
+      +------+
+      | 1    |
+      | 2    |
+      +------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>['name', 'value'], :fields=>['name']).should == expected_table
+    end
+
+    it "invalid fields in change_fields options are ignored" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([{:a=>1,:b=>2}, {:a=>2,:b=>3}], :change_fields=>{:a=>'name', :b=>'value', :c=>'time'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value','time']).should == expected_table
+    end
+
+    it "filter_any option filters any value" do
+      expected_table = <<-TABLE.unindent
+      +---------+
+      | a       |
+      +---------+
+      | {:b=>1} |
+      | 2       |
+      +---------+
+      2 rows in set
+      TABLE
+      table([{:a=>{:b=>1}}, {:a=>2}], :filter_any=>true).should == expected_table
+    end
+
+    it "filter_classes option overrides class-wide filter_classes" do
+      expected_table = <<-TABLE.unindent
+      +---+
+      | a |
+      +---+
+      | 1 |
+      +---+
+      1 row in set
+      TABLE
+      table([{:a=>{:b=>1}}], :filter_classes=>{Hash=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with callbacks" do
+    before_all {
+      Helpers::Table.send(:define_method, :and_one_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] += opt[:add] } }
+        obj
+      end
+    }
+    it "detects and runs them" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1).should == expected_table
+    end
+
+    it "doesn't run callbacks in delete_callbacks option" do
+      Helpers::Table.send(:define_method, :and_two_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] = row[k] * 2 } }
+        obj
+      end
+
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1, :delete_callbacks=>[:and_two]).should == expected_table
+
+      Helpers::Table.send(:remove_method, :and_two_callback)
+    end
+    after_all { Helpers::Table.send(:remove_method, :and_one_callback) }
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/test_helper.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/test_helper.rb
new file mode 100644
index 0000000..4706d0a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/test_helper.rb
@@ -0,0 +1,61 @@
+require 'bacon'
+require 'bacon/bits'
+require 'mocha'
+require 'mocha-on-bacon'
+require 'hirb'
+include Hirb
+
+module TestHelpers
+  # set these to avoid invoking stty multiple times which doubles test suite running time
+  ENV["LINES"] = ENV["COLUMNS"] = "20"
+  def reset_terminal_size
+    ENV["LINES"] = ENV["COLUMNS"] = "20"
+  end
+
+  def capture_stdout(&block)
+    original_stdout = $stdout
+    $stdout = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stdout = original_stdout
+    end
+    fake.string
+  end
+
+  def capture_stderr(&block)
+    original_stderr = $stderr
+    $stderr = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stderr = original_stderr
+    end
+    fake.string
+  end
+
+  def reset_config
+    View.instance_eval "@config = nil"
+  end
+end
+
+class Bacon::Context
+  include TestHelpers
+end
+
+class String
+  def unindent(num=nil)
+    regex = num ? /^\s{#{num}}/ : /^\s*/
+    gsub(regex, '').chomp
+  end
+end
+
+# mocks IRB for View + Pager
+module ::IRB
+  class Irb
+    def initialize(context)
+      @context = context
+    end
+    def output_value; end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/tree_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/tree_test.rb
new file mode 100644
index 0000000..cd046ef
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/tree_test.rb
@@ -0,0 +1,184 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Tree helpers:" do
+  def tree(*args)
+    Helpers::Tree.render(*args)
+  end
+  
+  describe "basic tree" do
+    it "with hash nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([{:level=>0, :value=>'0.0'}, {:level=>1, :value=>'1.1'}, {:level=>2, :value=>'2.2'},{:level=>2, :value=>'3.2'},
+         {:level=>1, :value=>'4.1'}]).should == expected_tree
+    end
+  
+    it "with array nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]]).should == expected_tree
+    end
+    
+    it "with non-string values renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0,0.0],[1,1.1],[2,2.2],[2,3.2],[1,4.1]]).should == expected_tree
+    end
+
+    it "with indent option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+        1.1
+          2.2
+          3.2
+        4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :indent=>2).should == expected_tree
+    end
+
+    it "with limit option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :limit=>1).should == expected_tree
+    end
+
+    it "with description option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      
+      5 nodes in tree
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :description=>true).should == expected_tree
+    end
+
+    it "with type directory renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :type=>:directory).should == expected_tree
+    end
+
+    it "with type directory and multiple children per level renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   |   `-- 3.3
+      |   `-- 4.2
+      |       `-- 5.3
+      `-- 6.1
+      TREE
+      tree([[0,'0.0'], [1,'1.1'], [2,'2.2'],[3,'3.3'],[2,'4.2'],[3,'5.3'],[1,'6.1']], :type=>:directory).should == expected_tree
+    end
+
+    it "with type number renders" do
+      expected_tree = <<-TREE.unindent(6)
+      1. 0
+          1. 1
+              1. 2
+              2. 3
+          2. 4
+      TREE
+      tree([[0,'0'],[1,'1'],[2,'2'],[2,'3'],[1,'4']], :type=>:number).should == expected_tree
+    end
+
+    it "with multi-line nodes option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      parent
+          +-------+
+          | value |
+          +-------+
+          | 1     |
+          | 2     |
+          | 3     |
+          +-------+
+              indented
+              stuff
+      TREE
+      node1 = "+-------+\n| value |\n+-------+\n| 1     |\n| 2     |\n| 3     |\n+-------+"
+      tree([ [0, 'parent'],[1, node1],[2, "indented\nstuff"]], :multi_line_nodes=>true).should == expected_tree
+    end
+  end
+
+  def mock_node(value, value_method)
+    children = []
+    value,children = *value if value.is_a?(Array)
+    mock(value_method=>value, :children=>children.map {|e| mock_node(e, value_method)})
+  end
+
+  describe "parent_child_tree" do
+    it "with name value renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :name)
+      Helpers::ParentChildTree.render(root, :type=>:directory).should == expected_tree
+    end
+    
+    it "with value_method option renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :blah)
+      Helpers::ParentChildTree.render(root, :type=>:directory, :value_method=>:blah).should == expected_tree
+    end
+
+    it "with children_method proc option renders" do
+      expected_tree = <<-TREE.unindent
+      1
+      |-- 2
+      |-- 3
+      |-- 4
+      `-- 5
+      TREE
+      Helpers::ParentChildTree.render(1, :type=>:directory,
+        :children_method=>lambda {|e| e == 1 ? (2..5).to_a : []}, :value_method=>:to_s).should == expected_tree
+    end
+  end
+
+  it "tree with parentless nodes renders ParentlessNodeError" do
+    lambda { tree([[0, "0.0"], [2, '1.2']], :validate=>true) }.should.raise(Helpers::Tree::ParentlessNodeError)
+  end
+  
+  it "tree with hash nodes missing level raises MissingLevelError" do
+    lambda { tree([{:value=>'ok'}]) }.should.raise(Helpers::Tree::Node::MissingLevelError)
+  end
+
+  it "tree with hash nodes missing level raises MissingValueError" do
+    lambda { tree([{:level=>0}]) }.should.raise(Helpers::Tree::Node::MissingValueError)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/util_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/util_test.rb
new file mode 100644
index 0000000..faadd5d
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/util_test.rb
@@ -0,0 +1,59 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Util" do
+  it "camelize converts underscore lowercase to camelcase" do
+    Util.camelize('hirb/util').should == "Hirb::Util"
+    Util.camelize('hirb_hash').should == "HirbHash"
+  end
+
+  it "any_const_get returns nested class" do
+    Util.any_const_get("YAML::BaseNode").should == ::YAML::BaseNode
+  end
+
+  it "any_const_get returns nil for invalid class" do
+    Util.any_const_get("Basdfr").should == nil
+  end
+
+  it "any_const_get returns class when given class" do
+    Util.any_const_get(String).should == String
+  end
+
+  it "recursive_hash_merge merges" do
+    expected_hash = {:output=>{:fields=>["f1", "f2"], :method=>"blah"}, :key1=>"hash1", :key2=>"hash2"}
+    Util.recursive_hash_merge({:output=>{:fields=>%w{f1 f2}}, :key1=>'hash1'},
+      {:output=>{:method=>'blah'}, :key2=>'hash2'}).should == expected_hash
+  end
+
+  it "choose_from_array specifies range with -" do
+    Util.choose_from_array([1,2,3,4], '1-2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array specifies range with .." do
+    Util.choose_from_array([1,2,3,4], '1 .. 2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array chooses all with *" do
+    Util.choose_from_array([1,2,3,4], '*').should == [1,2,3,4]
+  end
+
+  it "choose_from_array ignores non-numerical input" do
+    Util.choose_from_array([1,2,3,4], 'a,2').should == [2]
+  end
+
+  it "choose_from_array ignores 0" do
+    Util.choose_from_array([1,2,3,4], '0,2').should == [2]
+  end
+
+  it "choose_from_array returns empty when empty input" do
+    Util.choose_from_array([1,2,3,4], "\n").should == []
+  end
+
+  it "choose_from_array returns empty with an invalid range" do
+    Util.choose_from_array([1,2,3,4], "5").should == []
+  end
+
+  it "capture_stdout" do
+    string = "sweetness man"
+    Util.capture_stdout { puts string }.should == string + "\n"
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/view_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/view_test.rb
new file mode 100644
index 0000000..ab18087
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/view_test.rb
@@ -0,0 +1,172 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "View" do
+  def formatter_config
+    View.formatter.config
+  end
+  
+  it "page_output pages when view is enabled" do
+    Hirb.enable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page)
+    View.page_output('blah').should == true
+    Hirb.disable
+  end
+
+  it "page_output doesn't page when view is disabled" do
+    Hirb.enable
+    Hirb.disable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page).never
+    View.page_output('blah').should == false
+  end
+
+  it "view_output catches unexpected errors and prints them" do
+    reset_config
+    Hirb.enable
+    View.expects(:render_output).raises('blah')
+    capture_stderr { View.view_output([1,2,3]) }.should =~ /Hirb Error: blah/
+    Hirb.disable
+  end
+
+  describe "enable" do
+    before { reset_config }
+    after { Hirb.disable }
+    it "redefines irb output_value" do
+      View.expects(:render_output).once
+      Hirb.enable
+      context_stub = stub(:last_value=>'')
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    it "is enabled?" do
+      Hirb.enable
+      View.enabled?.should == true
+    end
+
+    def output_class_config(klass)
+      { :output=>{klass=>{:class=>:auto_table}} }
+    end
+
+    it "sets formatter config" do
+      class_hash = {"Something::Base"=>{:class=>"BlahBlah"}}
+      Hirb.enable :output=>class_hash
+      View.formatter_config['Something::Base'].should == class_hash['Something::Base']
+    end
+
+    it "when called multiple times merges configs" do
+      Hirb.config = nil
+      # default config + config_file
+      Hirb.expects(:read_config_file).returns(output_class_config('Regexp'))
+      Hirb.enable output_class_config('String')
+
+      # add config file and explicit config
+      [{:config_file=>'ok'}, output_class_config('Struct')].each do |config|
+        Hirb.expects(:read_config_file).times(2).returns(
+          output_class_config('ActiveRecord::Base'), output_class_config('Array'))
+        Hirb.enable config
+      end
+
+      Hirb.config_files.include?('ok').should == true
+      output_keys = %w{ActiveRecord::Base Array Regexp String Struct}
+      View.config[:output].keys.sort.should == output_keys
+    end
+
+    it "when called multiple times without config doesn't affect config" do
+      Hirb.enable
+      old_config = View.config
+      Hirb.expects(:read_config_file).never
+      View.expects(:load_config).never
+      Hirb.enable
+      View.config.should == old_config
+    end
+
+    it "works without irb" do
+      Object.stubs(:const_defined?).with(:IRB).returns(false)
+      Hirb.enable
+      formatter_config.size.should.be > 0
+    end
+
+    it "with config_file option adds to config_file" do
+      Hirb.enable :config_file=> 'test_file'
+      Hirb.config_files.include?('test_file').should == true
+    end
+
+    it "with output_method option realiases output_method" do
+      eval %[module ::Mini; extend self; def output(str); puts(str.inspect); end; end]
+      Hirb.enable :output_method=>"Mini.output", :output=>{"Symbol"=>{:output_method=>lambda {|e| e.to_s }}}
+      capture_stdout { ::Mini.output(:yoyo) }.should == "yoyo\n"
+      capture_stdout { ::Mini.output('blah') }.should == "\"blah\"\n"
+    end
+
+    it "with ignore_errors enable option" do
+      Hirb.enable :ignore_errors => true
+      View.stubs(:render_output).raises(Exception, "Ex mesg")
+      capture_stderr { View.view_output("").should == false }.should =~ /Error: Ex mesg/
+    end
+  end
+
+  describe "resize" do
+    def pager; View.pager; end
+    before { View.pager = nil; reset_config; Hirb.enable }
+    after { Hirb.disable}
+    it "changes width and height with stty" do
+      Util.expects(:command_exists?).with('stty').returns(true)
+      ENV['COLUMNS'] = ENV['LINES'] = nil # bypasses env usage
+      View.resize
+      pager.width.should.not == 10
+      pager.height.should.not == 10
+      reset_terminal_size
+    end
+
+    it "changes width and height with ENV" do
+      ENV['COLUMNS'] = ENV['LINES'] = '10' # simulates resizing
+      View.resize
+      pager.width.should == 10
+      pager.height.should == 10
+    end
+
+    it "with no environment or stty still has valid width and height" do
+      View.config[:width] = View.config[:height] = nil
+      Util.expects(:command_exists?).with('stty').returns(false)
+      ENV['COLUMNS'] = ENV['LINES'] = nil
+      View.resize
+      pager.width.is_a?(Integer).should == true
+      pager.height.is_a?(Integer).should == true
+      reset_terminal_size
+    end
+  end
+
+  it "disable points output_value back to original output_value" do
+    View.expects(:render_output).never
+    Hirb.enable
+    Hirb.disable
+    context_stub = stub(:last_value=>'')
+    ::IRB::Irb.new(context_stub).output_value
+  end
+
+  it "disable works without irb defined" do
+    Object.stubs(:const_defined?).with(:IRB).returns(false)
+    Hirb.enable
+    Hirb.disable
+    View.enabled?.should == false
+  end
+
+  it "capture_and_render" do
+    string = 'no waaaay'
+    View.render_method.expects(:call).with(string)
+    View.capture_and_render { print string }
+  end
+  
+  it "state is toggled by toggle_pager" do
+    previous_state = View.config[:pager]
+    View.toggle_pager
+    View.config[:pager].should == !previous_state
+  end
+  
+  it "state is toggled by toggle_formatter" do
+    previous_state = View.config[:formatter]
+    View.toggle_formatter
+    View.config[:formatter].should == !previous_state
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.4/test/views_test.rb b/lib/bbcloud/vendor/hirb-0.3.4/test/views_test.rb
new file mode 100644
index 0000000..1aeb641
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.4/test/views_test.rb
@@ -0,0 +1,13 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "activerecord table" do
+  it "with no select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{"name"=>'rufus', 'age'=>7}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:age, :name]}
+  end
+
+  it "with select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{'name'=>'rufus'}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:name]}
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/ini-0.1.1/.require_paths b/lib/bbcloud/vendor/ini-0.1.1/.require_paths
new file mode 100644
index 0000000..e875275
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/.require_paths
@@ -0,0 +1,3 @@
+lib
+test
+bin
diff --git a/lib/bbcloud/vendor/ini-0.1.1/README b/lib/bbcloud/vendor/ini-0.1.1/README
new file mode 100644
index 0000000..1e69cfe
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/README
@@ -0,0 +1,113 @@
+
+= Conventional INI File Parsing and Writing
+
+== Introduction
+
+Ah yes, INI files. We love them. We hate them. We cannot escape
+them. Originally made popular by Windows, INI files are everywhere
+including in Samba[www.samba.org] and Trac[trac.edgewall.org]. This
+gem has one goal: make INI file, structure, and stream manipulation
+as fast, safe, and simple as possible. We take a modal approach
+with a pluggable parser class.
+
+== Sample File
+
+  ; some comment about section1
+  [section1]
+  var1 = foo
+  var2 = doodle
+
+  [section2]
+
+  ; some comment about var1
+  var1 = baz
+
+  ; some comment about var2    
+  var2 = shoodle
+
+== Conventional Format
+
+There is no formal INI specification but most parsers observe the
+following so we do also by default:
+
+=== Sections
+
+Section declarations are wrapped in square brackets
+(<tt>[section1]</tt>) with no spaces surrounding the section
+name. Duplicate sections are discouraged but if included are merged.
+
+=== Parameters
+
+The <tt>var1 = foo</tt> above is an example of a parameter, also
+frequently referred to a property, item, or pair.  Each parameter is
+made up of a key name (<tt>var1</tt>), an equals sign (<tt>=</tt>),
+and a value (<tt>foo</tt>) with optional spaces. Leading spaces
+before the key name are allowed and leading spaces before or after
+the value are trimmed. Values are literally the characters that
+remain, even if quoted (<tt>var1 = "foo"</tt> would include the
+quotes in the value). Duplicate parameters, either in the same
+section or merged duplicate sections, play 'last one wins'.
+
+=== Comments
+
+All lines starting with a semicolon (<tt>;</tt>) are assumed to be
+comments and are ignored. This character must be the first on the line.
+
+=== Blank Lines
+
+All lines that contain nothing but spaces are ignored.
+
+=== Line Endings
+
+Lines end at either a CRLF or just a LF (CR=\015, LF=\012). Files
+may mix the two within the same file to accomodate edits from
+different platforms.
+
+=== Format Variations Supported
+
+Because INI format is not formally specified, many variations exist
+in the wild. Some of these are supported by extra parsers that are
+included and set by changing the <tt>mode</tt> of the <ini> instance.
+
+To maintain backward compatibility with the original 'inifile' gem,
+the following variations are supported by the default parser: 
+
+* <b>Comments:</b> the comment character can be specified when an instance is created
+* <b>Parameters:</b> separator character can be specified when an instance is created
+* <b>Duplicate Sections:</b> merged
+* <b>Duplicate Parameters:</b> the last one wins
+
+=== Currently Unsupported Format Variations
+
+If it isn't listed above, chances are it isn't supported. But here
+are some specific variations in case you are wondering (and, yes,
+we do have plans eventually support them, either as defaults or options):
+
+* Parameter value continuation with backslash (<tt>\\</tt>)
+* Parameter value double-quoting with escapes (<tt>foo = "value with \\n in it"</tt>)
+* Parameter values using braces (<tt>{}</tt>)
+* Parameter values using simple commas parsing into arrays
+
+== Copyright and License
+
+Copyright (c) 2006-2007 The 'ini' and 'inifile' Gem Team
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/lib/ini.rb b/lib/bbcloud/vendor/ini-0.1.1/lib/ini.rb
new file mode 100644
index 0000000..00a1859
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/lib/ini.rb
@@ -0,0 +1,264 @@
+# $Id: ini.rb 1 2007-01-17 15:21:30Z ironmo $
+
+#
+# This class represents the INI file and can be used to parse, modify,
+# and write INI files.
+#
+class Ini
+
+  # :stopdoc:
+  class Error < StandardError; end
+  # :startdoc:
+
+  #
+  # call-seq:
+  #    IniFile.load( filename )
+  #    IniFile.load( filename, options )
+  #
+  # Open the given _filename_ and load the contetns of the INI file.
+  # The following _options_ can be passed to this method:
+  #
+  #    :comment => ';'      The line comment character(s)
+  #    :parameter => '='    The parameter / value separator
+  #
+  def self.load( filename, opts = {} )
+    new(filename, opts)
+  end
+
+  #
+  # call-seq:
+  #    IniFile.new( filename )
+  #    IniFile.new( filename, options )
+  #
+  # Create a new INI file using the given _filename_. If _filename_
+  # exists and is a regular file, then its contents will be parsed.
+  # The following _options_ can be passed to this method:
+  #
+  #    :comment => ';'      The line comment character(s)
+  #    :parameter => '='    The parameter / value separator
+  #
+  def initialize( filename, opts = {} )
+    @fn = filename
+    @comment = opts[:comment] || ';'
+    @param = opts[:parameter] || '='
+    @ini = Hash.new {|h,k| h[k] = Hash.new}
+
+    @rgxp_comment = %r/\A\s*\z|\A\s*[#{@comment}]/
+    @rgxp_section = %r/\A\s*\[([^\]]+)\]/o
+    @rgxp_param   = %r/\A([^#{@param}]+)#{@param}(.*)\z/
+
+    parse
+  end
+
+  #
+  # call-seq:
+  #    write
+  #    write( filename )
+  #
+  # Write the INI file contents to the filesystem. The given _filename_
+  # will be used to write the file. If _filename_ is not given, then the
+  # named used when constructing this object will be used.
+  #
+  def write( filename = nil )
+    @fn = filename unless filename.nil?
+
+    ::File.open(@fn, 'w') do |f|
+      @ini.each do |section,hash|
+        f.puts "[#{section}]"
+        hash.each {|param,val| f.puts "#{param} #{@param} #{val}"}
+        f.puts
+      end
+    end
+    self
+  end
+  alias :save :write
+
+  #
+  # call-seq:
+  #    each {|section, parameter, value| block}
+  #
+  # Yield each _section_, _parameter_, _value_ in turn to the given
+  # _block_. The method returns immediately if no block is supplied.
+  #
+  def each
+    return unless block_given?
+    @ini.each do |section,hash|
+      hash.each do |param,val|
+        yield section, param, val
+      end
+    end
+    self
+  end
+
+  #
+  # call-seq:
+  #    each_section {|section| block}
+  #
+  # Yield each _section_ in turn to the given _block_. The method returns
+  # immediately if no block is supplied.
+  #
+  def each_section
+    return unless block_given?
+    @ini.each_key {|section| yield section}
+    self
+  end
+
+  #
+  # call-seq:
+  #    delete_section( section )
+  #
+  # Deletes the named _section_ from the INI file. Returns the
+  # parameter / value pairs if the section exists in the INI file. Otherwise,
+  # returns +nil+.
+  #
+  def delete_section( section )
+    @ini.delete section.to_s
+  end
+
+  #
+  # call-seq:
+  #    ini_file[section]
+  #
+  # Get the hash of parameter/value pairs for the given _section_. If the
+  # _section_ hash does not exist it will be created.
+  #
+  def []( section )
+    return nil if section.nil?
+    @ini[section.to_s]
+  end
+
+  #
+  # call-seq:
+  #    has_section?( section )
+  #
+  # Returns +true+ if the named _section_ exists in the INI file.
+  #
+  def has_section?( section )
+    @ini.has_key? section.to_s
+  end
+
+  #
+  # call-seq:
+  #    sections
+  #
+  # Returns an array of the section names.
+  #
+  def sections
+    @ini.keys
+  end
+
+  #
+  # call-seq:
+  #    freeze
+  #
+  # Freeze the state of the +IniFile+ object. Any attempts to change the
+  # object will raise an error.
+  #
+  def freeze
+    super
+    @ini.each_value {|h| h.freeze}
+    @ini.freeze
+    self
+  end
+
+  #
+  # call-seq:
+  #    taint
+  #
+  # Marks the INI file as tainted -- this will traverse each section marking
+  # each section as tainted as well.
+  #
+  def taint
+    super
+    @ini.each_value {|h| h.taint}
+    @ini.taint
+    self
+  end
+
+  #
+  # call-seq:
+  #    dup
+  #
+  # Produces a duplicate of this INI file. The duplicate is independent of the
+  # original -- i.e. the duplicate can be modified without changing the
+  # orgiinal. The tainted state of the original is copied to the duplicate.
+  #
+  def dup
+    other = super
+    other.instance_variable_set(:@ini, Hash.new {|h,k| h[k] = Hash.new})
+    @ini.each_pair {|s,h| other[s].merge! h}
+    other.taint if self.tainted?
+    other
+  end
+
+  #
+  # call-seq:
+  #    clone
+  #
+  # Produces a duplicate of this INI file. The duplicate is independent of the
+  # original -- i.e. the duplicate can be modified without changing the
+  # orgiinal. The tainted state and the frozen state of the original is copied
+  # to the duplicate.
+  #
+  def clone
+    other = dup
+    other.freeze if self.frozen?
+    other
+  end
+
+  #
+  # call-seq:
+  #    eql?( other )
+  #
+  # Returns +true+ if the _other_ object is equivalent to this INI file. For
+  # two INI files to be equivalent, they must have the same sections with  the
+  # same parameter / value pairs in each section.
+  #
+  def eql?( other )
+    return true if equal? other
+    return false unless other.instance_of? self.class
+    @ini == other.instance_variable_get(:@ini)
+  end
+  alias :== :eql?
+
+
+  private
+  #
+  # call-seq
+  #    parse
+  #
+  # Parse the ini file contents.
+  #
+  def parse
+    return unless ::Kernel.test ?f, @fn
+    section = nil
+
+    ::File.open(@fn, 'r') do |f|
+      while line = f.gets
+        line = line.chomp
+
+        case line
+        # ignore blank lines and comment lines
+        when @rgxp_comment: next
+
+        # this is a section declaration
+        when @rgxp_section: section = @ini[$1.strip]
+
+        # otherwise we have a parameter
+        when @rgxp_param
+          begin
+            section[$1.strip] = $2.strip
+          rescue NoMethodError
+            raise Error, "parameter encountered before first section"
+          end
+
+        else
+          raise Error, "could not parse line '#{line}"
+        end
+      end  # while
+    end  # File.open
+  end
+
+end
+
+# EOF
diff --git a/lib/bbcloud/vendor/ini-0.1.1/lib/inifile.rb b/lib/bbcloud/vendor/ini-0.1.1/lib/inifile.rb
new file mode 100644
index 0000000..d82f808
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/lib/inifile.rb
@@ -0,0 +1,10 @@
+# $Id: inifile.rb 1 2007-01-17 15:21:30Z ironmo $
+
+# The 'inifile' gem will eventually be deprecated in favor of the
+# 'ini' gem as it becomes able to handle streams, stringio and string buffers of INI
+# formatted data.
+
+require 'ini'
+
+class IniFile < Ini
+end
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_1.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_1.ini
new file mode 100644
index 0000000..15d3325
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_1.ini
@@ -0,0 +1,6 @@
+; having a paramater / value pair outside a section is an error
+one = 1
+
+[section_one]
+one = 1
+two = 2
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_2.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_2.ini
new file mode 100644
index 0000000..0e3bac8
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_2.ini
@@ -0,0 +1,6 @@
+[section_one]
+one = 1
+two = 2
+
+; the following is not a valid line
+invalid line
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/comment.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/comment.ini
new file mode 100644
index 0000000..52b9855
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/comment.ini
@@ -0,0 +1,5 @@
+# comments should be ignored
+[section_one]
+one = 1
+two = 2
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/good.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/good.ini
new file mode 100644
index 0000000..ca9ac05
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/good.ini
@@ -0,0 +1,17 @@
+[section_one]
+one = 1
+two = 2
+
+[section_two]
+three =         3    
+
+; comments should be ignored
+[section three]
+four   =4
+five=5
+six =6
+
+[section_four]
+   [section_five]
+ seven and eight= 7 & 8
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/mixed_comment.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/mixed_comment.ini
new file mode 100644
index 0000000..77ed510
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/mixed_comment.ini
@@ -0,0 +1,7 @@
+# comments should be ignored
+; multiple comments characeters are supported
+; (I'm lookin' at you, samba)
+[section_one]
+one = 1
+two = 2
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/param.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/param.ini
new file mode 100644
index 0000000..0700f6b
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/param.ini
@@ -0,0 +1,5 @@
+; comments should be ignored
+[section_one]
+one : 1
+two:2
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/test_inifile.rb b/lib/bbcloud/vendor/ini-0.1.1/test/test_inifile.rb
new file mode 100644
index 0000000..b5d764c
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/test_inifile.rb
@@ -0,0 +1,277 @@
+# Code Generated by ZenTest v. 3.3.0
+#                 classname: asrt / meth =  ratio%
+#             Rini::IniFile:    0 /    9 =   0.00%
+
+begin
+  require 'inifile'
+rescue LoadError
+  require 'rubygems'
+  require 'inifile'
+end
+
+begin; require 'turn'; rescue LoadError; end
+require 'test/unit' unless defined? $ZENTEST and $ZENTEST
+
+class TestIniFile < Test::Unit::TestCase
+
+  def setup
+    @ini_file = ::IniFile.new 'test/data/good.ini'
+    @contents = [
+      ['section_one', 'one', '1'],
+      ['section_one', 'two', '2'],
+      ['section_two', 'three', '3'],
+      ['section three', 'four', '4'],
+      ['section three', 'five', '5'],
+      ['section three', 'six', '6'],
+      ['section_five', 'seven and eight', '7 & 8']
+    ].sort
+  end
+
+  def test_class_load
+    ini_file = ::IniFile.load 'test/data/good.ini'
+    assert_instance_of ::IniFile, ini_file
+
+    # see if we can parse different style comments
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/comment.ini'}
+
+    ini_file = ::IniFile.load 'test/data/comment.ini', :comment => '#'
+    assert_instance_of ::IniFile, ini_file
+
+    # see if we can parse mixed style comments
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/mixed_comment.ini'}
+
+    ini_file = ::IniFile.load 'test/data/mixed_comment.ini', :comment => ';#'
+    assert_instance_of ::IniFile, ini_file
+
+    # see if we can parse different style param separators
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/param.ini'}
+
+    ini_file = ::IniFile.load 'test/data/param.ini', :parameter => ':'
+    assert_instance_of ::IniFile, ini_file
+
+    # make sure we error out on files with bad lines
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/bad_1.ini'}
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/bad_2.ini'}
+  end
+
+  def test_clone
+    clone = @ini_file.clone
+    assert_equal @ini_file, clone
+    assert !clone.tainted?
+    assert !clone.frozen?
+
+    # the clone should be completely independent of the original
+    clone['new_section']['one'] = 1
+    assert_not_equal @ini_file, clone
+
+    # the tainted state is copied to clones
+    @ini_file.taint
+    assert @ini_file.tainted?
+
+    clone = @ini_file.clone
+    assert clone.tainted?
+
+    # the frozen state is also copied to clones
+    @ini_file.freeze
+    assert @ini_file.frozen?
+
+    clone = @ini_file.clone
+    assert clone.tainted?
+    assert clone.frozen?
+  end
+
+  def test_delete_section
+    assert_nil @ini_file.delete_section('section_nil')
+
+    h = {'one' => '1', 'two' => '2'}
+    assert_equal true, @ini_file.has_section?('section_one')
+    assert_equal h, @ini_file.delete_section('section_one')
+    assert_equal false, @ini_file.has_section?('section_one')
+    assert_nil @ini_file.delete_section('section_one')
+  end
+
+  def test_dup
+    dup = @ini_file.dup
+    assert_equal @ini_file, dup
+    assert !dup.tainted?
+    assert !dup.frozen?
+
+    # the duplicate should be completely independent of the original
+    dup['new_section']['one'] = 1
+    assert_not_equal @ini_file, dup
+
+    # the tainted state is copied to duplicates
+    @ini_file.taint
+    assert @ini_file.tainted?
+
+    dup = @ini_file.dup
+    assert dup.tainted?
+
+    # the frozen state, however, is not
+    @ini_file.freeze
+    assert @ini_file.frozen?
+
+    dup = @ini_file.dup
+    assert dup.tainted?
+    assert !dup.frozen?
+  end
+
+  def test_each
+    ary = []
+    @ini_file.each {|*args| ary << args}
+
+    assert_equal @contents, ary.sort
+
+    ary = []
+    ::IniFile.new('temp.ini').each {|*args| ary << args}
+    assert_equal [], ary
+  end
+
+  def test_each_section
+    expected = [
+      'section_one', 'section_two', 'section three',
+      'section_four', 'section_five'
+    ].sort
+
+    ary = []
+    @ini_file.each_section {|section| ary << section}
+
+    assert_equal expected, ary.sort
+
+    ary = []
+    ::IniFile.new('temp.ini').each_section {|section| ary << section}
+    assert_equal [], ary
+  end
+
+  def test_eql_eh
+    assert @ini_file.eql?(@ini_file)
+    assert @ini_file.eql?(@ini_file.clone)
+    assert !@ini_file.eql?('string')
+    assert !@ini_file.eql?(IniFile.new(''))
+  end
+
+  def test_freeze
+    assert_equal false, @ini_file.frozen?
+    @ini_file.each_section do |s|
+      assert_equal false, @ini_file[s].frozen?
+    end
+
+    @ini_file.freeze
+
+    assert_equal true, @ini_file.frozen?
+    @ini_file.each_section do |s|
+      assert_equal true, @ini_file[s].frozen?
+    end
+  end
+
+  def test_has_section_eh
+    assert_equal true,  @ini_file.has_section?('section_one')
+    assert_equal false, @ini_file.has_section?('section_ten')
+    assert_equal true,  @ini_file.has_section?(:section_two)
+    assert_equal false, @ini_file.has_section?(nil)
+
+    ini_file = ::IniFile.new 'temp.ini'
+    assert_equal false, ini_file.has_section?('section_one')
+    assert_equal false, ini_file.has_section?('one')
+    assert_equal false, ini_file.has_section?('two')
+  end
+
+  def test_index
+    expected = {
+      'one' => '1',
+      'two' => '2'
+    }
+    assert_equal expected, @ini_file[:section_one]
+
+    expected = {'three' => '3'}
+    assert_equal expected, @ini_file['section_two']
+
+    expected = {
+      'four' => '4',
+      'five' => '5',
+      'six'  => '6',
+    }
+    assert_equal expected, @ini_file['section three']
+
+    expected = {}
+    assert_equal expected, @ini_file['section_four']
+
+    expected = {'seven and eight' => '7 & 8'}
+    assert_equal expected, @ini_file['section_five']
+
+    expected = {}
+    assert_equal expected, @ini_file['section_six']
+
+    assert_nil @ini_file[nil]
+
+    expected = {}
+    ini_file = ::IniFile.new 'temp.ini'
+    assert_equal expected, ini_file['section_one']
+    assert_equal expected, ini_file['one']
+    assert_nil ini_file[nil]
+  end
+
+  def test_initialize
+    # see if we can parse different style comments
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/comment.ini'}
+
+    ini_file = ::IniFile.new 'test/data/comment.ini', :comment => '#'
+    assert_equal true, ini_file.has_section?('section_one')
+
+    # see if we can parse different style param separators
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/param.ini'}
+
+    ini_file = ::IniFile.new 'test/data/param.ini', :parameter => ':'
+    assert_equal true, ini_file.has_section?('section_one')
+    assert_equal '1', ini_file['section_one']['one']
+    assert_equal '2', ini_file['section_one']['two']
+
+    # make sure we error out on files with bad lines
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/bad_1.ini'}
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/bad_2.ini'}
+  end
+
+  def test_sections
+    expected = [
+      'section_one', 'section_two', 'section three',
+      'section_four', 'section_five'
+    ].sort
+
+    assert_equal expected, @ini_file.sections.sort
+
+    ini_file = ::IniFile.new 'temp.ini'
+    assert_equal [], ini_file.sections
+  end
+
+  def test_taint
+    assert_equal false, @ini_file.tainted?
+    @ini_file.each_section do |s|
+      assert_equal false, @ini_file[s].tainted?
+    end
+
+    @ini_file.taint
+
+    assert_equal true, @ini_file.tainted?
+    @ini_file.each_section do |s|
+      assert_equal true, @ini_file[s].tainted?
+    end
+  end
+
+  def test_write
+    tmp = 'test/data/temp.ini'
+    ::File.delete tmp if ::Kernel.test(?f, tmp)
+
+    @ini_file.save tmp
+    assert_equal true, ::Kernel.test(?f, tmp)
+
+    ::File.delete tmp if ::Kernel.test(?f, tmp)
+
+    ini_file = ::IniFile.new tmp
+    ini_file.save
+    assert_nil ::Kernel.test(?s, tmp)
+
+    ::File.delete tmp if ::Kernel.test(?f, tmp)
+  end
+end
+
+# EOF

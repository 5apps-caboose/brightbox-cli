diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/Gemfile b/lib/bbcloud/vendor/excon-0.2.3-johnl/Gemfile
new file mode 100644
index 0000000..209c4ad
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/Gemfile
@@ -0,0 +1,11 @@
+source "http://rubygems.org"
+
+group :test do
+  gem "shindo"
+  gem "tach"
+
+  gem "sinatra"
+  gem "rake"
+  gem "mongrel"
+  gem "open4"
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/README.rdoc b/lib/bbcloud/vendor/excon-0.2.3-johnl/README.rdoc
new file mode 100644
index 0000000..b33e3de
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/README.rdoc
@@ -0,0 +1,57 @@
+= excon
+
+Http(s) EXtended CONnections
+
+== Getting Started
+
+  sudo gem install excon
+
+Now you are ready to get started, easiest is to use one off requests to start.
+
+  Excon.get('http://geemus.com')
+
+This will return a response object, which has body, headers and status attributes you can check out.
+
+This supports all the major http verbs: [connect, delete, get, head, options, post, put, trace]
+
+You can also create a connection to try and keep open across multiple requests.
+
+  connection = Excon.new('http://geemus.com')
+  connection.request(:method => 'GET')
+
+You can also specify more complicated options to either style of call
+
+  Excon.get('http://geemus.com', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+  # or
+  connection.request(:method => 'GET', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+
+If you need to do something special with a response you can also pass a block that will be called with each chunk.
+
+  Excon.get('http://geemus.com') {|chunk| p chunk }
+
+From there you should be able to make just about any request you might need.
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/Rakefile b/lib/bbcloud/vendor/excon-0.2.3-johnl/Rakefile
new file mode 100644
index 0000000..5f393c8
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/Rakefile
@@ -0,0 +1,147 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+require 'rake/testtask'
+Rake::TestTask.new(:test) do |test|
+  test.libs << 'lib' << 'test'
+  test.pattern = 'test/**/test_*.rb'
+  test.verbose = true
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/excon_vs.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/excon_vs.rb
new file mode 100644
index 0000000..f10d3bc
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/excon_vs.rb
@@ -0,0 +1,39 @@
+require File.join(File.dirname(__FILE__), '..', 'lib/excon')
+
+require 'benchmark'
+require 'net/http'
+require 'open-uri'
+
+COUNT = 100
+data = "Content-Length: 100"
+Benchmark.bmbm(25) do |bench|
+  bench.report('excon') do
+    COUNT.times do
+      Excon.new('http://www.google.com').request(:method => 'GET', :path => '/')
+    end
+  end
+  bench.report('excon (persistent)') do
+    excon = Excon.new('http://www.google.com')
+    COUNT.times do
+      excon.request(:method => 'GET', :path => '/')
+    end
+  end
+  bench.report('net/http') do
+    COUNT.times do
+      # Net::HTTP.get('www.google.com', '/')
+      Net::HTTP.start('www.google.com') {|http| http.get('/') }
+    end
+  end
+  bench.report('net/http (persistent)') do
+    Net::HTTP.start('www.google.com', 80) do |http|
+      COUNT.times do
+        http.get('/')
+      end
+    end
+  end
+  bench.report('open-uri') do
+    COUNT.times do
+      open('http://www.google.com/').read
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/headers_split_vs_match.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/headers_split_vs_match.rb
new file mode 100644
index 0000000..77f4b75
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/headers_split_vs_match.rb
@@ -0,0 +1,47 @@
+# require 'benchmark'
+
+# COUNT = 1_000_000
+# data = "Content-Length: 100"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('regex') do
+#     COUNT.times do
+#       header = data.match(/(.*):\s(.*)/)
+#     end
+#   end
+#   bench.report('split') do
+#     COUNT.times do
+#       header = data.split(': ')
+#     end
+#   end
+# end
+
+# Rehearsal ------------------------------------------------------------
+# regex                      4.270000   0.010000   4.280000 (  4.294186)
+# split                      3.870000   0.000000   3.870000 (  3.885645)
+# --------------------------------------------------- total: 8.150000sec
+# 
+#                                user     system      total        real
+# regex                      4.260000   0.010000   4.270000 (  4.284764)
+# split                      3.860000   0.010000   3.870000 (  3.882795)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100"
+Tach.meter(1_000_000) do
+  tach('regex') do
+    data.match(/(.*):\s(.*)/)
+    header = [$1, $2]
+  end
+  tach('split') do
+    header = data.split(': ')
+  end
+end
+
+# +-------+----------+----------+
+# | tach  | average  | total    |
+# +-------+----------+----------+
+# | regex | 4.680451 | 4.680451 |
+# +-------+----------+----------+
+# | split | 4.393218 | 4.393218 |
+# +-------+----------+----------+
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/strip_newline.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/strip_newline.rb
new file mode 100644
index 0000000..88a964f
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/benchmarks/strip_newline.rb
@@ -0,0 +1,115 @@
+# require 'benchmark'
+# 
+# COUNT = 1_000_000
+# data = "Content-Length: 100\r\n"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('chomp') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp
+#     end
+#   end
+#   bench.report('chomp!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp!
+#     end
+#   end
+#   bench.report('chop') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop
+#     end
+#   end
+#   bench.report('chop!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop!
+#     end
+#   end
+#   bench.report('strip') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip
+#     end
+#   end
+#   bench.report('strip!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip!
+#     end
+#   end
+#   bench.report('index') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data[0..-3]
+#     end
+#   end
+# end
+
+
+
+# Rehearsal ------------------------------------------------------------
+# chomp                      0.640000   0.000000   0.640000 (  0.644043)
+# chomp!                     0.530000   0.000000   0.530000 (  0.531415)
+# chop                       0.620000   0.000000   0.620000 (  0.624321)
+# chop!                      0.500000   0.000000   0.500000 (  0.509146)
+# strip                      0.640000   0.000000   0.640000 (  0.638785)
+# strip!                     0.530000   0.000000   0.530000 (  0.532196)
+# index                      0.740000   0.000000   0.740000 (  0.745742)
+# --------------------------------------------------- total: 4.200000sec
+# 
+#                                user     system      total        real
+# chomp                      0.640000   0.010000   0.650000 (  0.647287)
+# chomp!                     0.530000   0.000000   0.530000 (  0.532868)
+# chop                       0.630000   0.000000   0.630000 (  0.628236)
+# chop!                      0.520000   0.000000   0.520000 (  0.522950)
+# strip                      0.640000   0.000000   0.640000 (  0.646328)
+# strip!                     0.520000   0.000000   0.520000 (  0.532715)
+# index                      0.740000   0.010000   0.750000 (  0.771277)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100\r\n"
+Tach.meter(1_000_000) do
+  tach('chomp') do
+    data.dup.chomp
+  end
+  tach('chomp!') do
+    data.dup.chomp!
+  end
+  tach('chop') do
+    data.dup.chop
+  end
+  tach('chop!') do
+    data.dup.chop!
+  end
+  tach('strip') do
+    data.dup.strip
+  end
+  tach('strip!') do
+    data.dup.strip!
+  end
+  tach('index') do
+    data.dup[0..-3]
+  end
+end
+
+# +--------+----------+----------+
+# | tach   | average  | total    |
+# +--------+----------+----------+
+# | chomp  | 1.444547 | 1.444547 |
+# +--------+----------+----------+
+# | chomp! | 1.276813 | 1.276813 |
+# +--------+----------+----------+
+# | chop   | 1.422744 | 1.422744 |
+# +--------+----------+----------+
+# | chop!  | 1.240941 | 1.240941 |
+# +--------+----------+----------+
+# | strip  | 1.444776 | 1.444776 |
+# +--------+----------+----------+
+# | strip! | 1.266459 | 1.266459 |
+# +--------+----------+----------+
+# | index  | 1.557975 | 1.557975 |
+# +--------+----------+----------+
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/excon.gemspec b/lib/bbcloud/vendor/excon-0.2.3-johnl/excon.gemspec
new file mode 100644
index 0000000..8953fdb
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/excon.gemspec
@@ -0,0 +1,82 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'excon'
+  s.version           = '0.2.3'
+  s.date              = '2010-10-10'
+  s.rubyforge_project = 'excon'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "speed, persistence, http(s)"
+  s.description = "EXtended http(s) CONnections"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    benchmarks/excon_vs.rb
+    benchmarks/headers_split_vs_match.rb
+    benchmarks/strip_newline.rb
+    excon.gemspec
+    lib/excon.rb
+    lib/excon/connection.rb
+    lib/excon/errors.rb
+    lib/excon/response.rb
+    tests/config.ru
+    tests/test_helper.rb
+    tests/threaded_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon.rb
new file mode 100644
index 0000000..1e69941
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon.rb
@@ -0,0 +1,36 @@
+__DIR__ = File.dirname(__FILE__)
+
+$LOAD_PATH.unshift __DIR__ unless
+  $LOAD_PATH.include?(__DIR__) ||
+  $LOAD_PATH.include?(File.expand_path(__DIR__))
+
+require 'cgi'
+require 'openssl'
+require 'socket'
+require 'uri'
+
+require 'excon/connection'
+require 'excon/errors'
+require 'excon/response'
+
+module Excon
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.2.3'
+  end
+
+  CHUNK_SIZE = 1048576 # 1 megabyte
+
+  def self.new(url, params = {})
+    Excon::Connection.new(url, params)
+  end
+
+  %w{connect delete get head options post put trace}.each do |method|
+    eval <<-DEF
+      def self.#{method}(url, params = {}, &block)
+        new(url).request(params.merge!(:method => '#{method.upcase}'), &block)
+      end
+    DEF
+  end
+
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/connection.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/connection.rb
new file mode 100644
index 0000000..9ca9262
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/connection.rb
@@ -0,0 +1,132 @@
+module Excon
+  class Connection
+
+    def initialize(url, params = {})
+      uri = URI.parse(url)
+      @connection = {
+        :headers  => {},
+        :host     => uri.host,
+        :path     => uri.path,
+        :port     => uri.port,
+        :query    => uri.query,
+        :scheme   => uri.scheme
+      }.merge!(params)
+    end
+
+    def request(params, &block)
+      begin
+        params[:path] ||= @connection[:path]
+        unless params[:path][0..0] == '/'
+          params[:path] = "/#{params[:path]}"
+        end
+        request = "#{params[:method].upcase} #{params[:path]}?"
+        for key, values in (params[:query] || @connection[:query] || {})
+          for value in [*values]
+            request << "#{key}#{value && "=#{CGI.escape(value.to_s)}"}&"
+          end
+        end
+        request.chop!
+        request << " HTTP/1.1\r\n"
+        params[:headers] ||= @connection[:headers]
+        params[:headers]['Host'] ||= params[:host] || @connection[:host]
+        params[:body] ||= @connection[:body]
+        params[:headers]['Content-Length'] = case params[:body]
+        when File
+          params[:body].binmode
+          File.size(params[:body].path)
+        when String
+          if params[:body].respond_to?(:force_encoding)
+            params[:body].force_encoding('BINARY')
+          end
+          params[:body].length
+        else
+          0
+        end
+        for key, value in params[:headers]
+          request << "#{key}: #{value}\r\n"
+        end
+        request << "\r\n"
+        socket.write(request)
+
+        if params[:body]
+          if params[:body].is_a?(String)
+            socket.write(params[:body])
+          else
+            while chunk = params[:body].read(CHUNK_SIZE)
+              socket.write(chunk)
+            end
+          end
+        end
+
+        response = Excon::Response.parse(socket, params, &block)
+        if response.headers['Connection'] == 'close'
+          reset
+        end
+        response
+      rescue => socket_error
+        reset
+        raise(socket_error)
+      end
+
+      if params[:expects] && ![*params[:expects]].include?(response.status)
+        reset
+        raise(Excon::Errors.status_error(params, response))
+      else
+        response
+      end
+
+    rescue => request_error
+      if params[:idempotent] &&
+          (!request_error.is_a?(Excon::Errors::Error) || response.status != 404)
+        retries_remaining ||= 4
+        retries_remaining -= 1
+        if retries_remaining > 0
+          retry
+        else
+          raise(request_error)
+        end
+      else
+        raise(request_error)
+      end
+    end
+
+    def reset
+      (old_socket = sockets.delete(socket_key)) && old_socket.close
+    end
+
+    private
+
+    def connect
+      new_socket = TCPSocket.open(@connection[:host], @connection[:port])
+
+      if @connection[:scheme] == 'https'
+        @ssl_context = OpenSSL::SSL::SSLContext.new
+        @ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
+        new_socket = OpenSSL::SSL::SSLSocket.new(new_socket, @ssl_context)
+        new_socket.sync_close = true
+        new_socket.connect
+      end
+
+      new_socket
+    end
+
+    def closed?
+      sockets[socket_key] && sockets[socket_key].closed?
+    end
+
+    def socket
+      if closed?
+        reset
+      end
+      sockets[socket_key] ||= connect
+    end
+
+    def sockets
+      Thread.current[:_excon_sockets] ||= {}
+    end
+
+    def socket_key
+      "#{@connection[:host]}:#{@connection[:port]}"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/errors.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/errors.rb
new file mode 100644
index 0000000..0012156
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/errors.rb
@@ -0,0 +1,104 @@
+module Excon
+
+  module Errors
+    class Error < StandardError; 
+      attr_reader :request, :response
+
+      def initialize(msg, request = nil, response = nil)
+        super(msg)
+        @request = request
+        @response = response
+      end
+    end
+
+    class Continue < Error; end                     # 100
+    class SwitchingProtocols < Error; end           # 101
+    class OK < Error; end                           # 200
+    class Created < Error; end                      # 201
+    class Accepted < Error; end                     # 202
+    class NonAuthoritativeInformation < Error; end  # 203
+    class NoContent < Error; end                    # 204
+    class ResetContent < Error; end                 # 205
+    class PartialContent < Error; end               # 206
+    class MultipleChoices < Error; end              # 300
+    class MovedPermanently < Error; end             # 301
+    class Found < Error; end                        # 302
+    class SeeOther < Error; end                     # 303
+    class NotModified < Error; end                  # 304
+    class UseProxy < Error; end                     # 305
+    class TemporaryRedirect < Error; end            # 307
+    class BadRequest < Error; end                   # 400
+    class Unauthorized < Error; end                 # 401
+    class PaymentRequired < Error; end              # 402
+    class Forbidden < Error; end                    # 403
+    class NotFound < Error; end                     # 404
+    class MethodNotAllowed < Error; end             # 405
+    class NotAcceptable < Error; end                # 406
+    class ProxyAuthenticationRequired < Error; end  # 407
+    class RequestTimeout < Error; end               # 408
+    class Conflict < Error; end                     # 409
+    class Gone < Error; end                         # 410
+    class LengthRequired < Error; end               # 411
+    class PreconditionFailed < Error; end           # 412
+    class RequestEntityTooLarge < Error; end        # 412
+    class RequestURITooLong < Error; end            # 414
+    class UnsupportedMediaType < Error; end         # 415
+    class RequestedRangeNotSatisfiable < Error; end # 416
+    class ExpectationFailed < Error; end            # 417
+    class UnprocessableEntity < Error; end          # 422
+    class InternalServerError < Error; end          # 500
+    class NotImplemented < Error; end               # 501
+    class BadGateway < Error; end                   # 502
+    class ServiceUnavailable < Error; end           # 503
+    class GatewayTimeout < Error; end               # 504
+
+    # Messages for nicer exceptions, from rfc2616
+    def self.status_error(request, response)
+      @errors ||= { 
+        100 => [Excon::Errors::Continue, 'Continue'],
+        101 => [Excon::Errors::SwitchingProtocols, 'Switching Protocols'],
+        200 => [Excon::Errors::OK, 'OK'],
+        201 => [Excon::Errors::Created, 'Created'],
+        202 => [Excon::Errors::Accepted, 'Accepted'],
+        203 => [Excon::Errors::NonAuthoritativeInformation, 'Non-Authoritative Information'],
+        204 => [Excon::Errors::NoContent, 'No Content'],
+        205 => [Excon::Errors::ResetContent, 'Reset Content'],
+        206 => [Excon::Errors::PartialContent, 'Partial Content'],
+        300 => [Excon::Errors::MultipleChoices, 'Multiple Choices'],
+        301 => [Excon::Errors::MovedPermanently, 'Moved Permanently'],
+        302 => [Excon::Errors::Found, 'Found'],
+        303 => [Excon::Errors::SeeOther, 'See Other'],
+        304 => [Excon::Errors::NotModified, 'Not Modified'],
+        305 => [Excon::Errors::UseProxy, 'Use Proxy'],
+        307 => [Excon::Errors::TemporaryRedirect, 'Temporary Redirect'],
+        400 => [Excon::Errors::BadRequest, 'Bad Request'],
+        401 => [Excon::Errors::Unauthorized, 'Unauthorized'],
+        402 => [Excon::Errors::PaymentRequired, 'Payment Required'],
+        403 => [Excon::Errors::Forbidden, 'Forbidden'],
+        404 => [Excon::Errors::NotFound, 'Not Found'],
+        405 => [Excon::Errors::MethodNotAllowed, 'Method Not Allowed'],
+        406 => [Excon::Errors::NotAcceptable, 'Not Acceptable'],
+        407 => [Excon::Errors::ProxyAuthenticationRequired, 'Proxy Authentication Required'],
+        408 => [Excon::Errors::RequestTimeout, 'Request Timeout'],
+        409 => [Excon::Errors::Conflict, 'Conflict'],
+        410 => [Excon::Errors::Gone, 'Gone'],
+        411 => [Excon::Errors::LengthRequired, 'Length Required'],
+        412 => [Excon::Errors::PreconditionFailed, 'Precondition Failed'],
+        413 => [Excon::Errors::RequestEntityTooLarge, 'Request Entity Too Large'],
+        414 => [Excon::Errors::RequestURITooLong, 'Request-URI Too Long'],
+        415 => [Excon::Errors::UnsupportedMediaType, 'Unsupported Media Type'],
+        416 => [Excon::Errors::RequestedRangeNotSatisfiable, 'Request Range Not Satisfiable'],
+        417 => [Excon::Errors::ExpectationFailed, 'Expectation Failed'],
+        422 => [Excon::Errors::UnprocessableEntity, 'Unprocessable Entity'],
+        500 => [Excon::Errors::InternalServerError, 'InternalServerError'],
+        501 => [Excon::Errors::NotImplemented, 'Not Implemented'],
+        502 => [Excon::Errors::BadGateway, 'Bad Gateway'],
+        503 => [Excon::Errors::ServiceUnavailable, 'Service Unavailable'],
+        504 => [Excon::Errors::GatewayTimeout, 'Gateway Timeout']
+      }
+      error, message = @errors[response.status] || [Excon::Errors::Error, 'Unknown']
+      error.new("Expected(#{request[:expects].inspect}) <=> Actual(#{response.status} #{message})\n  request => #{request.inspect}\n  response => #{response.inspect}", request, response)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/response.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/response.rb
new file mode 100644
index 0000000..49f7efc
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/lib/excon/response.rb
@@ -0,0 +1,62 @@
+module Excon
+  class Response
+
+    def self.parse(socket, params = {}, &block)
+      if params[:block]
+        print "  \e[33m[WARN] params[:block] is deprecated, please pass the block to the request\e[0m"
+        block = params[:block]
+      end
+
+      response = new
+
+      response.status = socket.readline[9..11].to_i
+      while true
+        data = socket.readline.chop!
+        unless data.empty?
+          key, value = data.split(': ')
+          response.headers[key] = value
+        else
+          break
+        end
+      end
+
+      unless params[:method] == 'HEAD'
+        if !block || (params[:expects] && ![*params[:expects]].include?(response.status))
+          response.body = ''
+          block = lambda { |chunk| response.body << chunk }
+        end
+
+        if response.headers['Transfer-Encoding'] && response.headers['Transfer-Encoding'].downcase == 'chunked'
+          while true
+            chunk_size = socket.readline.chop!.to_i(16)
+            chunk = socket.read(chunk_size + 2).chop! # 2 == "/r/n".length
+            if chunk_size > 0
+              block.call(chunk)
+            else
+              break
+            end
+          end
+        elsif response.headers['Connection'] && response.headers['Connection'].downcase == 'close'
+          block.call(socket.read)
+        elsif response.headers['Content-Length']
+          remaining = response.headers['Content-Length'].to_i
+          while remaining > 0
+            block.call(socket.read([CHUNK_SIZE, remaining].min))
+            remaining -= CHUNK_SIZE
+          end
+        end
+      end
+
+      response
+    end
+
+    attr_accessor :body, :headers, :status
+
+    def initialize(attributes = {})
+      @body    = attributes[:body] || ''
+      @headers = attributes[:headers] || {}
+      @status  = attributes[:status]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/config.ru b/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/config.ru
new file mode 100644
index 0000000..2fa5581
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/config.ru
@@ -0,0 +1,10 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get '/id/:id/wait/:wait' do |id, wait|
+    sleep wait.to_i
+    id.to_s
+  end
+end
+
+run App
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/test_helper.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/test_helper.rb
new file mode 100644
index 0000000..e709e52
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/test_helper.rb
@@ -0,0 +1,15 @@
+require File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib/excon'))
+
+require 'open4'
+
+def local_file(*parts)
+  File.expand_path(File.join(File.dirname(__FILE__), *parts))
+end
+
+def with_rackup(configru = local_file('config.ru'))
+  pid, w, r, e = Open4.popen4("rackup #{configru}")
+  while `lsof -p #{pid} -P -i | grep ruby | grep TCP`.chomp.empty?; end
+  yield
+ensure
+  Process.kill(9, pid)
+end
diff --git a/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/threaded_tests.rb b/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/threaded_tests.rb
new file mode 100644
index 0000000..6f102b6
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.2.3-johnl/tests/threaded_tests.rb
@@ -0,0 +1,24 @@
+require File.expand_path(File.join(File.dirname(__FILE__), 'test_helper'))
+
+with_rackup do
+  Shindo.tests do
+    test('threaded requests') do
+      connection = Excon.new('http://127.0.0.1:9292')
+
+      long_thread = Thread.new {
+        response = connection.request(:method => 'GET', :path => '/id/1/wait/2')
+        Thread.current[:success] = response.body == '1'
+      }
+
+      short_thread = Thread.new {
+        response = connection.request(:method => 'GET', :path => '/id/2/wait/1')
+        Thread.current[:success] = response.body == '2'
+      }
+
+      long_thread.join
+      short_thread.join
+
+      long_thread[:success] && short_thread[:success]
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/Gemfile b/lib/bbcloud/vendor/fog/Gemfile
new file mode 100644
index 0000000..c80ee36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/Gemfile
@@ -0,0 +1,3 @@
+source "http://rubygems.org"
+
+gemspec
diff --git a/lib/bbcloud/vendor/fog/Gemfile.lock b/lib/bbcloud/vendor/fog/Gemfile.lock
new file mode 100644
index 0000000..3448aaa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/Gemfile.lock
@@ -0,0 +1,48 @@
+PATH
+  remote: .
+  specs:
+    fog (0.3.0)
+      builder
+      excon (>= 0.2.1)
+      formatador (>= 0.0.15)
+      json
+      mime-types
+      net-ssh (~> 2.0.23)
+      nokogiri (~> 1.4.3.1)
+      ruby-hmac
+
+GEM
+  remote: http://rubygems.org/
+  specs:
+    builder (2.1.2)
+    excon (0.2.1)
+    formatador (0.0.15)
+    gestalt (0.0.11)
+      formatador (>= 0.0.12)
+    json (1.4.6)
+    mime-types (1.16)
+    net-ssh (2.0.23)
+    nokogiri (1.4.3.1)
+    rake (0.8.7)
+    rspec (1.3.0)
+    ruby-hmac (0.4.0)
+    shindo (0.1.6)
+      formatador (>= 0.0.14)
+      gestalt (>= 0.0.11)
+
+PLATFORMS
+  ruby
+
+DEPENDENCIES
+  builder
+  excon (>= 0.2.1)
+  fog!
+  formatador (>= 0.0.15)
+  json
+  mime-types
+  net-ssh (~> 2.0.23)
+  nokogiri (~> 1.4.3.1)
+  rake
+  rspec
+  ruby-hmac
+  shindo (= 0.1.6)
diff --git a/lib/bbcloud/vendor/fog/README.rdoc b/lib/bbcloud/vendor/fog/README.rdoc
new file mode 100644
index 0000000..c51fc58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/README.rdoc
@@ -0,0 +1,141 @@
+http://geemus.com/fog.png
+
+fog is the Ruby cloud computing library.
+
+The quick and dirty, top to bottom:
+* Collections provide a simplified interface, making clouds easier to work with and switch between.
+* Requests allow power users to get the most out of the features of each individual cloud.
+* Mocks make testing and integrating a breeze.
+
+Put them together and you get a great cloud computing experience, but we are getting ahead of ourselves...
+
+== Getting Started
+
+  sudo gem install fog
+
+Now just type 'fog' to trying stuff out, confident that fog should let you know what you need to do. Here is an example of wading through server creation for Amazon Elastic Compute Cloud:
+
+  >> server = AWS.servers.create
+  ArgumentError: image_id is required for this operation
+  >> server = AWS.servers.create(:image_id => 'ami-5ee70037')
+  <Fog::AWS::EC2::Server [...]>
+  >> server.destroy # cleanup after yourself or regret it, trust me
+  true
+
+== Collections
+
+A high level interface to each cloud is provided through collections, such as images and servers.
+You can see a list of available collections by calling #collections on the connection object.
+Some of these collections are shared across multiple providers.
+Shared collections for compute are: flavors, images and servers.
+Shared collections for storage are: directory and file.
+
+Some common methods for all of these collections are:
+* #all - fetch every object of that type from the provider.
+* #create  initialize a new record locally and then persists it with the provider.
+* #get - fetch a single object by its identity from the provider.
+* #new - initialize a new record locally, but do not persist it to the provider.
+
+As an example, we'll try initializing and persisting a Rackspace Cloud server:
+
+  require 'fog'
+
+  # initialize a connection to Rackspace Cloud Servers
+  connection = Fog::Rackspace::Servers.new(
+    :rackspace_api_key => key,
+    :rackspace_username => username
+  )
+
+  # boot a gentoo server (flavor 1 = 256, image 3 = gentoo 2008.0)
+  server = connection.servers.create(:flavor_id => 1, :image_id => 3, :name => 'my_server')
+
+  # wait for it to be ready to do stuff
+  server.wait_for { ready? }
+
+  # DO STUFF
+
+  # shutdown the server
+  server.destroy
+
+== Models
+
+Many of the collection methods return individual objects, which also provide some common methods:
+* #destroy - will destroy the persisted object from the provider
+* #save - persist the object to the provider
+* #wait_for - takes a block and waits for either the block to return true for the object or for a timeout (defaults to 10 minutes)
+
+== Mocks
+
+Mocking provides an in memory representation of the state of cloud resources as you make requests.
+Mocked calls to mimic the behavior of each provider while eliminating the cost and time needed to actually use cloud resources.
+Enabling mocking easy to use, before you run any other commands run:
+
+  Fog.mock!
+
+Then you can run other commands just like you always would.
+Some mocks are not implemented just yet, but fog will raise an error to let you know and contributions are always welcome!
+
+== Requests
+
+Requests allow you to dive deeper when the models just can't cut it.
+You can see a list of available requests by calling #requests on the connection object.
+For instance, ec2 provides methods related to reserved instances that don't have any models (yet).
+Here is how you can lookup your reserved instances:
+
+  $ fog
+  >> AWS[:ec2].describe_reserved_instances
+  #<Excon::Response [...]>
+
+It will return an {excon}[http://github.com/geemus/excon] response, which has #headers and #body. Both return nice hashes.
+
+== Go forth and conquer
+
+Play around and use the console to explore or check out the {getting started guide}[http://wiki.github.com/geemus/fog/getting-started-with-fog] for more details.
+
+You should try out the (varying) support fog has for:
+* {AWS}[http://aws.amazon.com] [{EC2}[http://aws.amazon.com/ec2], {ELB}[http://aws.amazon.com/elasticloadbalancing], {S3}[http://aws.amazon.com/s3], {SimpleDB}[http://aws.amazon.com/simpledb]]
+* {Blue Box Group}[http://www.blueboxgrp.com] [{Blocks}[http://www.blueboxgrp.com/blocks]]
+* {Rackspace}[http://www.rackspace.com] [{Files}[http://www.rackspacecloud.com/cloud_hosting_products/files], {Servers}[http://www.rackspacecloud.com/cloud_hosting_products/servers]]
+* {Slicehost}[http://www.slicehost.com]
+* {Terremark}[http://www.terremark.com] [{vCloud Express}[http://vcloudexpress.terremark.com]]
+
+There are also the basics of these providers (that could use your love):
+* {GoGrid}[http://www.gogrid.com]
+* {Linode}[http://www.linode.com]
+* Local [Files]
+* {New Servers}[http://www.newservers.com]
+
+Enjoy, and let me know what I can do to continue improving fog!
+
+* See what already uses fog and add your own stuff to {the list}[http://wiki.github.com/geemus/fog/in-the-wild].
+* Work for {twitter}[http://twitter.com]? I'd love to reclaim the unused {@fog}[http://twitter.com/fog] account!
+* Follow {@geemus}[http://twitter.com/geemus] on Twitter.
+* Discuss in irc on the {#ruby-fog}[irc://irc.freenode.net/ruby-fog]#ruby-fog channel on Freenode or via email on the {mailing list}[http://groups.google.com/group/ruby-fog].
+* See upcoming work in the {tracker}[http://www.pivotaltracker.com/projects/54635].
+* Report bugs in {issues}[http://github.com/geemus/fog/issues].
+* Learn about {contributing}[http://wiki.github.com/geemus/fog/contributors-guide].
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/fog/Rakefile b/lib/bbcloud/vendor/fog/Rakefile
new file mode 100644
index 0000000..042a8b8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/Rakefile
@@ -0,0 +1,146 @@
+require 'rubygems'
+require 'bundler/setup'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+task :test do
+  sh("export FOG_MOCK=true  && bundle exec spec -cfs spec") &&
+  sh("export FOG_MOCK=true  && bundle exec shindo tests") &&
+  sh("export FOG_MOCK=false && bundle exec spec -cfs spec") &&
+  sh("export FOG_MOCK=false && bundle exec shindo tests")
+end
+
+task :ci do
+  sh("export FOG_MOCK=true  && bundle exec spec spec") &&
+  sh("export FOG_MOCK=true  && bundle exec shindont tests") &&
+  sh("export FOG_MOCK=false && bundle exec spec spec") &&
+  sh("export FOG_MOCK=false && bundle exec shindont tests")
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/benchs/fog_vs.rb b/lib/bbcloud/vendor/fog/benchs/fog_vs.rb
new file mode 100644
index 0000000..464d8df
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/benchs/fog_vs.rb
@@ -0,0 +1,106 @@
+require 'rubygems'
+require 'aws/s3'
+require 'benchmark'
+require 'right_aws'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+
+data = File.open(File.expand_path('~/.fog')).read
+config = YAML.load(data)[:default]
+fog = Fog::AWS::S3.new(
+  :aws_access_key_id     => config[:aws_access_key_id],
+  :aws_secret_access_key => config[:aws_secret_access_key]
+)
+raws = RightAws::S3Interface.new(
+  config[:aws_access_key_id],
+  config[:aws_secret_access_key]
+)
+raws.logger.level = 3 # ERROR
+awss3 = AWS::S3::Base.establish_connection!(
+  :access_key_id     => config[:aws_access_key_id],
+  :secret_access_key => config[:aws_secret_access_key],
+  :persistent        => true
+)
+
+TIMES = 10
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('fog.put_bucket') do
+    TIMES.times do |x|
+      fog.put_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.create_bucket') do
+    TIMES.times do |x|
+      raws.create_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.create') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.create("awss3bench#{x}")
+    end
+  end
+
+  bench.report('fog.put_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        fog.put_object("fogbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('raws.put') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        raws.put("rawsbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('awss3::S3Object.create') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        AWS::S3::S3Object.create("lorem_#{y}", file, "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        fog.delete_object("fogbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('raws.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        raws.delete("rawsbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('awss3::S3Object.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        AWS::S3::S3Object.delete("lorem_#{y}", "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_bucket') do
+    TIMES.times do |x|
+      fog.delete_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.delete_bucket') do
+    TIMES.times do |x|
+      raws.delete_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.delete') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.delete("awss3bench#{x}")
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/benchs/params.rb b/lib/bbcloud/vendor/fog/benchs/params.rb
new file mode 100644
index 0000000..25674e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/benchs/params.rb
@@ -0,0 +1,43 @@
+require 'benchmark'
+
+def hash(options)
+  result = "#{options.delete(:name)}"
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+def optional(name, a = nil, b = nil, c = nil)
+  result = "#{name}"
+  options = { :a => a, :b => b, :c => c }
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+COUNT = 100_000
+data = "Content-Length: 100"
+Benchmark.bmbm(25) do |bench|
+  bench.report('hash') do
+    COUNT.times do
+      hash({:name => 'name'})
+    end
+  end
+  bench.report('optional') do
+    COUNT.times do
+      optional('name')
+    end
+  end
+  bench.report('hash_with_option') do
+    COUNT.times do
+      hash({:name => 'name', :a => 'a', :b => 'b', :c => 'c'})
+    end
+  end
+  bench.report('optional_with_option') do
+    COUNT.times do
+      optional('name', :a => 'a', :b => 'b', :c => 'c')
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/benchs/parse_vs_push.rb b/lib/bbcloud/vendor/fog/benchs/parse_vs_push.rb
new file mode 100644
index 0000000..37d85e4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/benchs/parse_vs_push.rb
@@ -0,0 +1,60 @@
+require 'benchmark'
+require 'rubygems'
+require 'nokogiri'
+
+class Parser < Nokogiri::XML::SAX::Document
+
+  attr_reader :response
+
+  def initialize
+    reset
+  end
+
+  def reset
+    @item = {}
+    @response = { :items => [] }
+  end
+
+  def characters(string)
+    @value << string.strip
+  end
+
+  def start_element(name, attrs = [])
+    @value = nil
+  end
+
+  def end_element(name)
+    case name
+    when 'item'
+      @response[:items] << @item
+      @item = {}
+    when 'key'
+      @item[:key] = @value
+    end
+  end
+
+end
+
+data = <<-DATA
+<items>
+  <item>
+    <key>value</key>
+  </item>
+</items>
+DATA
+
+COUNT = 100
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('parse') do
+    parser = Parser.new
+    Nokogiri::XML::SAX::Parser.new(parser).parse(data)
+    parser.response
+  end
+
+  bench.report('push') do
+    parser = Parser.new
+    Nokogiri::XML::SAX::PushParser.new(parser).write(data, true)
+    parser.response
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/bin/fog b/lib/bbcloud/vendor/fog/bin/fog
new file mode 100755
index 0000000..46cbe72
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/bin/fog
@@ -0,0 +1,44 @@
+#!/usr/bin/env ruby
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+require 'irb'
+require 'yaml'
+require File.join('fog', 'credentials')
+Fog.credential = ARGV.first ? ARGV.first.to_sym : nil
+Fog.bin = true
+unless Fog.credentials
+  exit
+end
+
+require 'fog/bin'
+
+if ARGV.length > 1
+  print(instance_eval(ARGV[1..-1].join(' ')).to_json)
+else
+
+  ARGV.clear # Avoid passing args to IRB
+  IRB.setup(nil)
+  @irb = IRB::Irb.new(nil)
+  IRB.conf[:MAIN_CONTEXT] = @irb.context
+  IRB.conf[:PROMPT][:FOG] = IRB.conf[:PROMPT][:SIMPLE].dup
+  IRB.conf[:PROMPT][:FOG][:RETURN] = "%s\n"
+  @irb.context.prompt_mode = :FOG
+  @irb.context.workspace = IRB::WorkSpace.new(binding)
+
+  providers = Fog.providers.map{|provider| provider.to_s}
+  providers = if providers.length > 1
+    providers[0...-1].join(', ') << ' and ' << providers[-1]
+  else
+    providers.first
+  end
+  Formatador.display_line('Welcome to fog interactive!')
+  Formatador.display_line(":#{Fog.credential.to_s} credentials provide #{providers}")
+  providers = Fog.providers
+  Fog.modules.each do |_module_|
+    if _module_.respond_to?(:startup_notice)
+      _module_.send(:startup_notice)
+    end
+  end
+
+  catch(:IRB_EXIT) { @irb.eval_input }
+
+end
diff --git a/lib/bbcloud/vendor/fog/examples/bluebox_create.rb b/lib/bbcloud/vendor/fog/examples/bluebox_create.rb
new file mode 100644
index 0000000..43c76ac
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/examples/bluebox_create.rb
@@ -0,0 +1,33 @@
+#!/usr/bin/env ruby
+
+# For example only - you'd want to use your own AMI id.
+unless defined?(GENTOO_AMI)
+  GENTOO_AMI = 'ami-5ee70037'
+end
+
+require 'rubygems'
+require 'fog'
+
+@bluebox_api_key = "CHANGEME"
+@aws_access_key_id = "CHANGEME"
+@aws_secret_access_key = "CHANGEME"
+
+@flavor_id = "94fd37a7-2606-47f7-84d5-9000deda52ae" # Block 1GB Virtual Server
+@image_id = "03807e08-a13d-44e4-b011-ebec7ef2c928"  # Ubuntu 10.04 x64 LTS
+
+# Grab our current list of servers
+@bbg_servers = Fog::Bluebox.new(:bluebox_api_key => @bluebox_api_key).servers
+@ec2_servers = Fog::AWS::EC2.new(:aws_access_key_id => @aws_access_key_id, :aws_secret_access_key => @aws_secret_access_key).servers
+
+# Create a new server.
+@server = @bbg_servers.new(:flavor_id => @flavor_id, :image_id => @image_id,
+                           :name => "My Server", :password => "MyPassword")
+
+# Save the server, triggering its creation
+@server.save
+
+if @server.status == 'error'
+  # The create failed - create a new server on Amazon instead
+  @server = @ec2_servers.new(:image_id => GENTOO_AMI)
+  @server.save
+end
diff --git a/lib/bbcloud/vendor/fog/fog.gemspec b/lib/bbcloud/vendor/fog/fog.gemspec
new file mode 100644
index 0000000..63bd772
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/fog.gemspec
@@ -0,0 +1,701 @@
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'fog'
+  s.version           = '0.3.0'
+  s.date              = '2010-10-07'
+  s.rubyforge_project = 'fog'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "brings clouds to you"
+  s.description = "The Ruby cloud computing library."
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/fog'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  s.executables = ["fog"]
+  s.default_executable = 'fog'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  s.add_dependency('builder')
+  s.add_dependency('excon', '>=0.2.1')
+  s.add_dependency('formatador', '>=0.0.15')
+  s.add_dependency('json')
+  s.add_dependency('mime-types')
+  s.add_dependency('net-ssh', '~>2.0.23')
+  s.add_dependency('nokogiri', '~>1.4.3.1')
+  s.add_dependency('ruby-hmac')
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  s.add_development_dependency('rake')
+  s.add_development_dependency('rspec')
+  s.add_development_dependency('shindo', '0.1.6')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    Gemfile.lock
+    README.rdoc
+    Rakefile
+    benchs/fog_vs.rb
+    benchs/params.rb
+    benchs/parse_vs_push.rb
+    bin/fog
+    examples/bluebox_create.rb
+    fog.gemspec
+    lib/fog.rb
+    lib/fog/attributes.rb
+    lib/fog/aws.rb
+    lib/fog/aws/bin.rb
+    lib/fog/aws/compute.rb
+    lib/fog/aws/ec2.rb
+    lib/fog/aws/elb.rb
+    lib/fog/aws/models/compute/address.rb
+    lib/fog/aws/models/compute/addresses.rb
+    lib/fog/aws/models/compute/flavor.rb
+    lib/fog/aws/models/compute/flavors.rb
+    lib/fog/aws/models/compute/image.rb
+    lib/fog/aws/models/compute/images.rb
+    lib/fog/aws/models/compute/key_pair.rb
+    lib/fog/aws/models/compute/key_pairs.rb
+    lib/fog/aws/models/compute/security_group.rb
+    lib/fog/aws/models/compute/security_groups.rb
+    lib/fog/aws/models/compute/server.rb
+    lib/fog/aws/models/compute/servers.rb
+    lib/fog/aws/models/compute/snapshot.rb
+    lib/fog/aws/models/compute/snapshots.rb
+    lib/fog/aws/models/compute/volume.rb
+    lib/fog/aws/models/compute/volumes.rb
+    lib/fog/aws/models/storage/directories.rb
+    lib/fog/aws/models/storage/directory.rb
+    lib/fog/aws/models/storage/file.rb
+    lib/fog/aws/models/storage/files.rb
+    lib/fog/aws/parsers/compute/allocate_address.rb
+    lib/fog/aws/parsers/compute/attach_volume.rb
+    lib/fog/aws/parsers/compute/basic.rb
+    lib/fog/aws/parsers/compute/create_image.rb
+    lib/fog/aws/parsers/compute/create_key_pair.rb
+    lib/fog/aws/parsers/compute/create_snapshot.rb
+    lib/fog/aws/parsers/compute/create_volume.rb
+    lib/fog/aws/parsers/compute/deregister_image.rb
+    lib/fog/aws/parsers/compute/describe_addresses.rb
+    lib/fog/aws/parsers/compute/describe_availability_zones.rb
+    lib/fog/aws/parsers/compute/describe_images.rb
+    lib/fog/aws/parsers/compute/describe_instances.rb
+    lib/fog/aws/parsers/compute/describe_key_pairs.rb
+    lib/fog/aws/parsers/compute/describe_regions.rb
+    lib/fog/aws/parsers/compute/describe_reserved_instances.rb
+    lib/fog/aws/parsers/compute/describe_security_groups.rb
+    lib/fog/aws/parsers/compute/describe_snapshots.rb
+    lib/fog/aws/parsers/compute/describe_volumes.rb
+    lib/fog/aws/parsers/compute/detach_volume.rb
+    lib/fog/aws/parsers/compute/get_console_output.rb
+    lib/fog/aws/parsers/compute/import_key_pair.rb
+    lib/fog/aws/parsers/compute/register_image.rb
+    lib/fog/aws/parsers/compute/run_instances.rb
+    lib/fog/aws/parsers/compute/start_stop_instances.rb
+    lib/fog/aws/parsers/compute/terminate_instances.rb
+    lib/fog/aws/parsers/elb/create_load_balancer.rb
+    lib/fog/aws/parsers/elb/delete_load_balancer.rb
+    lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
+    lib/fog/aws/parsers/elb/describe_instance_health.rb
+    lib/fog/aws/parsers/elb/describe_load_balancers.rb
+    lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
+    lib/fog/aws/parsers/simpledb/basic.rb
+    lib/fog/aws/parsers/simpledb/domain_metadata.rb
+    lib/fog/aws/parsers/simpledb/get_attributes.rb
+    lib/fog/aws/parsers/simpledb/list_domains.rb
+    lib/fog/aws/parsers/simpledb/select.rb
+    lib/fog/aws/parsers/storage/access_control_list.rb
+    lib/fog/aws/parsers/storage/copy_object.rb
+    lib/fog/aws/parsers/storage/get_bucket.rb
+    lib/fog/aws/parsers/storage/get_bucket_location.rb
+    lib/fog/aws/parsers/storage/get_bucket_logging.rb
+    lib/fog/aws/parsers/storage/get_bucket_object_versions.rb
+    lib/fog/aws/parsers/storage/get_bucket_versioning.rb
+    lib/fog/aws/parsers/storage/get_request_payment.rb
+    lib/fog/aws/parsers/storage/get_service.rb
+    lib/fog/aws/requests/compute/allocate_address.rb
+    lib/fog/aws/requests/compute/associate_address.rb
+    lib/fog/aws/requests/compute/attach_volume.rb
+    lib/fog/aws/requests/compute/authorize_security_group_ingress.rb
+    lib/fog/aws/requests/compute/create_image.rb
+    lib/fog/aws/requests/compute/create_key_pair.rb
+    lib/fog/aws/requests/compute/create_security_group.rb
+    lib/fog/aws/requests/compute/create_snapshot.rb
+    lib/fog/aws/requests/compute/create_volume.rb
+    lib/fog/aws/requests/compute/delete_key_pair.rb
+    lib/fog/aws/requests/compute/delete_security_group.rb
+    lib/fog/aws/requests/compute/delete_snapshot.rb
+    lib/fog/aws/requests/compute/delete_volume.rb
+    lib/fog/aws/requests/compute/deregister_image.rb
+    lib/fog/aws/requests/compute/describe_addresses.rb
+    lib/fog/aws/requests/compute/describe_availability_zones.rb
+    lib/fog/aws/requests/compute/describe_images.rb
+    lib/fog/aws/requests/compute/describe_instances.rb
+    lib/fog/aws/requests/compute/describe_key_pairs.rb
+    lib/fog/aws/requests/compute/describe_regions.rb
+    lib/fog/aws/requests/compute/describe_reserved_instances.rb
+    lib/fog/aws/requests/compute/describe_security_groups.rb
+    lib/fog/aws/requests/compute/describe_snapshots.rb
+    lib/fog/aws/requests/compute/describe_volumes.rb
+    lib/fog/aws/requests/compute/detach_volume.rb
+    lib/fog/aws/requests/compute/disassociate_address.rb
+    lib/fog/aws/requests/compute/get_console_output.rb
+    lib/fog/aws/requests/compute/import_key_pair.rb
+    lib/fog/aws/requests/compute/modify_image_attributes.rb
+    lib/fog/aws/requests/compute/modify_snapshot_attribute.rb
+    lib/fog/aws/requests/compute/reboot_instances.rb
+    lib/fog/aws/requests/compute/register_image.rb
+    lib/fog/aws/requests/compute/release_address.rb
+    lib/fog/aws/requests/compute/revoke_security_group_ingress.rb
+    lib/fog/aws/requests/compute/run_instances.rb
+    lib/fog/aws/requests/compute/start_instances.rb
+    lib/fog/aws/requests/compute/stop_instances.rb
+    lib/fog/aws/requests/compute/terminate_instances.rb
+    lib/fog/aws/requests/elb/create_load_balancer.rb
+    lib/fog/aws/requests/elb/delete_load_balancer.rb
+    lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
+    lib/fog/aws/requests/elb/describe_instance_health.rb
+    lib/fog/aws/requests/elb/describe_load_balancers.rb
+    lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
+    lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
+    lib/fog/aws/requests/simpledb/batch_put_attributes.rb
+    lib/fog/aws/requests/simpledb/create_domain.rb
+    lib/fog/aws/requests/simpledb/delete_attributes.rb
+    lib/fog/aws/requests/simpledb/delete_domain.rb
+    lib/fog/aws/requests/simpledb/domain_metadata.rb
+    lib/fog/aws/requests/simpledb/get_attributes.rb
+    lib/fog/aws/requests/simpledb/list_domains.rb
+    lib/fog/aws/requests/simpledb/put_attributes.rb
+    lib/fog/aws/requests/simpledb/select.rb
+    lib/fog/aws/requests/storage/copy_object.rb
+    lib/fog/aws/requests/storage/delete_bucket.rb
+    lib/fog/aws/requests/storage/delete_object.rb
+    lib/fog/aws/requests/storage/get_bucket.rb
+    lib/fog/aws/requests/storage/get_bucket_acl.rb
+    lib/fog/aws/requests/storage/get_bucket_location.rb
+    lib/fog/aws/requests/storage/get_bucket_logging.rb
+    lib/fog/aws/requests/storage/get_bucket_object_versions.rb
+    lib/fog/aws/requests/storage/get_bucket_versioning.rb
+    lib/fog/aws/requests/storage/get_object.rb
+    lib/fog/aws/requests/storage/get_object_acl.rb
+    lib/fog/aws/requests/storage/get_object_torrent.rb
+    lib/fog/aws/requests/storage/get_object_url.rb
+    lib/fog/aws/requests/storage/get_request_payment.rb
+    lib/fog/aws/requests/storage/get_service.rb
+    lib/fog/aws/requests/storage/head_object.rb
+    lib/fog/aws/requests/storage/put_bucket.rb
+    lib/fog/aws/requests/storage/put_bucket_acl.rb
+    lib/fog/aws/requests/storage/put_bucket_logging.rb
+    lib/fog/aws/requests/storage/put_bucket_versioning.rb
+    lib/fog/aws/requests/storage/put_object.rb
+    lib/fog/aws/requests/storage/put_object_url.rb
+    lib/fog/aws/requests/storage/put_request_payment.rb
+    lib/fog/aws/s3.rb
+    lib/fog/aws/simpledb.rb
+    lib/fog/aws/storage.rb
+    lib/fog/bin.rb
+    lib/fog/bluebox.rb
+    lib/fog/bluebox/bin.rb
+    lib/fog/bluebox/compute.rb
+    lib/fog/bluebox/models/compute/flavor.rb
+    lib/fog/bluebox/models/compute/flavors.rb
+    lib/fog/bluebox/models/compute/image.rb
+    lib/fog/bluebox/models/compute/images.rb
+    lib/fog/bluebox/models/compute/server.rb
+    lib/fog/bluebox/models/compute/servers.rb
+    lib/fog/bluebox/requests/compute/create_block.rb
+    lib/fog/bluebox/requests/compute/destroy_block.rb
+    lib/fog/bluebox/requests/compute/get_block.rb
+    lib/fog/bluebox/requests/compute/get_blocks.rb
+    lib/fog/bluebox/requests/compute/get_product.rb
+    lib/fog/bluebox/requests/compute/get_products.rb
+    lib/fog/bluebox/requests/compute/get_template.rb
+    lib/fog/bluebox/requests/compute/get_templates.rb
+    lib/fog/bluebox/requests/compute/reboot_block.rb
+    lib/fog/brightbox.rb
+    lib/fog/brightbox/bin.rb
+    lib/fog/brightbox/compute.rb
+    lib/fog/brightbox/models/compute/cloud_ip.rb
+    lib/fog/brightbox/models/compute/cloud_ips.rb
+    lib/fog/brightbox/models/compute/flavor.rb
+    lib/fog/brightbox/models/compute/flavors.rb
+    lib/fog/brightbox/models/compute/image.rb
+    lib/fog/brightbox/models/compute/images.rb
+    lib/fog/brightbox/models/compute/server.rb
+    lib/fog/brightbox/models/compute/servers.rb
+    lib/fog/brightbox/models/compute/zone.rb
+    lib/fog/brightbox/models/compute/zones.rb
+    lib/fog/brightbox/requests/compute/create_account.rb
+    lib/fog/brightbox/requests/compute/create_api_client.rb
+    lib/fog/brightbox/requests/compute/create_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/create_image.rb
+    lib/fog/brightbox/requests/compute/create_server.rb
+    lib/fog/brightbox/requests/compute/destroy_api_client.rb
+    lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/destroy_image.rb
+    lib/fog/brightbox/requests/compute/destroy_server.rb
+    lib/fog/brightbox/requests/compute/get_account.rb
+    lib/fog/brightbox/requests/compute/get_api_client.rb
+    lib/fog/brightbox/requests/compute/get_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/get_image.rb
+    lib/fog/brightbox/requests/compute/get_interface.rb
+    lib/fog/brightbox/requests/compute/get_server.rb
+    lib/fog/brightbox/requests/compute/get_server_type.rb
+    lib/fog/brightbox/requests/compute/get_user.rb
+    lib/fog/brightbox/requests/compute/get_zone.rb
+    lib/fog/brightbox/requests/compute/list_accounts.rb
+    lib/fog/brightbox/requests/compute/list_api_clients.rb
+    lib/fog/brightbox/requests/compute/list_cloud_ips.rb
+    lib/fog/brightbox/requests/compute/list_images.rb
+    lib/fog/brightbox/requests/compute/list_server_types.rb
+    lib/fog/brightbox/requests/compute/list_servers.rb
+    lib/fog/brightbox/requests/compute/list_users.rb
+    lib/fog/brightbox/requests/compute/list_zones.rb
+    lib/fog/brightbox/requests/compute/map_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/rebuild_server.rb
+    lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
+    lib/fog/brightbox/requests/compute/resize_server.rb
+    lib/fog/brightbox/requests/compute/restart_server.rb
+    lib/fog/brightbox/requests/compute/shutdown_server.rb
+    lib/fog/brightbox/requests/compute/snapshot_server.rb
+    lib/fog/brightbox/requests/compute/start_server.rb
+    lib/fog/brightbox/requests/compute/stop_server.rb
+    lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
+    lib/fog/brightbox/requests/compute/update_account.rb
+    lib/fog/brightbox/requests/compute/update_api_client.rb
+    lib/fog/brightbox/requests/compute/update_image.rb
+    lib/fog/brightbox/requests/compute/update_server.rb
+    lib/fog/brightbox/requests/compute/update_user.rb
+    lib/fog/collection.rb
+    lib/fog/connection.rb
+    lib/fog/credentials.rb
+    lib/fog/deprecation.rb
+    lib/fog/errors.rb
+    lib/fog/go_grid.rb
+    lib/fog/go_grid/bin.rb
+    lib/fog/go_grid/compute.rb
+    lib/fog/go_grid/requests/compute/common_lookup_list.rb
+    lib/fog/go_grid/requests/compute/grid_image_list.rb
+    lib/fog/go_grid/requests/compute/grid_ip_list.rb
+    lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb
+    lib/fog/go_grid/requests/compute/grid_server_add.rb
+    lib/fog/go_grid/requests/compute/grid_server_delete.rb
+    lib/fog/go_grid/requests/compute/grid_server_get.rb
+    lib/fog/go_grid/requests/compute/grid_server_list.rb
+    lib/fog/go_grid/requests/compute/grid_server_power.rb
+    lib/fog/hmac.rb
+    lib/fog/linode.rb
+    lib/fog/linode/bin.rb
+    lib/fog/linode/compute.rb
+    lib/fog/linode/requests/compute/avail_datacenters.rb
+    lib/fog/linode/requests/compute/avail_distributions.rb
+    lib/fog/linode/requests/compute/avail_kernels.rb
+    lib/fog/linode/requests/compute/avail_linodeplans.rb
+    lib/fog/linode/requests/compute/avail_stackscripts.rb
+    lib/fog/linode/requests/compute/linode_create.rb
+    lib/fog/linode/requests/compute/linode_delete.rb
+    lib/fog/linode/requests/compute/linode_list.rb
+    lib/fog/linode/requests/compute/linode_reboot.rb
+    lib/fog/local.rb
+    lib/fog/local/bin.rb
+    lib/fog/local/models/storage/directories.rb
+    lib/fog/local/models/storage/directory.rb
+    lib/fog/local/models/storage/file.rb
+    lib/fog/local/models/storage/files.rb
+    lib/fog/local/storage.rb
+    lib/fog/model.rb
+    lib/fog/new_servers.rb
+    lib/fog/new_servers/bin.rb
+    lib/fog/new_servers/compute.rb
+    lib/fog/new_servers/requests/compute/add_server.rb
+    lib/fog/new_servers/requests/compute/cancel_server.rb
+    lib/fog/new_servers/requests/compute/get_server.rb
+    lib/fog/new_servers/requests/compute/list_images.rb
+    lib/fog/new_servers/requests/compute/list_plans.rb
+    lib/fog/new_servers/requests/compute/list_servers.rb
+    lib/fog/new_servers/requests/compute/reboot_server.rb
+    lib/fog/parser.rb
+    lib/fog/provider.rb
+    lib/fog/rackspace.rb
+    lib/fog/rackspace/bin.rb
+    lib/fog/rackspace/compute.rb
+    lib/fog/rackspace/files.rb
+    lib/fog/rackspace/models/compute/flavor.rb
+    lib/fog/rackspace/models/compute/flavors.rb
+    lib/fog/rackspace/models/compute/image.rb
+    lib/fog/rackspace/models/compute/images.rb
+    lib/fog/rackspace/models/compute/server.rb
+    lib/fog/rackspace/models/compute/servers.rb
+    lib/fog/rackspace/models/storage/directories.rb
+    lib/fog/rackspace/models/storage/directory.rb
+    lib/fog/rackspace/models/storage/file.rb
+    lib/fog/rackspace/models/storage/files.rb
+    lib/fog/rackspace/requests/compute/create_image.rb
+    lib/fog/rackspace/requests/compute/create_server.rb
+    lib/fog/rackspace/requests/compute/delete_image.rb
+    lib/fog/rackspace/requests/compute/delete_server.rb
+    lib/fog/rackspace/requests/compute/get_flavor_details.rb
+    lib/fog/rackspace/requests/compute/get_image_details.rb
+    lib/fog/rackspace/requests/compute/get_server_details.rb
+    lib/fog/rackspace/requests/compute/list_addresses.rb
+    lib/fog/rackspace/requests/compute/list_flavors.rb
+    lib/fog/rackspace/requests/compute/list_flavors_detail.rb
+    lib/fog/rackspace/requests/compute/list_images.rb
+    lib/fog/rackspace/requests/compute/list_images_detail.rb
+    lib/fog/rackspace/requests/compute/list_private_addresses.rb
+    lib/fog/rackspace/requests/compute/list_public_addresses.rb
+    lib/fog/rackspace/requests/compute/list_servers.rb
+    lib/fog/rackspace/requests/compute/list_servers_detail.rb
+    lib/fog/rackspace/requests/compute/reboot_server.rb
+    lib/fog/rackspace/requests/compute/update_server.rb
+    lib/fog/rackspace/requests/storage/delete_container.rb
+    lib/fog/rackspace/requests/storage/delete_object.rb
+    lib/fog/rackspace/requests/storage/get_container.rb
+    lib/fog/rackspace/requests/storage/get_containers.rb
+    lib/fog/rackspace/requests/storage/get_object.rb
+    lib/fog/rackspace/requests/storage/head_container.rb
+    lib/fog/rackspace/requests/storage/head_containers.rb
+    lib/fog/rackspace/requests/storage/head_object.rb
+    lib/fog/rackspace/requests/storage/put_container.rb
+    lib/fog/rackspace/requests/storage/put_object.rb
+    lib/fog/rackspace/servers.rb
+    lib/fog/rackspace/storage.rb
+    lib/fog/service.rb
+    lib/fog/slicehost.rb
+    lib/fog/slicehost/bin.rb
+    lib/fog/slicehost/compute.rb
+    lib/fog/slicehost/models/compute/flavor.rb
+    lib/fog/slicehost/models/compute/flavors.rb
+    lib/fog/slicehost/models/compute/image.rb
+    lib/fog/slicehost/models/compute/images.rb
+    lib/fog/slicehost/models/compute/server.rb
+    lib/fog/slicehost/models/compute/servers.rb
+    lib/fog/slicehost/parsers/compute/create_slice.rb
+    lib/fog/slicehost/parsers/compute/get_backups.rb
+    lib/fog/slicehost/parsers/compute/get_flavor.rb
+    lib/fog/slicehost/parsers/compute/get_flavors.rb
+    lib/fog/slicehost/parsers/compute/get_image.rb
+    lib/fog/slicehost/parsers/compute/get_images.rb
+    lib/fog/slicehost/parsers/compute/get_slice.rb
+    lib/fog/slicehost/parsers/compute/get_slices.rb
+    lib/fog/slicehost/requests/compute/create_slice.rb
+    lib/fog/slicehost/requests/compute/delete_slice.rb
+    lib/fog/slicehost/requests/compute/get_backups.rb
+    lib/fog/slicehost/requests/compute/get_flavor.rb
+    lib/fog/slicehost/requests/compute/get_flavors.rb
+    lib/fog/slicehost/requests/compute/get_image.rb
+    lib/fog/slicehost/requests/compute/get_images.rb
+    lib/fog/slicehost/requests/compute/get_slice.rb
+    lib/fog/slicehost/requests/compute/get_slices.rb
+    lib/fog/slicehost/requests/compute/reboot_slice.rb
+    lib/fog/ssh.rb
+    lib/fog/terremark.rb
+    lib/fog/terremark/bin.rb
+    lib/fog/terremark/ecloud.rb
+    lib/fog/terremark/models/shared/address.rb
+    lib/fog/terremark/models/shared/addresses.rb
+    lib/fog/terremark/models/shared/network.rb
+    lib/fog/terremark/models/shared/networks.rb
+    lib/fog/terremark/models/shared/server.rb
+    lib/fog/terremark/models/shared/servers.rb
+    lib/fog/terremark/models/shared/task.rb
+    lib/fog/terremark/models/shared/tasks.rb
+    lib/fog/terremark/models/shared/vdc.rb
+    lib/fog/terremark/models/shared/vdcs.rb
+    lib/fog/terremark/parser.rb
+    lib/fog/terremark/parsers/shared/get_catalog.rb
+    lib/fog/terremark/parsers/shared/get_catalog_item.rb
+    lib/fog/terremark/parsers/shared/get_internet_services.rb
+    lib/fog/terremark/parsers/shared/get_network_ips.rb
+    lib/fog/terremark/parsers/shared/get_node_services.rb
+    lib/fog/terremark/parsers/shared/get_organization.rb
+    lib/fog/terremark/parsers/shared/get_organizations.rb
+    lib/fog/terremark/parsers/shared/get_public_ips.rb
+    lib/fog/terremark/parsers/shared/get_tasks_list.rb
+    lib/fog/terremark/parsers/shared/get_vapp_template.rb
+    lib/fog/terremark/parsers/shared/get_vdc.rb
+    lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
+    lib/fog/terremark/parsers/shared/internet_service.rb
+    lib/fog/terremark/parsers/shared/network.rb
+    lib/fog/terremark/parsers/shared/node_service.rb
+    lib/fog/terremark/parsers/shared/public_ip.rb
+    lib/fog/terremark/parsers/shared/task.rb
+    lib/fog/terremark/parsers/shared/vapp.rb
+    lib/fog/terremark/requests/shared/add_internet_service.rb
+    lib/fog/terremark/requests/shared/add_node_service.rb
+    lib/fog/terremark/requests/shared/create_internet_service.rb
+    lib/fog/terremark/requests/shared/delete_internet_service.rb
+    lib/fog/terremark/requests/shared/delete_node_service.rb
+    lib/fog/terremark/requests/shared/delete_public_ip.rb
+    lib/fog/terremark/requests/shared/delete_vapp.rb
+    lib/fog/terremark/requests/shared/deploy_vapp.rb
+    lib/fog/terremark/requests/shared/get_catalog.rb
+    lib/fog/terremark/requests/shared/get_catalog_item.rb
+    lib/fog/terremark/requests/shared/get_internet_services.rb
+    lib/fog/terremark/requests/shared/get_network.rb
+    lib/fog/terremark/requests/shared/get_network_ips.rb
+    lib/fog/terremark/requests/shared/get_node_services.rb
+    lib/fog/terremark/requests/shared/get_organization.rb
+    lib/fog/terremark/requests/shared/get_organizations.rb
+    lib/fog/terremark/requests/shared/get_public_ip.rb
+    lib/fog/terremark/requests/shared/get_public_ips.rb
+    lib/fog/terremark/requests/shared/get_task.rb
+    lib/fog/terremark/requests/shared/get_tasks_list.rb
+    lib/fog/terremark/requests/shared/get_vapp.rb
+    lib/fog/terremark/requests/shared/get_vapp_template.rb
+    lib/fog/terremark/requests/shared/get_vdc.rb
+    lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
+    lib/fog/terremark/requests/shared/power_off.rb
+    lib/fog/terremark/requests/shared/power_on.rb
+    lib/fog/terremark/requests/shared/power_reset.rb
+    lib/fog/terremark/requests/shared/power_shutdown.rb
+    lib/fog/terremark/shared.rb
+    lib/fog/terremark/vcloud.rb
+    lib/fog/vcloud.rb
+    lib/fog/vcloud/bin.rb
+    lib/fog/vcloud/collection.rb
+    lib/fog/vcloud/generators.rb
+    lib/fog/vcloud/model.rb
+    lib/fog/vcloud/models/vdc.rb
+    lib/fog/vcloud/models/vdcs.rb
+    lib/fog/vcloud/requests/get_network.rb
+    lib/fog/vcloud/requests/get_organization.rb
+    lib/fog/vcloud/requests/get_vdc.rb
+    lib/fog/vcloud/requests/get_versions.rb
+    lib/fog/vcloud/requests/login.rb
+    lib/fog/vcloud/terremark/ecloud.rb
+    lib/fog/vcloud/terremark/ecloud/models/catalog.rb
+    lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb
+    lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb
+    lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb
+    lib/fog/vcloud/terremark/ecloud/models/internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/models/internet_services.rb
+    lib/fog/vcloud/terremark/ecloud/models/ip.rb
+    lib/fog/vcloud/terremark/ecloud/models/ips.rb
+    lib/fog/vcloud/terremark/ecloud/models/network.rb
+    lib/fog/vcloud/terremark/ecloud/models/networks.rb
+    lib/fog/vcloud/terremark/ecloud/models/node.rb
+    lib/fog/vcloud/terremark/ecloud/models/nodes.rb
+    lib/fog/vcloud/terremark/ecloud/models/public_ip.rb
+    lib/fog/vcloud/terremark/ecloud/models/public_ips.rb
+    lib/fog/vcloud/terremark/ecloud/models/server.rb
+    lib/fog/vcloud/terremark/ecloud/models/servers.rb
+    lib/fog/vcloud/terremark/ecloud/models/task.rb
+    lib/fog/vcloud/terremark/ecloud/models/tasks.rb
+    lib/fog/vcloud/terremark/ecloud/models/vdc.rb
+    lib/fog/vcloud/terremark/ecloud/models/vdcs.rb
+    lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/requests/add_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb
+    lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_node.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_task.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb
+    lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb
+    lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_off.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_on.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb
+    lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb
+    lib/fog/vcloud/terremark/vcloud.rb
+    lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb
+    spec/aws/models/compute/address_spec.rb
+    spec/aws/models/compute/addresses_spec.rb
+    spec/aws/models/compute/flavors_spec.rb
+    spec/aws/models/compute/key_pair_spec.rb
+    spec/aws/models/compute/key_pairs_spec.rb
+    spec/aws/models/compute/security_group_spec.rb
+    spec/aws/models/compute/security_groups_spec.rb
+    spec/aws/models/compute/server_spec.rb
+    spec/aws/models/compute/servers_spec.rb
+    spec/aws/models/compute/snapshot_spec.rb
+    spec/aws/models/compute/snapshots_spec.rb
+    spec/aws/models/compute/volume_spec.rb
+    spec/aws/models/compute/volumes_spec.rb
+    spec/aws/models/storage/directories_spec.rb
+    spec/aws/models/storage/directory_spec.rb
+    spec/aws/models/storage/file_spec.rb
+    spec/aws/models/storage/files_spec.rb
+    spec/aws/requests/compute/describe_images_spec.rb
+    spec/aws/requests/s3/copy_object_spec.rb
+    spec/aws/requests/s3/delete_bucket_spec.rb
+    spec/aws/requests/s3/delete_object_spec.rb
+    spec/aws/requests/s3/get_bucket_location_spec.rb
+    spec/aws/requests/s3/get_bucket_spec.rb
+    spec/aws/requests/s3/get_object_spec.rb
+    spec/aws/requests/s3/get_request_payment_spec.rb
+    spec/aws/requests/s3/get_service_spec.rb
+    spec/aws/requests/s3/head_object_spec.rb
+    spec/aws/requests/s3/put_bucket_spec.rb
+    spec/aws/requests/s3/put_object_spec.rb
+    spec/aws/requests/s3/put_request_payment_spec.rb
+    spec/aws/requests/simpledb/batch_put_attributes_spec.rb
+    spec/aws/requests/simpledb/create_domain_spec.rb
+    spec/aws/requests/simpledb/delete_attributes_spec.rb
+    spec/aws/requests/simpledb/delete_domain_spec.rb
+    spec/aws/requests/simpledb/domain_metadata_spec.rb
+    spec/aws/requests/simpledb/get_attributes_spec.rb
+    spec/aws/requests/simpledb/list_domains_spec.rb
+    spec/aws/requests/simpledb/put_attributes_spec.rb
+    spec/aws/requests/simpledb/select_spec.rb
+    spec/bluebox/models/compute/flavors_spec.rb
+    spec/bluebox/models/compute/server_spec.rb
+    spec/bluebox/models/compute/servers_spec.rb
+    spec/brightbox/models/flavors_spec.rb
+    spec/brightbox/models/server_spec.rb
+    spec/brightbox/models/servers_spec.rb
+    spec/compact_progress_bar_formatter.rb
+    spec/lorem.txt
+    spec/rackspace/models/compute/flavors_spec.rb
+    spec/rackspace/models/compute/server_spec.rb
+    spec/rackspace/models/compute/servers_spec.rb
+    spec/rackspace/requests/storage/delete_container_spec.rb
+    spec/rackspace/requests/storage/delete_object_spec.rb
+    spec/rackspace/requests/storage/get_container_spec.rb
+    spec/rackspace/requests/storage/get_containers_spec.rb
+    spec/rackspace/requests/storage/get_object_spec.rb
+    spec/rackspace/requests/storage/head_container_spec.rb
+    spec/rackspace/requests/storage/head_containers_spec.rb
+    spec/rackspace/requests/storage/head_object_spec.rb
+    spec/rackspace/requests/storage/put_container_spec.rb
+    spec/rackspace/requests/storage/put_object_spec.rb
+    spec/shared_examples/flavors_examples.rb
+    spec/shared_examples/server_examples.rb
+    spec/shared_examples/servers_examples.rb
+    spec/slicehost/models/compute/flavors_spec.rb
+    spec/slicehost/models/compute/server_spec.rb
+    spec/slicehost/models/compute/servers_spec.rb
+    spec/spec_helper.rb
+    spec/vcloud/bin_spec.rb
+    spec/vcloud/models/vdc_spec.rb
+    spec/vcloud/models/vdcs_spec.rb
+    spec/vcloud/requests/get_network_spec.rb
+    spec/vcloud/requests/get_organization_spec.rb
+    spec/vcloud/requests/get_vdc_spec.rb
+    spec/vcloud/requests/get_versions_spec.rb
+    spec/vcloud/requests/login_spec.rb
+    spec/vcloud/spec_helper.rb
+    spec/vcloud/terremark/ecloud/models/internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/models/internet_services_spec.rb
+    spec/vcloud/terremark/ecloud/models/ip_spec.rb
+    spec/vcloud/terremark/ecloud/models/ips_spec.rb
+    spec/vcloud/terremark/ecloud/models/network_spec.rb
+    spec/vcloud/terremark/ecloud/models/networks_spec.rb
+    spec/vcloud/terremark/ecloud/models/node_spec.rb
+    spec/vcloud/terremark/ecloud/models/nodes_spec.rb
+    spec/vcloud/terremark/ecloud/models/public_ip_spec.rb
+    spec/vcloud/terremark/ecloud/models/public_ips_spec.rb
+    spec/vcloud/terremark/ecloud/models/vdc_spec.rb
+    spec/vcloud/terremark/ecloud/models/vdcs_spec.rb
+    spec/vcloud/terremark/ecloud/requests/add_internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/requests/add_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/configure_internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/requests/configure_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/delete_internet_service_spec.rb
+    spec/vcloud/terremark/ecloud/requests/delete_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_internet_services_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_network_ip_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_network_ips_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_network_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_node_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_nodes_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_public_ip_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_public_ips_spec.rb
+    spec/vcloud/terremark/ecloud/requests/get_vdc_spec.rb
+    spec/vcloud/terremark/ecloud/requests/login_spec.rb
+    spec/vcloud/vcloud_spec.rb
+    tests/aws/helper.rb
+    tests/aws/models/storage/directory_tests.rb
+    tests/aws/requests/compute/address_tests.rb
+    tests/aws/requests/compute/availability_zone_tests.rb
+    tests/aws/requests/compute/instance_tests.rb
+    tests/aws/requests/compute/key_pair_tests.rb
+    tests/aws/requests/compute/region_tests.rb
+    tests/aws/requests/compute/security_group_tests.rb
+    tests/aws/requests/compute/snapshot_tests.rb
+    tests/aws/requests/compute/volume_tests.rb
+    tests/bluebox/helper.rb
+    tests/bluebox/requests/compute/block_tests.rb
+    tests/bluebox/requests/compute/product_tests.rb
+    tests/bluebox/requests/compute/template_tests.rb
+    tests/helper.rb
+    tests/helper_tests.rb
+    tests/helpers/model_helper.rb
+    tests/linode/helper.rb
+    tests/linode/requests/compute/datacenter_tests.rb
+    tests/linode/requests/compute/distribution_tests.rb
+    tests/linode/requests/compute/linode_tests.rb
+    tests/linode/requests/compute/linodeplans_tests.rb
+    tests/rackspace/helper.rb
+    tests/rackspace/requests/compute/address_tests.rb
+    tests/rackspace/requests/compute/flavor_tests.rb
+    tests/rackspace/requests/compute/image_tests.rb
+    tests/rackspace/requests/compute/server_tests.rb
+    tests/slicehost/helper.rb
+    tests/slicehost/requests/compute/backup_tests.rb
+    tests/slicehost/requests/compute/flavor_tests.rb
+    tests/slicehost/requests/compute/image_tests.rb
+    tests/slicehost/requests/compute/slice_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog.rb b/lib/bbcloud/vendor/fog/lib/fog.rb
new file mode 100644
index 0000000..e785a27
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog.rb
@@ -0,0 +1,98 @@
+#
+#require 'rubygems'
+require 'base64'
+require 'cgi'
+require 'digest/md5'
+require 'excon'
+require 'formatador'
+require 'json'
+require 'mime/types'
+require 'net/ssh'
+require 'nokogiri'
+require 'tempfile'
+require 'time'
+
+__DIR__ = File.dirname(__FILE__)
+
+$LOAD_PATH.unshift __DIR__ unless
+  $LOAD_PATH.include?(__DIR__) ||
+  $LOAD_PATH.include?(File.expand_path(__DIR__))
+
+require 'fog/attributes'
+require 'fog/collection'
+require 'fog/connection'
+require 'fog/deprecation'
+require 'fog/errors'
+require 'fog/hmac'
+require 'fog/model'
+require 'fog/parser'
+require 'fog/provider'
+require 'fog/service'
+require 'fog/ssh'
+
+module Fog
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.3.0'
+  end
+
+  module Mock
+    @delay = 1
+    def self.delay
+      @delay
+    end
+
+    def self.delay=(new_delay)
+      raise ArgumentError, "delay must be non-negative" unless new_delay >= 0
+      @delay = new_delay
+    end
+
+    def self.not_implemented
+      raise Fog::Errors::MockNotImplemented.new("Contributions welcome!")
+    end
+
+  end
+
+  def self.bin
+    @bin ||= false
+  end
+
+  def self.bin=(new_bin)
+    @bin = new_bin
+  end
+
+  def self.mock!
+    @mocking = true
+  end
+
+  def self.mocking?
+    !!@mocking
+  end
+
+  def self.wait_for(timeout=600, interval=1, &block)
+    duration = 0
+    start = Time.now
+    until yield || duration > timeout
+      sleep(interval)
+      duration = Time.now - start
+    end
+    if duration > timeout
+      false
+    else
+      { :duration => duration }
+    end
+  end
+
+end
+
+require 'fog/aws'
+require 'fog/bluebox'
+require 'fog/brightbox'
+require 'fog/go_grid'
+require 'fog/linode'
+require 'fog/local'
+require 'fog/new_servers'
+require 'fog/rackspace'
+require 'fog/slicehost'
+require 'fog/terremark'
+require 'fog/vcloud'
diff --git a/lib/bbcloud/vendor/fog/lib/fog/attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/attributes.rb
new file mode 100644
index 0000000..5e75bef
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/attributes.rb
@@ -0,0 +1,179 @@
+module Fog
+  module Attributes
+    module ClassMethods
+
+      def _load(marshalled)
+        new(Marshal.load(marshalled))
+      end
+
+      def aliases
+        @aliases ||= {}
+      end
+
+      def attributes
+        @attributes ||= []
+      end
+
+      def attribute(name, options = {})
+        class_eval <<-EOS, __FILE__, __LINE__
+          attr_reader :#{name}
+        EOS
+        case options[:type]
+        when :boolean
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = case new_#{name}
+              when 'true'
+                true
+              when 'false'
+                false
+              end
+            end
+          EOS
+        when :float
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = new_#{name}.to_f
+            end
+          EOS
+        when :integer
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = new_#{name}.to_i
+            end
+          EOS
+        when :string
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              @#{name} = new_#{name}.to_s
+            end
+          EOS
+        when :time
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              if new_#{name}.nil?|| new_#{name} == "" || new_#{name}.is_a?(Time)
+                @#{name} = new_#{name}
+              else
+                @#{name} = Time.parse(new_#{name})
+              end
+            end
+          EOS
+        when :array
+          class_eval <<-EOS, __FILE__, __LINE__
+          def #{name}=(new_#{name})
+            @#{name} = if new_#{name}.is_a?(Array)
+              new_#{name}
+            else
+              @#{name} = [ new_#{name} ]
+            end
+          end
+          EOS
+        else
+          if squash = options[:squash]
+            class_eval <<-EOS, __FILE__, __LINE__
+              def #{name}=(new_data)
+                if new_data.is_a?(Hash)
+                  if new_data[:#{squash}] || new_data["#{squash}"]
+                    @#{name} = new_data[:#{squash}] || new_data["#{squash}"]
+                  else
+                    @#{name} = [ new_data ]
+                  end
+                else
+                  @#{name} = new_data
+                end
+              end
+            EOS
+          else
+            class_eval <<-EOS, __FILE__, __LINE__
+              attr_writer :#{name}
+            EOS
+          end
+        end
+        @attributes ||= []
+        @attributes |= [name]
+        for new_alias in [*options[:aliases]]
+          aliases[new_alias] = name
+        end
+      end
+
+      def identity(name, options = {})
+        @identity = name
+        self.attribute(name, options)
+      end
+
+      def ignore_attributes(*args)
+        @ignored_attributes = args
+      end
+
+      def ignored_attributes
+        @ignored_attributes ||= []
+      end
+
+    end
+
+    module InstanceMethods
+
+      def _dump
+        Marshal.dump(attributes)
+      end
+
+      def attributes
+        attributes = {}
+        for attribute in self.class.attributes
+          attributes[attribute] = send("#{attribute}")
+        end
+        attributes
+      end
+
+      def identity
+        send(self.class.instance_variable_get('@identity'))
+      end
+
+      def identity=(new_identity)
+        send("#{self.class.instance_variable_get('@identity')}=", new_identity)
+      end
+
+      def merge_attributes(new_attributes = {})
+        for key, value in new_attributes
+          unless self.class.ignored_attributes.include?(key)
+            if aliased_key = self.class.aliases[key]
+              send("#{aliased_key}=", value)
+            else
+              send("#{key}=", value)
+            end
+          end
+        end
+        self
+      end
+
+      def new_record?
+        !identity
+      end
+
+      def requires(*args)
+        missing = []
+        for arg in [:connection] | args
+          missing << arg unless send("#{arg}")
+        end
+        unless missing.empty?
+          if missing.length == 1
+            raise(ArgumentError, "#{missing.first} is required for this operation")
+          else
+            raise(ArgumentError, "#{missing[0...-1].join(", ")} and #{missing[-1]} are required for this operation")
+          end
+        end
+      end
+
+      private
+
+      def remap_attributes(attributes, mapping)
+        for key, value in mapping
+          if attributes.key?(key)
+            attributes[value] = attributes.delete(key)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws.rb b/lib/bbcloud/vendor/fog/lib/fog/aws.rb
new file mode 100644
index 0000000..dfebe12
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws.rb
@@ -0,0 +1,200 @@
+module Fog
+  module AWS
+
+    extend Fog::Provider
+
+    service_path 'fog/aws'
+    service 'compute'
+    service 'ec2'
+    service 'elb'
+    service 's3'
+    service 'simpledb'
+    service 'storage'
+
+    def self.indexed_param(key, values)
+      params = {}
+      unless key.include?('%d')
+        key << '.%d'
+      end
+      [*values].each_with_index do |value, index|
+        params[format(key, index + 1)] = value
+      end
+      params
+    end
+
+    def self.signed_params(params, options = {})
+      params.merge!({
+        'AWSAccessKeyId'    => options[:aws_access_key_id],
+        'SignatureMethod'   => 'HmacSHA256',
+        'SignatureVersion'  => '2',
+        'Timestamp'         => Time.now.utc.strftime("%Y-%m-%dT%H:%M:%SZ"),
+        'Version'           => options[:version]
+      })
+
+      body = ''
+      for key in params.keys.sort
+        unless (value = params[key]).nil?
+          body << "#{key}=#{CGI.escape(value.to_s).gsub(/\+/, '%20')}&"
+        end
+      end
+      string_to_sign = "POST\n#{options[:host]}\n/\n" << body.chop
+      signed_string = options[:hmac].sign(string_to_sign)
+      body << "Signature=#{CGI.escape(Base64.encode64(signed_string).chomp!).gsub(/\+/, '%20')}"
+
+      body
+    end
+
+    class Mock
+
+      def self.availability_zone
+        "us-east-1" << random_selection('abcd', 1)
+      end
+
+      def self.box_usage
+        sprintf("%0.10f", rand / 100).to_f
+      end
+
+      def self.dns_name_for(ip_address)
+        "ec2-#{ip_address.gsub('.','-')}.compute-1.amazonaws.com"
+      end
+
+      def self.private_dns_name_for(ip_address)
+        "ip-#{ip_address.gsub('.','-')}.ec2.internal"
+      end
+
+      def self.etag
+        hex(32)
+      end
+
+      def self.image
+        path = []
+        (rand(3) + 2).times do
+          path << letters(rand(9) + 8)
+        end
+        {
+          "imageOwnerId"   => letters(rand(5) + 4),
+          "blockDeviceMapping" => [],
+          "productCodes"   => [],
+          "kernelId"       => kernel_id,
+          "ramdiskId"      => ramdisk_id,
+          "imageState"     => "available",
+          "imageId"        => image_id,
+          "architecture"   => "i386",
+          "isPublic"       => true,
+          "imageLocation"  => path.join('/'),
+          "imageType"      => "machine",
+          "rootDeviceType" => ["ebs","instance-store"][rand(2)],
+          "rootDeviceName" => "/dev/sda1"
+        }
+      end
+
+      def self.image_id
+        "ami-#{hex(8)}"
+      end
+
+      def self.key_fingerprint
+        fingerprint = []
+        20.times do
+          fingerprint << hex(2)
+        end
+        fingerprint.join(':')
+      end
+
+      def self.image_id
+        "ami-#{hex(8)}"
+      end
+
+      def self.instance_id
+        "i-#{hex(8)}"
+      end
+
+      def self.ip_address
+        ip = []
+        4.times do
+          ip << numbers(rand(3) + 1).to_i.to_s # remove leading 0
+        end
+        ip.join('.')
+      end
+
+      def self.kernel_id
+        "aki-#{hex(8)}"
+      end
+
+      def self.key_material
+        key_material = ['-----BEGIN RSA PRIVATE KEY-----']
+        20.times do
+          key_material << base64(76)
+        end
+        key_material << base64(67) + '='
+        key_material << '-----END RSA PRIVATE KEY-----'
+        key_material.join("\n")
+      end
+
+      def self.owner_id
+        numbers(12)
+      end
+
+      def self.ramdisk_id
+        "ari-#{hex(8)}"
+      end
+
+      def self.request_id
+        request_id = []
+        request_id << hex(8)
+        3.times do
+          request_id << hex(4)
+        end
+        request_id << hex(12)
+        request_id.join('-')
+      end
+
+      def self.reservation_id
+        "r-#{hex(8)}"
+      end
+
+      def self.snapshot_id
+        "snap-#{hex(8)}"
+      end
+
+      def self.volume_id
+        "vol-#{hex(8)}"
+      end
+
+      private
+
+      def self.random_selection(characters, length)
+        selection = ''
+        length.times do
+          position = rand(characters.length)
+          selection << characters[position..position]
+        end
+        selection
+      end
+
+      def self.letters(length)
+        random_selection(
+          'abcdefghijklmnopqrstuvwxyz',
+          length
+        )
+      end
+
+      def self.numbers(length)
+        max = ('9' * length).to_i
+        rand(max).to_s
+      end
+
+      def self.hex(length)
+        max = ('f' * length).to_i(16)
+        rand(max).to_s(16)
+      end
+
+      def self.base64(length)
+        random_selection(
+          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
+          length
+        )
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/bin.rb
new file mode 100644
index 0000000..75badf7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/bin.rb
@@ -0,0 +1,39 @@
+class AWS < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::AWS::Compute.new
+        when :ec2
+          location = caller.first
+          warning = "[yellow][WARN] AWS[:ec2] is deprecated, use AWS[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::AWS::Compute.new
+        when :elb
+          Fog::AWS::ELB.new
+        when :eu_storage
+          Fog::AWS::Storage.new(:region => 'eu-west-1')
+        when :sdb
+          Fog::AWS::SimpleDB.new
+        when :s3
+          location = caller.first
+          warning = "[yellow][WARN] AWS[:s3] is deprecated, use AWS[:storage] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::AWS::Storage.new
+        when :storage
+          Fog::AWS::Storage.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute, :elb, :sdb, :storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/compute.rb
new file mode 100644
index 0000000..1d145ae
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/compute.rb
@@ -0,0 +1,220 @@
+module Fog
+  module AWS
+    class Compute < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+
+      model_path 'fog/aws/models/compute'
+      model       :address
+      collection  :addresses
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :key_pair
+      collection  :key_pairs
+      model       :security_group
+      collection  :security_groups
+      model       :server
+      collection  :servers
+      model       :snapshot
+      collection  :snapshots
+      model       :volume
+      collection  :volumes
+
+      require 'fog/aws/parsers/compute/basic'
+
+      request_path 'fog/aws/requests/compute'
+      request :allocate_address
+      request :associate_address
+      request :attach_volume
+      request :authorize_security_group_ingress
+      request :create_key_pair
+      request :create_security_group
+      request :create_snapshot
+      request :create_image
+      request :create_volume
+      request :delete_key_pair
+      request :delete_security_group
+      request :delete_snapshot
+      request :delete_volume
+      request :deregister_image
+      request :describe_addresses
+      request :describe_availability_zones
+      request :describe_images
+      request :describe_instances
+      request :describe_reserved_instances
+      request :describe_key_pairs
+      request :describe_regions
+      request :describe_security_groups
+      request :describe_snapshots
+      request :describe_volumes
+      request :detach_volume
+      request :disassociate_address
+      request :get_console_output
+      request :import_key_pair
+      request :modify_image_attributes
+      request :modify_snapshot_attribute
+      request :reboot_instances
+      request :release_address
+      request :register_image
+      request :revoke_security_group_ingress
+      request :run_instances
+      request :terminate_instances
+      request :start_instances
+      request :stop_instances
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            owner_id = Fog::AWS::Mock.owner_id
+            hash[key] = {
+              :deleted_at => {},
+              :addresses  => {},
+              :instances  => {},
+              :key_pairs  => {},
+              :limits     => { :addresses => 5 },
+              :owner_id   => owner_id,
+              :security_groups => {
+                'default' => {
+                  'groupDescription'  => 'default group',
+                  'groupName'         => 'default',
+                  'ipPermissions'     => [
+                    {
+                      'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                      'fromPort'    => -1,
+                      'toPort'      => -1,
+                      'ipProtocol'  => 'icmp',
+                      'ipRanges'    => []
+                    },
+                    {
+                      'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                      'fromPort'    => 0,
+                      'toPort'      => 65535,
+                      'ipProtocol'  => 'tcp',
+                      'ipRanges'    => []
+                    },
+                    {
+                      'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                      'fromPort'    => 0,
+                      'toPort'      => 65535,
+                      'ipProtocol'  => 'udp',
+                      'ipRanges'    => []
+                    }
+                  ],
+                  'ownerId'           => owner_id
+                }
+              },
+              :snapshots => {},
+              :volumes => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @data = self.class.data[@aws_access_key_id]
+          @owner_id = @data[:owner_id]
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to EC2
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and 
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   sdb = SimpleDB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1']
+        #
+        # ==== Returns
+        # * EC2 object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+            when 'ap-southeast-1'
+              'ec2.ap-southeast-1.amazonaws.com'
+            when 'eu-west-1'
+              'ec2.eu-west-1.amazonaws.com'
+            when 'us-east-1'
+              'ec2.us-east-1.amazonaws.com'
+            when 'us-west-1'
+              'ec2.us-west-1.amazonaws.com'
+            else
+              raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+            end
+          @port   = options[:port]      || 443
+          @scheme = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :version            => '2010-08-31'
+            }
+          )
+
+          begin
+            response = @connection.request({
+              :body       => body,
+              :expects    => 200,
+              :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+              :idempotent => idempotent,
+              :host       => @host,
+              :method     => 'POST',
+              :parser     => parser
+            })
+          rescue Excon::Errors::Error => error
+            if match = error.message.match(/<Code>(.*)<\/Code><Message>(.*)<\/Message>/)
+              raise case match[1].split('.').last
+              when 'NotFound'
+                Fog::AWS::Compute::NotFound.slurp(error, match[2])
+              else
+                Fog::AWS::Compute::Error.slurp(error, "#{match[1]} => #{match[2]}")
+              end
+            else
+              raise error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/ec2.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/ec2.rb
new file mode 100644
index 0000000..ba0f913
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/ec2.rb
@@ -0,0 +1,15 @@
+module Fog
+  module AWS
+    class EC2
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::AWS::EC2#new is deprecated, use Fog::AWS::Compute#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::AWS::Compute.new(attributes)
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/elb.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/elb.rb
new file mode 100644
index 0000000..05610bc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/elb.rb
@@ -0,0 +1,103 @@
+module Fog
+  module AWS
+    class ELB < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+
+      request_path 'fog/aws/requests/elb'
+      request :create_load_balancer
+      request :delete_load_balancer
+      request :deregister_instances_from_load_balancer
+      request :describe_instance_health
+      request :describe_load_balancers
+      request :disable_availability_zones_for_load_balancer
+      request :enable_availability_zones_for_load_balancer
+      request :register_instances_with_load_balancer
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to ELB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   elb = ELB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1'i, 'ap-southeast-1']
+        #
+        # ==== Returns
+        # * ELB object with connection to AWS.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-southeast-1'
+            'elasticloadbalancing.ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            'elasticloadbalancing.eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            'elasticloadbalancing.us-east-1.amazonaws.com'
+          when 'us-west-1'
+            'elasticloadbalancing.us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :version            => '2009-11-25'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+            :idempotent => idempotent,
+            :host       => @host,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/address.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/address.rb
new file mode 100644
index 0000000..341663b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/address.rb
@@ -0,0 +1,67 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Address < Fog::Model
+
+        identity  :public_ip, :aliases => 'publicIp'
+
+        attribute :server_id, :aliases => 'instanceId'
+
+        def initialize(attributes = {})
+          # assign server first to prevent race condition with new_record?
+          self.server = attributes.delete(:server)
+          super
+        end
+
+        def destroy
+          requires :public_ip
+
+          connection.release_address(@public_ip)
+          true
+        end
+
+        def server=(new_server)
+          if new_server
+            associate(new_server)
+          else
+            disassociate
+          end
+        end
+
+        def save
+          data = connection.allocate_address
+          @public_ip = data.body['publicIp']
+          if @server
+            self.server = @server
+          end
+          true
+        end
+
+        private
+
+        def associate(new_server)
+          if new_record?
+            @server = new_server
+          else
+            @server = nil
+            @server_id = new_server.id
+            connection.associate_address(@server_id, @public_ip)
+          end
+        end
+
+        def disassociate
+          @server = nil
+          @server_id = nil
+          unless new_record?
+            connection.disassociate_address(@public_ip)
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/addresses.rb
new file mode 100644
index 0000000..366fe3b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/addresses.rb
@@ -0,0 +1,54 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/address'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Addresses < Fog::Collection
+
+        attribute :public_ip
+        attribute :server
+
+        model Fog::AWS::Compute::Address
+
+        def initialize(attributes)
+          @public_ip ||= []
+          super
+        end
+
+        def all(public_ip = @public_ip)
+          @public_ip = public_ip
+          data = connection.describe_addresses(public_ip).body
+          load(
+            data['addressesSet'].map do |address|
+              address.reject {|key, value| value.nil? || value.empty? }
+            end
+          )
+          if server
+            self.replace(self.select {|address| address.server_id == server.id})
+          end
+          self
+        end
+
+        def get(public_ip)
+          if public_ip
+            all(public_ip).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :server => server }.merge!(attributes))
+          else
+            super(attributes)
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/flavor.rb
new file mode 100644
index 0000000..ef40b6d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/flavor.rb
@@ -0,0 +1,21 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :bits
+        attribute :cores
+        attribute :disk
+        attribute :name
+        attribute :ram
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/flavors.rb
new file mode 100644
index 0000000..2bbe3dc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/flavors.rb
@@ -0,0 +1,39 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/flavor'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::AWS::Compute::Flavor
+
+        def all
+          data = [
+            { :bits => 0,  :cores => 2,   :disk => 0,    :id => 't1.micro',   :name => 'Micro Instance',       :ram => 613},
+
+            { :bits => 32, :cores => 1,   :disk => 160,  :id => 'm1.small',   :name => 'Small Instance',       :ram => 1740.8},
+            { :bits => 64, :cores => 4,   :disk => 850,  :id => 'm1.large',   :name => 'Large Instance',       :ram => 7680},
+            { :bits => 64, :cores => 8,   :disk => 1690, :id => 'm1.xlarge',  :name => 'Extra Large Instance', :ram => 15360},
+
+            { :bits => 32, :cores =>  5,  :disk => 350,  :id => 'c1.medium',  :name => 'High-CPU Medium',      :ram => 1740.8},
+            { :bits => 64, :cores => 20,  :disk => 1690, :id => 'c1.xlarge',  :name => 'High-CPU Extra Large', :ram => 7168},
+
+            { :bits => 64, :cores => 6.5, :disk => 420,  :id => 'm2.xlarge',  :name => 'High-Memory Extra Large',           :ram => 17510.4},
+            { :bits => 64, :cores =>  13, :disk => 850,  :id => 'm2.2xlarge', :name => 'High Memory Double Extra Large',    :ram => 35020.8},
+            { :bits => 64, :cores =>  26, :disk => 1690, :id => 'm2.4xlarge', :name => 'High Memory Quadruple Extra Large', :ram => 70041.6},
+          ]
+          load(data)
+          self
+        end
+
+        def get(flavor_id)
+          all.detect {|flavor| flavor.id == flavor_id}
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/image.rb
new file mode 100644
index 0000000..a141745
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/image.rb
@@ -0,0 +1,44 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id,                     :aliases => 'imageId'
+
+        attribute :architecture
+        attribute :block_device_mapping,  :aliases => 'blockDeviceMapping'
+        attribute :location,              :aliases => 'imageLocation'
+        attribute :owner_id,              :aliases => 'imageOwnerId'
+        attribute :state,                 :aliases => 'imageState'
+        attribute :type,                  :aliases => 'imageType'
+        attribute :is_public,             :aliases => 'isPublic'
+        attribute :kernel_id,             :aliases => 'kernelId'
+        attribute :platform
+        attribute :product_codes,         :aliases => 'productCodes'
+        attribute :ramdisk_id,            :aliases => 'ramdiskId'
+        attribute :root_device_type,      :aliases => 'rootDeviceType'
+        attribute :root_device_name,      :aliases => 'rootDeviceName'
+
+        def deregister(delete_snapshot = false)
+          connection.deregister_image(@id)
+
+          if(delete_snapshot && @root_device_type=="ebs")
+            @block_device_mapping.each do |block_device|
+              next if block_device["deviceName"] != @root_device_name
+              snapshot_id = block_device["snapshotId"]
+              snapshot = @connection.snapshots.get(snapshot_id)
+              return snapshot.destroy
+            end
+          end
+
+          return true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/images.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/images.rb
new file mode 100644
index 0000000..6bb0838
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/images.rb
@@ -0,0 +1,36 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/image'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Images < Fog::Collection
+
+        attribute :image_id
+
+        model Fog::AWS::Compute::Image
+
+        def initialize(attributes)
+          @image_id ||= []
+          super
+        end
+
+        def all(image_id = @image_id)
+          @image_id = image_id
+          data = connection.describe_images('ImageId' => image_id).body
+          load(data['imagesSet'])
+        end
+
+        def get(image_id)
+          if image_id
+            all(image_id).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/key_pair.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/key_pair.rb
new file mode 100644
index 0000000..b5704e4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/key_pair.rb
@@ -0,0 +1,44 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class KeyPair < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:material, :private_key)
+
+        identity  :name,        :aliases => 'keyName'
+
+        attribute :fingerprint, :aliases => 'keyFingerprint'
+        attribute :private_key, :aliases => 'keyMaterial'
+
+        attr_accessor :public_key
+
+        def destroy
+          requires :name
+
+          connection.delete_key_pair(@name)
+          true
+        end
+
+        def save
+          requires :name
+
+          data = if public_key
+            connection.import_key_pair(name, public_key).body
+          else
+            connection.create_key_pair(name).body
+          end
+          new_attributes = data.reject {|key,value| !['keyFingerprint', 'keyMaterial', 'keyName'].include?(key)}
+          merge_attributes(new_attributes)
+          true
+        end
+
+        private
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/key_pairs.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/key_pairs.rb
new file mode 100644
index 0000000..dc9b7c4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/key_pairs.rb
@@ -0,0 +1,37 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/key_pair'
+
+module Fog
+  module AWS
+    class Compute
+
+      class KeyPairs < Fog::Collection
+
+        attribute :key_name
+
+        model Fog::AWS::Compute::KeyPair
+
+        def initialize(attributes)
+          @key_name ||= []
+          super
+        end
+
+        def all(key_name = @key_name)
+          @key_name = key_name
+          data = connection.describe_key_pairs(key_name).body
+          load(data['keySet'])
+        end
+
+        def get(key_name)
+          if key_name
+            all(key_name).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/security_group.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/security_group.rb
new file mode 100644
index 0000000..03c358a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/security_group.rb
@@ -0,0 +1,77 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class SecurityGroup < Fog::Model
+
+        identity  :name,            :aliases => 'groupName'
+
+        attribute :description,     :aliases => 'groupDescription'
+        attribute :ip_permissions,  :aliases => 'ipPermissions'
+        attribute :owner_id,        :aliases => 'ownerId'
+
+        def authorize_group_and_owner(group, owner)
+          requires :name
+
+          connection.authorize_security_group_ingress(
+            'GroupName'                   => @name,
+            'SourceSecurityGroupName'     => group,
+            'SourceSecurityGroupOwnerId'  => owner
+          )
+        end
+
+        def authorize_port_range(range, options = {})
+          requires :name
+
+          connection.authorize_security_group_ingress(
+            'CidrIp'      => options[:cidr_ip] || '0.0.0.0/0',
+            'FromPort'    => range.min,
+            'GroupName'   => @name,
+            'ToPort'      => range.max,
+            'IpProtocol'  => options[:ip_protocol] || 'tcp'
+          )
+        end
+
+        def destroy
+          requires :name
+
+          connection.delete_security_group(@name)
+          true
+        end
+
+        def revoke_group_and_owner(group, owner)
+          requires :name
+
+          connection.revoke_security_group_ingress(
+            'GroupName'                   => @name,
+            'SourceSecurityGroupName'     => group,
+            'SourceSecurityGroupOwnerId'  => owner
+          )
+        end
+
+        def revoke_port_range(range, options = {})
+          requires :name
+
+          connection.revoke_security_group_ingress(
+            'CidrIp'      => options[:cidr_ip] || '0.0.0.0/0',
+            'FromPort'    => range.min,
+            'GroupName'   => @name,
+            'ToPort'      => range.max,
+            'IpProtocol'  => options[:ip_protocol] || 'tcp'
+          )
+        end
+
+        def save
+          requires :description, :name
+
+          data = connection.create_security_group(@name, @description).body
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/security_groups.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/security_groups.rb
new file mode 100644
index 0000000..073e8c9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/security_groups.rb
@@ -0,0 +1,37 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/security_group'
+
+module Fog
+  module AWS
+    class Compute
+
+      class SecurityGroups < Fog::Collection
+
+        attribute :group_name
+
+        model Fog::AWS::Compute::SecurityGroup
+
+        def initialize(attributes)
+          @group_name ||= []
+          super
+        end
+
+        def all(group_name = @group_name)
+          @group_name = group_name
+          data = connection.describe_security_groups(group_name).body
+          load(data['securityGroupInfo'])
+        end
+
+        def get(group_name)
+          if group_name
+            all(group_name).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/server.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/server.rb
new file mode 100644
index 0000000..7b0d89f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/server.rb
@@ -0,0 +1,212 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Server < Fog::Model
+
+        identity  :id,                    :aliases => 'instanceId'
+
+        attr_accessor :architecture
+        attribute :ami_launch_index,      :aliases => 'amiLaunchIndex'
+        attribute :availability_zone,     :aliases => 'availabilityZone'
+        attribute :block_device_mapping,  :aliases => 'blockDeviceMapping'
+        attribute :dns_name,              :aliases => 'dnsName'
+        attribute :groups
+        attribute :flavor_id,             :aliases => 'instanceType'
+        attribute :image_id,              :aliases => 'imageId'
+        attribute :ip_address,            :aliases => 'ipAddress'
+        attribute :kernel_id,             :aliases => 'kernelId'
+        attribute :key_name,              :aliases => 'keyName'
+        attribute :created_at,            :aliases => 'launchTime'
+        attribute :monitoring
+        attribute :product_codes,         :aliases => 'productCodes'
+        attribute :private_dns_name,      :aliases => 'privateDnsName'
+        attribute :private_ip_address,    :aliases => 'privateIpAddress'
+        attribute :ramdisk_id,            :aliases => 'ramdiskId'
+        attribute :reason
+        attribute :root_device_name,      :aliases => 'rootDeviceName'
+        attribute :root_device_type,      :aliases => 'rootDeviceType'
+        attribute :state,                 :aliases => 'instanceState'
+        attribute :subnet_id,             :aliases => 'subnetId'
+        attribute :user_data
+
+        attr_accessor :password, :username
+        attr_writer   :private_key, :private_key_path, :public_key, :public_key_path
+
+        def initialize(attributes={})
+          @groups ||= ["default"] unless attributes[:subnet_id]
+          @flavor_id ||= 'm1.small'
+          super
+        end
+
+        def addresses
+          requires :id
+
+          connection.addresses(:server => self)
+        end
+
+        def console_output
+          requires :id
+
+          connection.get_console_output(@id)
+        end
+
+        def destroy
+          requires :id
+
+          connection.terminate_instances(@id)
+          true
+        end
+
+        def flavor_id
+          @flavor && @flavor.id || @flavor_id
+        end
+
+        def flavor=(new_flavor)
+          @flavor = new_flavor
+        end
+
+        def flavor
+          @flavor ||= connection.flavors.all.detect {|flavor| flavor.id == @flavor_id}
+        end
+
+        def key_pair
+          requires :key_name
+
+          connection.keypairs.all(@key_name).first
+        end
+
+        def key_pair=(new_keypair)
+          @key_name = new_keypair && new_keypair.name
+        end
+
+        def monitoring=(new_monitoring)
+          if new_monitoring.is_a?(Hash)
+            @monitoring = new_monitoring['state']
+          else
+            @monitoring = new_monitoring
+          end
+        end
+
+        def placement=(new_placement)
+          if new_placement.is_a?(Hash)
+            @availability_zone = new_placement['availabilityZone']
+          else
+            @availability_zone = new_placement
+          end
+        end
+
+        def private_key_path
+          File.expand_path(@private_key_path ||= Fog.credentials[:private_key_path])
+        end
+
+        def private_key
+          @private_key ||= File.read(private_key_path)
+        end
+
+        def public_key_path
+          File.expand_path(@public_key_path ||= Fog.credentials[:public_key_path])
+        end
+
+        def public_key
+          @public_key ||= File.read(public_key_path)
+        end
+        def ready?
+          @state == 'running'
+        end
+
+        def reboot
+          requires :id
+          connection.reboot_instances(@id)
+          true
+        end
+
+        def save
+          requires :image_id
+
+          options = {
+            'BlockDeviceMapping'          => block_device_mapping,
+            'InstanceType'                => flavor_id,
+            'KernelId'                    => kernel_id,
+            'KeyName'                     => key_name,
+            'Monitoring.Enabled'          => monitoring,
+            'Placement.AvailabilityZone'  => availability_zone,
+            'RamdiskId'                   => ramdisk_id,
+            'SecurityGroup'               => groups,
+            'SubnetId'                    => subnet_id,
+            'UserData'                    => user_data
+          }
+
+          # If subnet is defined we are working on a virtual private cloud.
+          # subnet & security group cannot co-exist. I wish VPC just ignored
+          # the security group parameter instead, it would be much easier!
+          if subnet_id
+            options.delete('SecurityGroup')
+          else
+            options.delete('SubnetId')
+          end
+
+          data = connection.run_instances(image_id, 1, 1, options)
+          merge_attributes(data.body['instancesSet'].first)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :identity, :ip_address, :public_key, :username
+          sleep(10) # takes a bit before EC2 instances will play nice
+          Fog::SSH.new(ip_address, username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ])
+        rescue Errno::ECONNREFUSED => e
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :identity, :ip_address, :private_key, :username
+          @ssh ||= Fog::SSH.new(ip_address, username, :key_data => [private_key])
+          @ssh.run(commands)
+        end
+
+        def start
+          requires :id
+          connection.start_instances(@id)
+          true
+        end
+
+        def stop
+          requires :id
+          connection.stop_instances(@id)
+          true
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        def volumes
+          requires :id
+
+          connection.volumes(:server => self)
+        end
+
+        private
+
+        def state=(new_state)
+          if new_state.is_a?(Hash)
+            @state = new_state['name']
+          else
+            @state = new_state
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/servers.rb
new file mode 100644
index 0000000..f1bfca3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/servers.rb
@@ -0,0 +1,72 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/server'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Servers < Fog::Collection
+
+        attribute :server_id
+
+        model Fog::AWS::Compute::Server
+
+        def initialize(attributes)
+          @server_id ||= []
+          super
+        end
+
+        def all(server_id = @server_id)
+          @server_id = server_id
+          data = connection.describe_instances(server_id).body
+          load(
+            data['reservationSet'].map do |reservation|
+              reservation['instancesSet'].map do |instance|
+                instance.merge(:groups => reservation['groupSet'])
+              end
+            end.flatten
+          )
+        end
+
+        def bootstrap(new_attributes = {})
+          server = connection.servers.new(new_attributes)
+
+          # first or create fog_#{credential} keypair
+          unless server.key_pair = connection.key_pairs.get("fog_#{Fog.credential}")
+            server.key_pair = connection.key_pairs.create(
+              :name => "fog_#{Fog.credential}",
+              :public_key => server.public_key
+            )
+          end
+
+          # make sure port 22 is open in the first security group
+          security_group = connection.security_groups.get(server.groups.first)
+          ip_permission = security_group.ip_permissions.detect do |ip_permission|
+            ip_permission['ipRanges'].first && ip_permission['ipRanges'].first['cidrIp'] == '0.0.0.0/0' &&
+            ip_permission['fromPort'] == 22 &&
+            ip_permission['ipProtocol'] == 'tcp' &&
+            ip_permission['toPort'] == 22
+          end
+          unless ip_permission
+            security_group.authorize_port_range(22..22)
+          end
+
+          server.save
+          server.wait_for { ready? }
+          server.setup(:key_data => [server.private_key])
+          server
+        end
+
+        def get(server_id)
+          if server_id
+            all(server_id).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/snapshot.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/snapshot.rb
new file mode 100644
index 0000000..8194312
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/snapshot.rb
@@ -0,0 +1,57 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Snapshot < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:status, :state)
+
+        identity  :id,          :aliases => 'snapshotId'
+
+        attribute :description
+        attribute :progress
+        attribute :created_at,  :aliases => 'startTime'
+        attribute :owner_id,    :aliases => 'ownerId'
+        attribute :state,       :aliases => 'status'
+        attribute :volume_id,   :aliases => 'volumeId'
+        attribute :volume_size, :aliases => 'volumeSize'
+
+        def destroy
+          requires :id
+
+          connection.delete_snapshot(@id)
+          true
+        end
+
+        def ready?
+          state == 'completed'
+        end
+
+        def save
+          requires :volume_id
+
+          data = connection.create_snapshot(@volume_id, @description).body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          true
+        end
+
+        def volume
+          requires :id
+
+          connection.describe_volumes(@volume_id)
+        end
+
+        private
+
+        def volume=(new_volume)
+          @volume_id = new_volume.volume_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/snapshots.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/snapshots.rb
new file mode 100644
index 0000000..93f1379
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/snapshots.rb
@@ -0,0 +1,57 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/snapshot'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Snapshots < Fog::Collection
+
+        attribute :owner,         :aliases => 'Owner'
+        attribute :restorable_by, :aliases => 'RestorableBy'
+        attribute :snapshot_id
+        attribute :volume
+
+        model Fog::AWS::Compute::Snapshot
+
+        def initialize(attributes)
+          @snapshot_id ||= []
+          super
+        end
+
+        def all(snapshot_id = @snapshot_id, options = {})
+          options = {
+            'Owner' => @owner || 'self',
+            'RestorableBy' => @restorable_by
+          }
+          options = options.reject {|key,value| value.nil? || value.to_s.empty?}
+          merge_attributes(options)
+          data = connection.describe_snapshots(snapshot_id).body
+          load(data['snapshotSet'])
+          if volume
+            self.replace(self.select {|snapshot| snapshot.volume_id == volume.id})
+          end
+          self
+        end
+
+        def get(snapshot_id)
+          if snapshot_id
+            all(snapshot_id).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          if volume
+            super({ 'volumeId' => volume.id }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/volume.rb
new file mode 100644
index 0000000..4189f36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/volume.rb
@@ -0,0 +1,97 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Volume < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:status, :state)
+
+        identity  :id,                :aliases => 'volumeId'
+
+        attribute :attached_at,       :aliases => 'attachTime'
+        attribute :availability_zone, :aliases => 'availabilityZone'
+        attribute :created_at,        :aliases => 'createTime'
+        attribute :device
+        attribute :server_id,         :aliases => 'instanceId'
+        attribute :size
+        attribute :snapshot_id,       :aliases => 'snapshotId'
+        attribute :state,             :aliases => 'status'
+
+        def initialize(attributes = {})
+          # assign server first to prevent race condition with new_record?
+          self.server = attributes.delete(:server)
+          super
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_volume(@id)
+          true
+        end
+
+        def ready?
+          state == 'available'
+        end
+
+        def server=(new_server)
+          if new_server
+            attach(new_server)
+          else
+            detach
+          end
+        end
+
+        def save
+          requires :availability_zone, :size
+
+          data = connection.create_volume(@availability_zone, @size, @snapshot_id).body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          if @server
+            self.server = @server
+          end
+          true
+        end
+
+        def snapshots
+          requires :id
+
+          connection.snapshots(:volume => self)
+        end
+
+        private
+
+        def attachmentSet=(new_attachment_set)
+          merge_attributes(new_attachment_set.first || {})
+        end
+
+        def attach(new_server)
+          if new_record?
+            @server = new_server
+            @availability_zone = new_server.availability_zone
+          elsif new_server
+            requires :device
+            @server = nil
+            @server_id = new_server.id
+            connection.attach_volume(@server_id, @id, @device)
+            reload
+          end
+        end
+
+        def detach
+          @server = nil
+          @server_id = nil
+          unless new_record?
+            connection.detach_volume(@id)
+            reload
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/volumes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/volumes.rb
new file mode 100644
index 0000000..2c01f28
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/compute/volumes.rb
@@ -0,0 +1,50 @@
+require 'fog/collection'
+require 'fog/aws/models/compute/volume'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Volumes < Fog::Collection
+
+        attribute :volume_id
+        attribute :server
+
+        model Fog::AWS::Compute::Volume
+
+        def initialize(attributes)
+          @volume_id ||= []
+          super
+        end
+
+        def all(volume_id = @volume_id)
+          @volume_id = volume_id
+          data = connection.describe_volumes(volume_id).body
+          load(data['volumeSet'])
+          if server
+            self.replace(self.select {|volume| volume.server_id == server.id})
+          end
+          self
+        end
+
+        def get(volume_id)
+          if volume_id
+            all(volume_id).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :server => server }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/directories.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/directories.rb
new file mode 100644
index 0000000..316c853
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/directories.rb
@@ -0,0 +1,43 @@
+require 'fog/collection'
+require 'fog/aws/models/storage/directory'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::AWS::Storage::Directory
+
+        def all
+          data = connection.get_service.body['Buckets']
+          load(data)
+        end
+
+        def get(key, options = {})
+          remap_attributes(options, {
+            :delimiter  => 'delimiter',
+            :marker     => 'marker',
+            :max_keys   => 'max-keys',
+            :prefix     => 'prefix'
+          })
+          data = connection.get_bucket(key, options).body
+          directory = new(:key => data['Name'])
+          options = {}
+          for k, v in data
+            if ['Delimiter', 'IsTruncated', 'Marker', 'MaxKeys', 'Prefix'].include?(k)
+              options[k] = v
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.load(data['Contents'])
+          directory
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/directory.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/directory.rb
new file mode 100644
index 0000000..644b7e2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/directory.rb
@@ -0,0 +1,70 @@
+require 'fog/model'
+require 'fog/aws/models/storage/files'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key,           :aliases => ['Name', 'name']
+
+        attribute :creation_date, :aliases => 'CreationDate'
+
+        def destroy
+          requires :key
+          connection.delete_bucket(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def location
+          requires :key
+          data = connection.get_bucket_location(key)
+          data.body['LocationConstraint']
+        end
+
+        def location=(new_location)
+          @location = new_location
+        end
+
+        def files
+          @files ||= begin
+            Fog::AWS::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def payer
+          requires :key
+          data = connection.get_request_payment(key)
+          data.body['Payer']
+        end
+
+        def payer=(new_payer)
+          requires :key
+          connection.put_request_payment(key, new_payer)
+          @payer = new_payer
+        end
+
+        def save
+          requires :key
+          options = {}
+          if @location
+            options['LocationConstraint'] = @location
+          end
+          connection.put_bucket(key, options)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/file.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/file.rb
new file mode 100644
index 0000000..943c4ef
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/file.rb
@@ -0,0 +1,95 @@
+require 'fog/model'
+
+module Fog
+  module AWS
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attr_accessor :body
+        attribute :content_length,  :aliases => 'Content-Length'
+        attribute :content_type,    :aliases => 'Content-Type'
+        attribute :etag,            :aliases => ['Etag', 'ETag']
+        attribute :last_modified,   :aliases => ['Last-Modified', 'LastModified']
+        attribute :owner,           :aliases => 'Owner'
+        attribute :size,            :aliases => 'Size'
+        attribute :storage_class,   :aliases => 'StorageClass'
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def body
+          @body ||= if last_modified && (file = collection.get(identity))
+            file.body
+          else
+            ''
+          end
+        end
+
+        def directory
+          @directory
+        end
+
+        def copy(target_directory_key, target_file_key)
+          requires :directory, :key
+          data = connection.copy_object(directory.key, @key, target_directory_key, target_file_key).body
+          target_directory = connection.directories.new(:key => target_directory_key)
+          target_file = target_directory.files.new(attributes.merge!(:key => target_file_key))
+          copy_data = {}
+          for key, value in data
+            if ['ETag', 'LastModified'].include?(key)
+              copy_data[key] = value
+            end
+          end
+          target_file.merge_attributes(copy_data)
+          target_file
+        end
+
+        def destroy
+          requires :directory, :key
+          connection.delete_object(directory.key, @key)
+          true
+        end
+
+        def owner=(new_owner)
+          if new_owner
+            @owner = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          if @acl
+            options['x-amz-acl'] = @acl
+          end
+          data = connection.put_object(directory.key, @key, @body, options)
+          @etag = data.headers['ETag']
+          true
+        end
+
+        def url(expires)
+          requires :key
+          collection.get_url(key, expires)
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/files.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/files.rb
new file mode 100644
index 0000000..f4b1c06
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/models/storage/files.rb
@@ -0,0 +1,94 @@
+require 'fog/collection'
+require 'fog/aws/models/storage/file'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :delimiter,     :aliases => 'Delimiter'
+        attribute :directory
+        attribute :is_truncated,  :aliases => 'IsTruncated'
+        attribute :marker,        :aliases => 'Marker'
+        attribute :max_keys,      :aliases => ['MaxKeys', 'max-keys']
+        attribute :prefix,        :aliases => 'Prefix'
+
+        model Fog::AWS::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'delimiter'   => @delimiter,
+            'marker'      => @marker,
+            'max-keys'    => @max_keys,
+            'prefix'      => @prefix
+          }.merge!(options)
+          options = options.reject {|key,value| value.nil? || value.to_s.empty?}
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            merge_attributes(parent.files.attributes)
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(key, options = {}, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, options, &block)
+          file_data = {
+            :body => data.body,
+            :key  => key
+          }
+          for key, value in data.headers
+            if ['Content-Length', 'Content-Type', 'ETag', 'Last-Modified'].include?(key)
+              file_data[key] = value
+            end
+          end
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key, options)
+          file_data = {
+            :key => key
+          }
+          for key, value in data.headers
+            if ['Content-Length', 'Content-Type', 'ETag', 'Last-Modified'].include?(key)
+              file_data[key] = value
+            end
+          end
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/allocate_address.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/allocate_address.rb
new file mode 100644
index 0000000..e655c90
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/allocate_address.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class AllocateAddress < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'publicIp', 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/attach_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/attach_volume.rb
new file mode 100644
index 0000000..4bb8150
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/attach_volume.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class AttachVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'attachTime'
+              @response[name] = Time.parse(@value)
+            when 'device', 'instanceId', 'requestId', 'status', 'volumeId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/basic.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/basic.rb
new file mode 100644
index 0000000..f591d96
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/basic.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class Basic < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'requestId'
+              @response[name] = @value
+            when 'return'
+              if @value == 'true'
+                @response[name] = true
+              else
+                @response[name] = false
+              end
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_image.rb
new file mode 100644
index 0000000..57ee677
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId', 'name', 'description', 'noReboot', 'imageId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_key_pair.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_key_pair.rb
new file mode 100644
index 0000000..9fc8bd5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_key_pair.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateKeyPair < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'keyFingerprint', 'keyMaterial', 'keyName', 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_snapshot.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_snapshot.rb
new file mode 100644
index 0000000..e506a39
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_snapshot.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateSnapshot < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'description', 'ownerId', 'progress', 'snapshotId', 'status', 'volumeId'
+              @response[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            when 'startTime'
+              @response[name] = Time.parse(@value)
+            when 'volumeSize'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_volume.rb
new file mode 100644
index 0000000..8b4263d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/create_volume.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'requestId', 'snapshotId', 'status', 'volumeId'
+              @response[name] = @value
+            when 'createTime'
+              @response[name] = Time.parse(@value)
+            when 'size'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/deregister_image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/deregister_image.rb
new file mode 100644
index 0000000..697c124
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/deregister_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DeregisterImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'return', 'requestId', 'imageId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_addresses.rb
new file mode 100644
index 0000000..51087f6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_addresses.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeAddresses < Fog::Parsers::Base
+
+          def reset
+            @address = {}
+            @response = { 'addressesSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'publicIp'
+              @address[name] = @value
+            when 'item'
+              @response['addressesSet'] << @address
+              @address = {}
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_availability_zones.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_availability_zones.rb
new file mode 100644
index 0000000..92f27e8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_availability_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeAvailabilityZones < Fog::Parsers::Base
+
+          def reset
+            @availability_zone = {}
+            @response = { 'availabilityZoneInfo' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['availabilityZoneInfo'] << @availability_zone
+              @availability_zone = {}
+            when 'regionName', 'zoneName', 'zoneState'
+              @availability_zone[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_images.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_images.rb
new file mode 100644
index 0000000..a9aded4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_images.rb
@@ -0,0 +1,60 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeImages < Fog::Parsers::Base
+
+          def reset
+            @image = { 'productCodes' => [], 'blockDeviceMapping' => nil }
+            @response = { 'imagesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'productCodes'
+              @in_product_codes = true
+            elsif name == 'blockDeviceMapping'
+              @in_block_device_mapping = true
+              @image['blockDeviceMapping'] = []
+             elsif name == 'item' && @in_block_device_mapping
+              @image['blockDeviceMapping'] << {}
+            end
+          end
+          
+          def end_element(name)
+            case name
+            when 'architecture',  'imageId', 'imageLocation', 'imageOwnerId', 'imageState', 'imageType', 'kernelId', 'platform', 'ramdiskId', 'rootDeviceType','rootDeviceName'
+              @image[name] = @value
+            when 'isPublic'
+              if @value == 'true'
+                @image[name] = true
+              else
+                @image[name] = false
+              end
+            when 'item'
+              if @in_block_device_mapping
+              elsif !@in_product_codes
+                @response['imagesSet'] << @image
+                @image = { 'productCodes' => [] }
+              end
+            when 'productCode'
+              @image['productCodes'] << @value
+            when 'productCodes'
+              @in_product_codes = false
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'requestId'
+              @response[name] = @value
+            when 'deviceName','virtualName','snapshotId','volumeSize','deleteOnTermination'
+              l = @image['blockDeviceMapping'].length
+              @image['blockDeviceMapping'][l-1].store(name,@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_instances.rb
new file mode 100644
index 0000000..1f111b9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_instances.rb
@@ -0,0 +1,93 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeInstances < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+            @reservation = { 'groupSet' => [], 'instancesSet' => [] }
+            @response = { 'reservationSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when'groupSet', 'productCodes'
+              @in_subset = true
+            when 'instancesSet'
+              @in_instances_set = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'amiLaunchIndex'
+              @instance[name] = @value.to_i
+            when 'availabilityZone'
+              @instance['placement'][name] = @value
+            when 'architecture', 'dnsName', 'imageId', 'instanceId',
+                  'instanceType', 'ipAddress', 'kernelId', 'keyName',
+                  'privateDnsName', 'privateIpAddress', 'ramdiskId', 'reason',
+                  'rootDeviceType'
+              @instance[name] = @value
+            when 'attachTime'
+              @block_device_mapping[name] = Time.parse(@value)
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'code'
+              @instance['instanceState'][name] = @value.to_i
+            when 'deleteOnTermination'
+              if @value == 'true'
+                @block_device_mapping[name] = true
+              else
+                @block_device_mapping[name] = false
+              end
+            when 'deviceName', 'status', 'volumeId'
+              @block_device_mapping[name] = @value
+            when 'groupId'
+              @reservation['groupSet'] << @value
+            when 'groupSet', 'productCodes'
+              @in_subset = false
+            when 'instancesSet'
+              @in_instances_set = false
+            when 'item'
+              if @in_block_device_mapping
+                @instance['blockDeviceMapping'] << @block_device_mapping
+                @block_device_mapping = {}
+              elsif @in_instances_set
+                @reservation['instancesSet'] << @instance
+                @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+              elsif !@in_subset
+                @response['reservationSet'] << @reservation
+                @reservation = { 'groupSet' => [], 'instancesSet' => [] }
+              end
+            when 'launchTime'
+              @instance[name] = Time.parse(@value)
+            when 'name'
+              @instance['instanceState'][name] = @value
+            when 'ownerId', 'reservationId'
+              @reservation[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            when 'productCode'
+              @instance['productCodes'] << @value
+            when 'state'
+              if @value == 'true'
+                @instance['monitoring'][name] = true
+              else
+                @instance['monitoring'][name] = false
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_key_pairs.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_key_pairs.rb
new file mode 100644
index 0000000..d62746b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_key_pairs.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeKeyPairs < Fog::Parsers::Base
+
+          def reset
+            @key = {}
+            @response = { 'keySet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['keySet'] << @key
+              @key = {}
+            when 'keyFingerprint', 'keyName'
+              @key[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_regions.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_regions.rb
new file mode 100644
index 0000000..fe93ef4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_regions.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeRegions < Fog::Parsers::Base
+
+          def reset
+            @region = {}
+            @response = { 'regionInfo' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['regionInfo'] << @region
+              @region = {}
+            when 'regionEndpoint', 'regionName'
+              @region[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_reserved_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_reserved_instances.rb
new file mode 100644
index 0000000..4452ebd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_reserved_instances.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeReservedInstances < Fog::Parsers::Base
+
+          def reset
+            @reserved_instance = {}
+            @response = { 'reservedInstancesSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'instanceType', 'productDescription', 'reservedInstancesId', 'state'
+              @reserved_instance[name] = @value
+            when 'duration', 'instanceCount'
+              @reserved_instance[name] = @value.to_i
+            when 'fixedPrice', 'usagePrice'
+              @reserved_instance[name] = @value.to_f
+            when 'item'
+              @response['reservedInstancesSet'] << @reserved_instance
+              @reserved_instance = {}
+            when 'requestId'
+              @response[name] = @value
+            when 'start'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_security_groups.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_security_groups.rb
new file mode 100644
index 0000000..68c323b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_security_groups.rb
@@ -0,0 +1,75 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeSecurityGroups < Fog::Parsers::Base
+
+          def reset
+            @group = {}
+            @ip_permission = { 'groups' => [], 'ipRanges' => []}
+            @ip_range = {}
+            @security_group = { 'ipPermissions' => [] }
+            @response = { 'securityGroupInfo' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'groups'
+              @in_groups = true
+            elsif name == 'ipPermissions'
+              @in_ip_permissions = true
+            elsif name == 'ipRanges'
+              @in_ip_ranges = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'cidrIp'
+              @ip_range[name] = @value
+            when 'fromPort', 'toPort'
+              @ip_permission[name] = @value.to_i
+            when 'groups'
+              @in_groups = false
+            when 'groupDescription', 'ownerId'
+              @security_group[name] = @value
+            when 'groupName'
+              if @in_groups
+                @group[name] = @value
+              else
+                @security_group[name] = @value
+              end
+            when 'ipPermissions'
+              @in_ip_permissions = false
+            when 'ipProtocol'
+              @ip_permission[name] = @value
+            when 'ipRanges'
+              @in_ip_ranges = false
+            when 'item'
+              if @in_groups
+                @ip_permission['groups'] << @group
+                @group = {}
+              elsif @in_ip_ranges
+                @ip_permission['ipRanges'] << @ip_range
+                @ip_range = {}
+              elsif @in_ip_permissions
+                @security_group['ipPermissions'] << @ip_permission
+                @ip_permission = { 'groups' => [], 'ipRanges' => []}
+               else
+                @response['securityGroupInfo'] << @security_group
+                @security_group = { 'ipPermissions' => [] }
+              end
+            when 'requestId'
+              @response[name] = @value
+            when 'userId'
+              @group[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_snapshots.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_snapshots.rb
new file mode 100644
index 0000000..e5e235b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_snapshots.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeSnapshots < Fog::Parsers::Base
+
+          def reset
+            @response = { 'snapshotSet' => [] }
+            @snapshot = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['snapshotSet'] << @snapshot
+              @snapshot = {}
+            when 'description', 'ownerId', 'progress', 'snapshotId', 'status', 'volumeId'
+              @snapshot[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            when 'startTime'
+              @snapshot[name] = Time.parse(@value)
+            when 'volumeSize'
+              @snapshot[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_volumes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_volumes.rb
new file mode 100644
index 0000000..ec0c307
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/describe_volumes.rb
@@ -0,0 +1,57 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeVolumes < Fog::Parsers::Base
+
+          def reset
+            @attachment = {}
+            @in_attachment_set = false
+            @response = { 'volumeSet' => [] }
+            @volume = { 'attachmentSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'attachmentSet'
+              @in_attachment_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_attachment_set
+              case name
+              when 'attachmentSet'
+                @in_attachment_set = false
+              when 'attachTime'
+                @attachment[name] = Time.parse(@value)
+              when 'device', 'instanceId', 'status', 'volumeId'
+                @attachment[name] = @value
+              when 'item'
+                @volume['attachmentSet'] << @attachment
+                @attachment = {}
+              end
+            else
+              case name
+              when 'availabilityZone', 'snapshotId', 'status', 'volumeId'
+                @volume[name] = @value
+              when 'createTime'
+                @volume[name] = Time.parse(@value)
+              when 'item'
+                @response['volumeSet'] << @volume
+                @volume = { 'attachmentSet' => [] }
+              when 'requestId'
+                @response[name] = @value
+              when 'size'
+                @volume[name] = @value.to_i
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/detach_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/detach_volume.rb
new file mode 100644
index 0000000..54b3824
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/detach_volume.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DetachVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'attachTime'
+              @response[name] = Time.parse(@value)
+            when 'device', 'instanceId', 'requestId', 'status', 'volumeId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/get_console_output.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/get_console_output.rb
new file mode 100644
index 0000000..1315735
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/get_console_output.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class GetConsoleOutput < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId'
+              @response[name] = @value
+            when 'output'
+              @response[name] = if @value
+                Base64.decode64(@value)
+              else
+                nil
+              end
+            when 'timestamp'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/import_key_pair.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/import_key_pair.rb
new file mode 100644
index 0000000..0aebc0b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/import_key_pair.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class ImportKeyPair < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'keyFingerprint', 'keyName', 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/register_image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/register_image.rb
new file mode 100644
index 0000000..8db68cf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/register_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class RegisterImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'requestId', 'imageId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/run_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/run_instances.rb
new file mode 100644
index 0000000..d26bed6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/run_instances.rb
@@ -0,0 +1,89 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class RunInstances < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+            @response = { 'groupSet' => [], 'instancesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when 'groupSet'
+              @in_group_set = true
+            when 'productCodes'
+              @in_product_codes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'amiLaunchIndex'
+              @instance[name] = @value.to_i
+            when 'architecture', 'dnsName', 'imageId', 'instanceId',
+                  'instanceType', 'ipAddress', 'kernelId', 'keyName',
+                  'privateDnsName', 'privateIpAddress', 'ramdiskId', 'reason',
+                  'rootDeviceType'
+              @instance[name] = @value
+            when 'availabilityZone'
+              @instance['placement'][name] = @value
+            when 'attachTime'
+              @block_device_mapping[name] = Time.parse(@value)
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'code'
+              @instance['instanceState'][name] = @value.to_i
+            when 'deleteOnTermination'
+              if @value == 'true'
+                @block_device_mapping[name] = true
+              else
+                @block_device_mapping[name] = false
+              end
+            when 'deviceName', 'status', 'volumeId'
+              @block_device_mapping[name] = @value
+            when 'groupId'
+              @response['groupSet'] << @value
+            when 'groupSet'
+              @in_group_set = false
+            when 'item'
+              if @in_block_device_mapping
+                @instance['blockDeviceMapping'] << @block_device_mapping
+                @block_device_mapping = {}
+              elsif !@in_group_set && !@in_product_codes
+                @response['instancesSet'] << @instance
+                @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+              end
+            when 'launchTime'
+              @instance[name] = Time.parse(@value)
+            when 'name'
+              @instance['instanceState'][name] = @value
+            when 'ownerId', 'requestId', 'reservationId'
+              @response[name] = @value
+            when 'product_code'
+              @instance['productCodes'] << @value
+            when 'productCodes'
+              @in_product_codes = false
+            when 'state'
+              if @value == 'true'
+                @instance['monitoring'][name] = true
+              else
+                @instance['monitoring'][name] = false
+              end
+            when 'subnetId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/start_stop_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/start_stop_instances.rb
new file mode 100644
index 0000000..f83bd5d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/start_stop_instances.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class StartStopInstances < Fog::Parsers::Base
+
+          def reset
+            @instance = { 'currentState' => {}, 'previousState' => {} }
+            @response = { 'instancesSet' => [] }
+            @state = nil
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'currentState', 'previousState'
+              @state = name
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'code'
+              @instance[@state][name] = @value.to_s
+            when 'instanceId'
+              @instance[name] = @value
+            when 'item'
+              @response['instancesSet'] << @instance
+              @instance = { 'currentState' => {}, 'previousState' => {} }
+            when 'name'
+              @instance[@state][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/terminate_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/terminate_instances.rb
new file mode 100644
index 0000000..6f9a466
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/compute/terminate_instances.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class TerminateInstances < Fog::Parsers::Base
+
+          def reset
+            @instance = { 'previousState' => {}, 'currentState' => {} }
+            @response = { 'instancesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'previousState'
+              @in_previous_state = true
+            elsif name == 'currentState'
+              @in_current_state = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId'
+              @instance[name] = @value
+            when 'item'
+              @response['instancesSet'] << @instance
+              @instance = { 'previousState' => {}, 'currentState' => {} }
+            when 'code'
+              if @in_previous_state
+                @instance['previousState'][name] = @value.to_i
+              elsif @in_current_state
+                @instance['currentState'][name] = @value.to_i
+              end
+            when 'name'
+              if @in_previous_state
+                @instance['previousState'][name] = @value
+              elsif @in_current_state
+                @instance['currentState'][name] = @value
+              end
+            when 'previousState'
+              @in_previous_state = false
+            when 'requestId'
+              @response[name] = @value
+            when 'currentState'
+              @in_current_state = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/create_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/create_load_balancer.rb
new file mode 100644
index 0000000..a69858c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/create_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class CreateLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CreateLoadBalancerResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DNSName'
+              @response['CreateLoadBalancerResult'][name] = @value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/delete_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/delete_load_balancer.rb
new file mode 100644
index 0000000..cfb946e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/delete_load_balancer.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DeleteLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DeleteLoadBalancerResult' => nil, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
new file mode 100644
index 0000000..8436127
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DeregisterInstancesFromLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DeregisterInstancesFromLoadBalancerResult' => { 'Instances' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'InstanceId'
+              @response['DeregisterInstancesFromLoadBalancerResult']['Instances'] << {name => @value}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/describe_instance_health.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/describe_instance_health.rb
new file mode 100644
index 0000000..2c51dfd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/describe_instance_health.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DescribeInstanceHealth < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DescribeInstanceHealthResult' => { 'InstanceStates' => [] }, 'ResponseMetadata' => {} }
+            @instance_state = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'State', 'InstanceId', 'ReasonCode'
+              @instance_state[name] = @value
+            when 'member'
+              @response['DescribeInstanceHealthResult']['InstanceStates'] << @instance_state
+              @instance_state = {}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/describe_load_balancers.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/describe_load_balancers.rb
new file mode 100644
index 0000000..7778a6a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/describe_load_balancers.rb
@@ -0,0 +1,101 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DescribeLoadBalancers < Fog::Parsers::Base
+
+          def reset
+            @load_balancer = { 'ListenerDescriptions' => [], 'Instances' => [], 'AvailabilityZones' => [], 'Policies' => {'AppCookieStickinessPolicies' => [], 'LBCookieStickinessPolicies' => [] }, 'HealthCheck' => {} }
+            @listener_description = { 'PolicyNames' => [], 'Listener' => {} }
+            @results = { 'LoadBalancerDescriptions' => [] }
+            @response = { 'DescribeLoadBalancersResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'ListenerDescriptions'
+              @in_listeners = true
+            when 'Instances'
+              @in_instances = true
+            when 'AvailabilityZones'
+              @in_availability_zones = true
+            when 'PolicyNames'
+              @in_policy_names = true
+            when 'Policies'
+              @in_policies = true
+            when 'LBCookieStickinessPolicies'
+              @in_lb_cookies = true
+            when 'AppCookieStickinessPolicies'
+              @in_app_cookies = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              if @in_policy_names
+                @listener_description['PolicyNames'] << @value
+              elsif @in_availability_zones
+                @load_balancer['AvailabilityZones'] << @value
+              elsif @in_listeners
+                @load_balancer['ListenerDescriptions'] << @listener_description
+                @listener_description = { 'PolicyNames' => [], 'Listener' => {} }
+              elsif @in_app_cookies
+                @load_balancer['Policies']['AppCookieStickinessPolicies'] << @value
+              elsif @in_lb_cookies
+                @load_balancer['Policies']['LBCookieStickinessPolicies'] << @value
+              elsif !@in_instances && !@in_policies
+                @results['LoadBalancerDescriptions'] << @load_balancer
+                @load_balancer = { 'ListenerDescriptions' => [], 'Instances' => [], 'AvailabilityZones' => [], 'Policies' => {'AppCookieStickinessPolicies' => [], 'LBCookieStickinessPolicies' => [] }, 'HealthCheck' => {} }
+              end
+
+            when 'LoadBalancerName', 'DNSName'
+              @load_balancer[name] = @value
+            when 'CreatedTime'
+              @load_balancer[name] = Time.parse(@value)
+
+            when 'ListenerDescriptions'
+              @in_listeners = false
+            when 'PolicyNames'
+              @in_policy_names = false
+            when 'Protocol'
+              @listener_description['Listener'][name] = @value
+            when 'LoadBalancerPort', 'InstancePort'
+              @listener_description['Listener'][name] = @value.to_i
+
+            when 'Instances'
+              @in_instances = false
+            when 'InstanceId'
+              @load_balancer['Instances'] << @value
+
+            when 'AvailabilityZones'
+              @in_availability_zones = false
+
+            when 'Policies'
+              @in_policies = false
+            when 'AppCookieStickinessPolicies'
+              @in_app_cookies = false
+            when 'LBCookieStickinessPolicies'
+              @in_lb_cookies = false
+
+            when 'Interval', 'HealthyThreshold', 'Timeout', 'UnhealthyThreshold'
+              @load_balancer['HealthCheck'][name] = @value.to_i
+            when 'Target'
+              @load_balancer['HealthCheck'][name] = @value
+
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+
+            when 'DescribeLoadBalancersResponse'
+              @response['DescribeLoadBalancersResult'] = @results
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..4abfb77
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DisableAvailabilityZonesForLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DisableAvailabilityZonesForLoadBalancerResult' => { 'AvailabilityZones' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['DisableAvailabilityZonesForLoadBalancerResult']['AvailabilityZones'] << @value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..cb96c38
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class EnableAvailabilityZonesForLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'EnableAvailabilityZonesForLoadBalancerResult' => { 'AvailabilityZones' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['EnableAvailabilityZonesForLoadBalancerResult']['AvailabilityZones'] << @value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
new file mode 100644
index 0000000..2b1cca3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class RegisterInstancesWithLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'RegisterInstancesWithLoadBalancerResult' => { 'Instances' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'InstanceId'
+              @response['RegisterInstancesWithLoadBalancerResult']['Instances'] << {name => @value}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/basic.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/basic.rb
new file mode 100644
index 0000000..8a653e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/basic.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class Basic < Fog::Parsers::Base
+
+          def initialize(nil_string)
+            @nil_string = nil_string
+            reset
+          end
+
+          def end_element(name)
+            case(name)
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'RequestId'
+              response[name] = @value
+            end
+          end
+
+          def sdb_decode(value)
+            value.eql?(@nil_string) ? nil : value
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/domain_metadata.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/domain_metadata.rb
new file mode 100644
index 0000000..3d9df66
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/domain_metadata.rb
@@ -0,0 +1,32 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class DomainMetadata < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'AttributeNameCount', 'AttributeNamesSizeBytes', 'AttributeValueCount', 'AttributeValuesSizeBytes', 'ItemCount', 'ItemNamesSizeBytes'
+              response[name] = @value.to_i
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'RequestId'
+              response[name] = @value
+            when 'Timestamp'
+              response[name] = Time.at(@value.to_i)
+            end
+          end
+
+        end
+        
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/get_attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/get_attributes.rb
new file mode 100644
index 0000000..c1c9ee4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/get_attributes.rb
@@ -0,0 +1,36 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class GetAttributes < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @attribute = nil
+            @response = { 'Attributes' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Attribute'
+              @attribute = nil
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'Name'
+              @attribute = @value
+              response['Attributes'][@attribute] ||= []
+            when 'RequestId'
+              response[name] = @value
+            when 'Value'
+              response['Attributes'][@attribute] << sdb_decode(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/list_domains.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/list_domains.rb
new file mode 100644
index 0000000..8b1fa3e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/list_domains.rb
@@ -0,0 +1,30 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class ListDomains < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @response = { 'Domains' => [] }
+          end
+
+          def end_element(name)
+            case(name)
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'DomainName'
+              response['Domains'] << @value
+            when 'NextToken', 'RequestId'
+              response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/select.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/select.rb
new file mode 100644
index 0000000..ce5e503
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/simpledb/select.rb
@@ -0,0 +1,41 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class Select < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @item_name = @attribute_name = nil
+            @response = { 'Items' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'Item'
+              @item_name = @attribute_name = nil
+            when 'Name'
+              if @item_name.nil? 
+                @item_name = @value
+                response['Items'][@item_name] = {}
+              else
+                @attribute_name = @value
+                response['Items'][@item_name][@attribute_name] ||= []
+              end
+            when 'NextToken', 'RequestId'
+              response[name] = @value
+            when 'Value'
+              response['Items'][@item_name][@attribute_name] << sdb_decode(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/access_control_list.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/access_control_list.rb
new file mode 100644
index 0000000..b0f1f70
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/access_control_list.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @in_access_control_list = false
+            @grant = { 'Grantee' => {} }
+            @response = { 'Owner' => {}, 'AccessControlList' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'AccessControlList'
+              @in_access_control_list = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessControlList'
+              @in_access_control_list = false
+            when 'Grant'
+              @response['AccessControlList'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = @value
+              else
+                @response['Owner'][name] = @value
+              end
+            when 'Permission'
+              @grant[name] = @value
+            when 'URI'
+              @grant['Grantee'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/copy_object.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/copy_object.rb
new file mode 100644
index 0000000..4e428bd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/copy_object.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class CopyObject < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'ETag'
+              @response[name] = @value.gsub('"', '')
+            when 'LastModified'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket.rb
new file mode 100644
index 0000000..740a826
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucket < Fog::Parsers::Base
+
+          def reset
+            @object = { 'Owner' => {} }
+            @response = { 'Contents' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Contents'
+              @response['Contents'] << @object
+              @object = { 'Owner' => {} }
+            when 'DisplayName', 'ID'
+              @object['Owner'][name] = @value
+            when 'ETag'
+              @object[name] = @value.gsub('"', '')
+            when 'IsTruncated'
+              if @value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              @object['LastModified'] = Time.parse(@value)
+            when 'Marker', 'Name', 'Prefix'
+              @response[name] = @value
+            when 'MaxKeys'
+              @response['MaxKeys'] = @value.to_i
+            when 'Size'
+              @object['Size'] = @value.to_i
+            when 'Delimeter', 'Key', 'Name', 'StorageClass'
+              @object[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_location.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_location.rb
new file mode 100644
index 0000000..ba40bd0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_location.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketLocation < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'LocationConstraint'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_logging.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_logging.rb
new file mode 100644
index 0000000..ef635b1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_logging.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @grant = { 'Grantee' => {} }
+            @response = { 'BucketLoggingStatus' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = @value
+              else
+                @response['Owner'][name] = @value
+              end
+            when 'Grant'
+              @response['BucketLoggingStatus']['LoggingEnabled']['TargetGrants'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'LoggingEnabled'
+              @response['BucketLoggingStatus']['LoggingEnabled'] = { 'TargetGrants' => [] }
+            when 'Permission'
+              @grant[name] = @value
+            when 'TargetBucket', 'TargetPrefix'
+              @response['BucketLoggingStatus'][name] = @value
+            when 'URI'
+              @grant['Grantee'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_object_versions.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_object_versions.rb
new file mode 100644
index 0000000..8d631dc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_object_versions.rb
@@ -0,0 +1,88 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketObjectVersions < Fog::Parsers::Base
+
+          def reset
+            @delete_marker = { 'Owner' => {} }
+            @version = { 'Owner' => {} }
+
+            @in_delete_marke = false
+            @in_version = false
+
+            @response = { 'Versions' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'DeleteMarker'
+              @in_delete_marker = true
+            when 'Version'
+              @in_version = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DeleteMarker'
+              @response['Versions'] << {'DeleteMarker' => @delete_marker }
+              @delete_marker = { 'Owner' => {} }
+              @in_delete_marker = false
+            when 'Version'
+              @response['Versions'] << {'Version' => @version }
+              @version = { 'Owner' => {} }
+              @in_version = false
+            when 'DisplayName', 'ID'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['Owner'][name] = @value
+            when 'ETag'
+              @version[name] = @value.gsub('"', '')
+            when 'IsLatest'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['IsLatest'] = if @value == 'true'
+                true
+              else
+                false
+              end
+            when 'IsTruncated'
+              if @value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['LastModified'] = Time.parse(@value)
+            when 'KeyMarker', 'Name', 'Prefix', 'VersionIdMarker'
+              @response[name] = @value
+            when 'MaxKeys'
+              @response['MaxKeys'] = @value.to_i
+            when 'Size'
+              @version['Size'] = @value.to_i
+            when 'Key', 'Name', 'StorageClass', 'VersionId'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_versioning.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_versioning.rb
new file mode 100644
index 0000000..1a3f947
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_bucket_versioning.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketVersioning < Fog::Parsers::Base
+
+          def reset
+            @response = { 'VersioningConfiguration' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Status'
+              @response['VersioningConfiguration'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_request_payment.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_request_payment.rb
new file mode 100644
index 0000000..2884f4b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_request_payment.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetRequestPayment < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'Payer'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_service.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_service.rb
new file mode 100644
index 0000000..d3ad8cc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/parsers/storage/get_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetService < Fog::Parsers::Base
+
+          def reset
+            @bucket = {}
+            @response = { 'Owner' => {}, 'Buckets' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket'
+              @response['Buckets'] << @bucket
+              @bucket = {}
+            when 'CreationDate'
+              @bucket['CreationDate'] = Time.parse(@value)
+            when 'DisplayName', 'ID'
+              @response['Owner'][name] = @value
+            when 'Name'
+              @bucket[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/allocate_address.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/allocate_address.rb
new file mode 100644
index 0000000..c6f5cec
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/allocate_address.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/allocate_address'
+
+        # Acquire an elastic IP address.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'publicIp'<~String> - The acquired address
+        #     * 'requestId'<~String> - Id of the request
+        def allocate_address
+          request(
+            'Action'  => 'AllocateAddress',
+            :parser   => Fog::Parsers::AWS::Compute::AllocateAddress.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def allocate_address
+          response = Excon::Response.new
+          if describe_addresses.body['addressesSet'].size < @data[:limits][:addresses]
+            response.status = 200
+            public_ip = Fog::AWS::Mock.ip_address
+            data ={
+              'instanceId' => nil,
+              'publicIp'   => public_ip
+            }
+            @data[:addresses][public_ip] = data
+            response.body = {
+              'publicIp'  => public_ip,
+              'requestId' => Fog::AWS::Mock.request_id
+            }
+            response
+          else
+            response.status = 400
+            response.body = "<?xml version=\"1.0\"?><Response><Errors><Error><Code>AddressLimitExceeded</Code><Message>Too many addresses allocated</Message></Error></Errors><RequestID>#{Fog::AWS::Mock.request_id}</RequestID></Response>"
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/associate_address.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/associate_address.rb
new file mode 100644
index 0000000..7080b41
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/associate_address.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Associate an elastic IP address with an instance
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to associate address with
+        # * public_ip<~String> - Public ip to assign to instance
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def associate_address(instance_id, public_ip)
+          request(
+            'Action'      => 'AssociateAddress',
+            'InstanceId'  => instance_id,
+            'PublicIp'    => public_ip,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def associate_address(instance_id, public_ip)
+          response = Excon::Response.new
+          response.status = 200
+          instance = @data[:instances][instance_id]
+          address = @data[:addresses][public_ip]
+          if instance && address
+            address['instanceId'] = instance_id
+            instance['originalIpAddress'] = instance['ipAddress']
+            instance['ipAddress'] = public_ip
+            instance['dnsName'] = Fog::AWS::Mock.dns_name_for(public_ip)
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          elsif !instance
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          elsif !address
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/attach_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/attach_volume.rb
new file mode 100644
index 0000000..d90505d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/attach_volume.rb
@@ -0,0 +1,81 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/attach_volume'
+
+        # Attach an Amazon EBS volume with a running instance, exposing as specified device
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to associate volume with
+        # * volume_id<~String> - Id of amazon EBS volume to associate with instance
+        # * device<~String> - Specifies how the device is exposed to the instance (e.g. "/dev/sdh")
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'attachTime'<~Time> - Time of attachment was initiated at
+        #     * 'device'<~String> - Device as it is exposed to the instance
+        #     * 'instanceId'<~String> - Id of instance for volume
+        #     * 'requestId'<~String> - Id of request
+        #     * 'status'<~String> - Status of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        def attach_volume(instance_id, volume_id, device)
+          request(
+            'Action'      => 'AttachVolume',
+            'VolumeId'    => volume_id,
+            'InstanceId'  => instance_id,
+            'Device'      => device,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::AttachVolume.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def attach_volume(instance_id, volume_id, device)
+          response = Excon::Response.new
+          if instance_id && volume_id && device
+            response.status = 200
+            instance = @data[:instances][instance_id]
+            volume = @data[:volumes][volume_id]
+            if instance && volume
+              data = {
+                'attachTime'  => Time.now,
+                'device'      => device,
+                'instanceId'  => instance_id,
+                'status'      => 'attaching',
+                'volumeId'    => volume_id
+              }
+              volume['attachmentSet'] = [data]
+              volume['status'] = 'attaching'
+              response.status = 200
+              response.body = {
+                'requestId' => Fog::AWS::Mock.request_id
+              }.merge!(data)
+              response
+            elsif !instance
+              raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist.")
+            elsif !volume
+              raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+            end
+          else
+            message = 'MissingParameter => '
+            if !instance_id
+              message << 'The request must contain the parameter instance_id'
+            elsif !volume_id
+              message << 'The request must contain the parameter volume_id'
+            else
+              message << 'The request must contain the parameter device'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/authorize_security_group_ingress.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/authorize_security_group_ingress.rb
new file mode 100644
index 0000000..30cb6a3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/authorize_security_group_ingress.rb
@@ -0,0 +1,86 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Add permissions to a security group
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'GroupName'<~String> - Name of group
+        #   * 'SourceSecurityGroupName'<~String> - Name of security group to authorize
+        #   * 'SourceSecurityGroupOwnerId'<~String> - Name of owner to authorize
+        #   or
+        #   * 'CidrIp' - CIDR range
+        #   * 'FromPort' - Start of port range (or -1 for ICMP wildcard)
+        #   * 'GroupName' - Name of group to modify
+        #   * 'IpProtocol' - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #   * 'ToPort' - End of port range (or -1 for ICMP wildcard)
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def authorize_security_group_ingress(options = {})
+          request({
+            'Action'    => 'AuthorizeSecurityGroupIngress',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def authorize_security_group_ingress(options = {})
+          response = Excon::Response.new
+          group = @data[:security_groups][options['GroupName']]
+
+          if group
+            group['ipPermissions'] ||= []
+            if options['GroupName'] && options['SourceSecurityGroupName'] && options['SourceSecurityGroupOwnerId']
+              ['tcp', 'udp'].each do |protocol|
+                group['ipPermissions'] << {
+                  'groups'      => [{'groupName' => options['GroupName'], 'userId' => @owner_id}],
+                  'fromPort'    => 1,
+                  'ipRanges'    => [],
+                  'ipProtocol'  => protocol,
+                  'toPort'      => 65535
+                }
+              end
+              group['ipPermissions'] << {
+                'groups'      => [{'groupName' => options['GroupName'], 'userId' => @owner_id}],
+                'fromPort'    => -1,
+                'ipRanges'    => [],
+                'ipProtocol'  => 'icmp',
+                'toPort'      => -1
+              }
+            else
+              group['ipPermissions'] << {
+                'groups'      => [],
+                'fromPort'    => options['FromPort'],
+                'ipRanges'    => [],
+                'ipProtocol'  => options['IpProtocol'],
+                'toPort'      => options['ToPort']
+              }
+              if options['CidrIp']
+                group['ipPermissions'].last['ipRanges'] << { 'cidrIp' => options['CidrIp'] }
+              end
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{options['GroupName']}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_image.rb
new file mode 100644
index 0000000..e296147
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_image.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_image'
+
+        # Create a bootable EBS volume AMI
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Instance used to create image.
+        # * name<~Name> - Name to give image.
+        # * description<~Name> - Description of image.
+        # * no_reboot<~Boolean> - Optional, whether or not to reboot the image when making the snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'imageId'<~String> - The ID of the created AMI.
+        #     * 'requestId'<~String> - Id of request.
+        def create_image(instance_id, name, description, no_reboot = false)
+          request(
+            'Action'            => 'CreateImage',
+            'InstanceId'        => instance_id,
+            'Name'              => name,
+            'Description'       => description,
+            'NoReboot'          => no_reboot.to_s,
+            :parser             => Fog::Parsers::AWS::Compute::CreateImage.new
+          )
+        end
+      end
+
+      class Mock
+
+        def create_image(instance_id, name, description, no_reboot = false)
+          response = Excon::Response.new
+          if instance_id && !name.empty?
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'imageId' => Fog::AWS::Mock.image_id
+            }
+          else
+            response.status = 400
+            response.body = {
+              'Code' => 'InvalidParameterValue'
+            }
+            if name.empty?
+              response.body['Message'] = "Invalid value '' for name. Must be specified."
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_key_pair.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_key_pair.rb
new file mode 100644
index 0000000..d96936c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_key_pair.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_key_pair'
+
+        # Create a new key pair
+        #
+        # ==== Parameters
+        # * key_name<~String> - Unique name for key pair.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'keyFingerprint'<~String> - SHA-1 digest of DER encoded private key
+        #     * 'keyMaterial'<~String> - Unencrypted encoded PEM private key
+        #     * 'keyName'<~String> - Name of key
+        #     * 'requestId'<~String> - Id of request
+        def create_key_pair(key_name)
+          request(
+            'Action'  => 'CreateKeyPair',
+            'KeyName' => key_name,
+            :parser   => Fog::Parsers::AWS::Compute::CreateKeyPair.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_key_pair(key_name)
+          response = Excon::Response.new
+          unless @data[:key_pairs][key_name]
+            response.status = 200
+            data = {
+              'keyFingerprint'  => Fog::AWS::Mock.key_fingerprint,
+              'keyMaterial'     => Fog::AWS::Mock.key_material,
+              'keyName'         => key_name
+            }
+            @data[:key_pairs][key_name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidKeyPair.Duplicate => The keypair '#{key_name}' already exists.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_security_group.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_security_group.rb
new file mode 100644
index 0000000..02cb8c1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_security_group.rb
@@ -0,0 +1,53 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Create a new security group
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of the security group.
+        # * group_description<~String> - Description of group.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def create_security_group(name, description)
+          request(
+            'Action'            => 'CreateSecurityGroup',
+            'GroupName'         => name,
+            'GroupDescription'  => CGI.escape(description),
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_security_group(name, description)
+          response = Excon::Response.new
+          unless @data[:security_groups][name]
+            data = {
+              'groupDescription'  => CGI.escape(description).gsub('%20', '+'),
+              'groupName'         => CGI.escape(name).gsub('%20', '+'),
+              'ipPermissions'     => [],
+              'ownerId'           => @owner_id
+            }
+            @data[:security_groups][name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidGroup.Duplicate => The security group '#{name}' already exists")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_snapshot.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_snapshot.rb
new file mode 100644
index 0000000..f461ee4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_snapshot.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_snapshot'
+
+        # Create a snapshot of an EBS volume and store it in S3
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of EBS volume to snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'progress'<~String> - The percentage progress of the snapshot
+        #     * 'requestId'<~String> - id of request
+        #     * 'snapshotId'<~String> - id of snapshot
+        #     * 'startTime'<~Time> - timestamp when snapshot was initiated
+        #     * 'status'<~String> - state of snapshot
+        #     * 'volumeId'<~String> - id of volume snapshot targets
+        def create_snapshot(volume_id, description = nil)
+          request(
+            'Action'      => 'CreateSnapshot',
+            'Description' => description,
+            'VolumeId'    => volume_id,
+            :parser       => Fog::Parsers::AWS::Compute::CreateSnapshot.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_snapshot(volume_id, description = nil)
+          response = Excon::Response.new
+          if volume = @data[:volumes][volume_id]
+            response.status = 200
+            snapshot_id = Fog::AWS::Mock.snapshot_id
+            data = {
+              'description' => description,
+              'ownerId'     => @owner_id,
+              'progress'    => nil,
+              'snapshotId'  => snapshot_id,
+              'startTime'   => Time.now,
+              'status'      => 'pending',
+              'volumeId'    => volume_id,
+              'volumeSize'  => volume['size']
+            }
+            @data[:snapshots][snapshot_id] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_volume.rb
new file mode 100644
index 0000000..a7d394c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/create_volume.rb
@@ -0,0 +1,73 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_volume'
+
+        # Create an EBS volume
+        #
+        # ==== Parameters
+        # * availability_zone<~String> - availability zone to create volume in
+        # * size<~Integer> - Size in GiBs for volume.  Must be between 1 and 1024.
+        # * snapshot_id<~String> - Optional, snapshot to create volume from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'availabilityZone'<~String> - Availability zone for volume
+        #     * 'createTime'<~Time> - Timestamp for creation
+        #     * 'size'<~Integer> - Size in GiBs for volume
+        #     * 'snapshotId'<~String> - Snapshot volume was created from, if any
+        #     * 'status's<~String> - State of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        def create_volume(availability_zone, size, snapshot_id = nil)
+          request(
+            'Action'            => 'CreateVolume',
+            'AvailabilityZone'  => availability_zone,
+            'Size'              => size,
+            'SnapshotId'        => snapshot_id,
+            :parser             => Fog::Parsers::AWS::Compute::CreateVolume.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_volume(availability_zone, size, snapshot_id = nil)
+          response = Excon::Response.new
+          if availability_zone && size
+            response.status = 200
+            volume_id = Fog::AWS::Mock.volume_id
+            data = {
+              'availabilityZone'  => availability_zone,
+              'attachmentSet'     => [],
+              'createTime'        => Time.now,
+              'size'              => size,
+              'snapshotId'        => snapshot_id,
+              'status'            => 'creating',
+              'volumeId'          => volume_id
+            }
+            @data[:volumes][volume_id] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data.reject {|key,value| !['availabilityZone','createTime','size','snapshotId','status','volumeId'].include?(key) })
+          else
+            response.status = 400
+            response.body = {
+              'Code' => 'MissingParameter'
+            }
+            unless availability_zone
+              response.body['Message'] = 'The request must contain the parameter availability_zone'
+            else
+              response.body['Message'] = 'The request must contain the parameter size'
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_key_pair.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_key_pair.rb
new file mode 100644
index 0000000..2efbf7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_key_pair.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete a key pair that you own
+        #
+        # ==== Parameters
+        # * key_name<~String> - Name of the key pair.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_key_pair(key_name)
+          request(
+            'Action'    => 'DeleteKeyPair',
+            'KeyName'   => key_name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_key_pair(key_name)
+          response = Excon::Response.new
+          @data[:key_pairs].delete(key_name)
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'return'    => true
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_security_group.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_security_group.rb
new file mode 100644
index 0000000..beea6e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_security_group.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete a security group that you own
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of the security group.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_security_group(name)
+          request(
+            'Action'    => 'DeleteSecurityGroup',
+            'GroupName' => name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+        def delete_security_group(name)
+          response = Excon::Response.new
+          if @data[:security_groups][name]
+            @data[:security_groups].delete(name)
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{name}' does not exist")
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_snapshot.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_snapshot.rb
new file mode 100644
index 0000000..966244a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_snapshot.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete a snapshot of an EBS volume that you own
+        #
+        # ==== Parameters
+        # * snapshot_id<~String> - ID of snapshot to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_snapshot(snapshot_id)
+          request(
+            'Action'      => 'DeleteSnapshot',
+            'SnapshotId'  => snapshot_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_snapshot(snapshot_id)
+          response = Excon::Response.new
+          if snapshot = @data[:snapshots].delete(snapshot_id)
+            response.status = true
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The snapshot '#{snapshot_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_volume.rb
new file mode 100644
index 0000000..85a254b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/delete_volume.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete an EBS volume
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of volume to delete.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_volume(volume_id)
+          request(
+            'Action'    => 'DeleteVolume',
+            'VolumeId'  => volume_id,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_volume(volume_id)
+          response = Excon::Response.new
+          if volume = @data[:volumes][volume_id]
+            if volume["attachmentSet"].any?
+              attach = volume["attachmentSet"].first
+              raise Fog::AWS::Compute::Error.new("Client.VolumeInUse => Volume #{volume_id} is currently attached to #{attach["instanceId"]}")
+            end
+            @data[:deleted_at][volume_id] = Time.now
+            volume['status'] = 'deleting'
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/deregister_image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/deregister_image.rb
new file mode 100644
index 0000000..72442ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/deregister_image.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/deregister_image'
+
+        # deregister an image
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of image to deregister 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'return'<~Boolean> - Returns true if deregistration succeeded
+        #     * 'requestId'<~String> - Id of request
+        def deregister_image(image_id)
+          request(
+            'Action'      => 'DeregisterImage',
+            'ImageId'     => image_id,
+            :parser       => Fog::Parsers::AWS::Compute::DeregisterImage.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def deregister_image(image_id)
+          response = Excon::Response.new
+          if image_id 
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return' => "true"
+            }
+            response
+          else
+            message = 'MissingParameter => '
+            if !instance_id
+              message << 'The request must contain the parameter image_id'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_addresses.rb
new file mode 100644
index 0000000..2bc9245
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_addresses.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_addresses'
+
+        # Describe all or specified IP addresses.
+        #
+        # ==== Parameters
+        # * public_ip<~Array> - List of ips to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'addressesSet'<~Array>:
+        #       * 'instanceId'<~String> - instance for ip address
+        #       * 'publicIp'<~String> - ip address for instance
+        def describe_addresses(public_ip = [])
+          params = AWS.indexed_param('PublicIp', public_ip)
+          request({
+            'Action'    => 'DescribeAddresses',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeAddresses.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_addresses(public_ip = [])
+          response = Excon::Response.new
+          public_ip = [*public_ip]
+          if public_ip != []
+            addresses_set = @data[:addresses].reject {|key, value| !public_ip.include?(key)}.values
+          else
+            addresses_set = @data[:addresses].values
+          end
+          if public_ip.length == 0 || public_ip.length == addresses_set.length
+            response.status = 200
+            response.body = {
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'addressesSet'  => addresses_set
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("Address #{public_ip.inspect} not found.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_availability_zones.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_availability_zones.rb
new file mode 100644
index 0000000..dd1cd8d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_availability_zones.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_availability_zones'
+
+        # Describe all or specified availability zones
+        #
+        # ==== Params
+        # * zone_name<~String> - List of availability zones to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'availabilityZoneInfo'<~Array>:
+        #       * 'regionName'<~String> - Name of region
+        #       * 'zoneName'<~String> - Name of zone
+        #       * 'zoneState'<~String> - State of zone
+        def describe_availability_zones(zone_name = [])
+          params = AWS.indexed_param('ZoneName', zone_name)
+          request({
+            'Action'    => 'DescribeAvailabilityZones',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeAvailabilityZones.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_availability_zones(zone_name = [])
+          response = Excon::Response.new
+          zone_name = [*zone_name]
+          zones = {
+            'us-east-1a' => {"zoneName"=>"us-east-1a", "regionName"=>"us-east-1", "zoneState"=>"available"}, 
+            'us-east-1b' => {"zoneName"=>"us-east-1b", "regionName"=>"us-east-1", "zoneState"=>"available"}, 
+            'us-east-1c' => {"zoneName"=>"us-east-1c", "regionName"=>"us-east-1", "zoneState"=>"available"}, 
+            'us-east-1d' => {"zoneName"=>"us-east-1d", "regionName"=>"us-east-1", "zoneState"=>"available"}
+          }
+          if zone_name != []
+            availability_zone_info = zones.reject {|key, value| !zone_name.include?(key)}.values
+          else
+            availability_zone_info = zones.values
+          end
+
+          if zone_name.length == 0 || zone_name.length == availability_zone_info.length
+            response.status = 200
+            response.body = {
+              'requestId'             => Fog::AWS::Mock.request_id,
+              'availabilityZoneInfo'  => availability_zone_info
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidParameterValue => Invalid availability zone: #{zone_name.inspect}")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_images.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_images.rb
new file mode 100644
index 0000000..4a47cb9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_images.rb
@@ -0,0 +1,70 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_images'
+
+        # Describe all or specified images.
+        #
+        # ==== Params
+        # * options<~Hash> - Optional params
+        #   * 'ExecutableBy'<~String> - Only return images that the executable_by
+        #     user has explicit permission to launch
+        #   * 'ImageId'<~Array> - Ids of images to describe
+        #   * 'Owner'<~String> - Only return images belonging to owner.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'imagesSet'<~Array>:
+        #       * 'architecture'<~String> - Architecture of the image
+        #       * 'blockDeviceMapping'<~Array> - An array of mapped block devices
+        #       * 'imageId'<~String> - Id of the image
+        #       * 'imageLocation'<~String> - Location of the image
+        #       * 'imageOwnerId'<~String> - Id of the owner of the image
+        #       * 'imageState'<~String> - State of the image
+        #       * 'imageType'<~String> - Type of the image
+        #       * 'isPublic'<~Boolean> - Whether or not the image is public
+        #       * 'kernelId'<~String> - Kernel id associated with image, if any
+        #       * 'platform'<~String> - Operating platform of the image
+        #       * 'productCodes'<~Array> - Product codes for the image
+        #       * 'ramdiskId'<~String> - Ramdisk id associated with image, if any
+        #       * 'rootDeviceName'<~String> - Root device name, e.g. /dev/sda1
+        #       * 'rootDeviceType'<~String> - Root device type, ebs or instance-store
+        def describe_images(options = {})
+          if image_id = options.delete('ImageId')
+            options.merge!(AWS.indexed_param('ImageId', image_id))
+          end
+          request({
+            'Action'    => 'DescribeImages',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeImages.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def describe_images(options = {})
+          response = Excon::Response.new
+          images = []
+
+          (rand(101 + 100)).times do
+            images << Fog::AWS::Mock.image
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'imagesSet' => images
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_instances.rb
new file mode 100644
index 0000000..4d48f04
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_instances.rb
@@ -0,0 +1,129 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_instances'
+
+        # Describe all or specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - List of instance ids to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservationSet'<~Array>:
+        #       * 'groupSet'<~Array> - Group names for reservation
+        #       * 'ownerId'<~String> - AWS Access Key ID of reservation owner
+        #       * 'reservationId'<~String> - Id of the reservation
+        #       * 'instancesSet'<~Array>:
+        #         * instance<~Hash>:
+        #           * 'architecture'<~String> - architecture of image in [i386, x86_64]
+        #           * 'amiLaunchIndex'<~Integer> - reference to instance in launch group
+        #           * 'blockDeviceMapping'<~Array>
+        #             * 'attachTime'<~Time> - time of volume attachment
+        #             * 'deleteOnTermination'<~Boolean> - whether or not to delete volume on termination
+        #             * 'deviceName'<~String> - specifies how volume is exposed to instance
+        #             * 'status'<~String> - status of attached volume
+        #             * 'volumeId'<~String> - Id of attached volume
+        #           * 'dnsName'<~String> - public dns name, blank until instance is running
+        #           * 'imageId'<~String> - image id of ami used to launch instance
+        #           * 'instanceId'<~String> - id of the instance
+        #           * 'instanceState'<~Hash>:
+        #             * 'code'<~Integer> - current status code
+        #             * 'name'<~String> - current status name
+        #           * 'instanceType'<~String> - type of instance
+        #           * 'ipAddress'<~String> - public ip address assigned to instance
+        #           * 'kernelId'<~String> - id of kernel used to launch instance
+        #           * 'keyName'<~String> - name of key used launch instances or blank
+        #           * 'launchTime'<~Time> - time instance was launched
+        #           * 'monitoring'<~Hash>:
+        #             * 'state'<~Boolean - state of monitoring
+        #           * 'placement'<~Hash>:
+        #             * 'availabilityZone'<~String> - Availability zone of the instance
+        #           * 'productCodes'<~Array> - Product codes for the instance
+        #           * 'privateDnsName'<~String> - private dns name, blank until instance is running
+        #           * 'privateIpAddress'<~String> - private ip address assigned to instance
+        #           * 'rootDeviceName'<~String> - specifies how the root device is exposed to the instance
+        #           * 'rootDeviceType'<~String> - root device type used by AMI in [ebs, instance-store]
+        #           * 'ramdiskId'<~String> - Id of ramdisk used to launch instance
+        #           * 'reason'<~String> - reason for most recent state transition, or blank
+        def describe_instances(instance_id = [])
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'DescribeInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_instances(instance_id = [])
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if instance_id != []
+            instance_set = @data[:instances].reject {|key,value| !instance_id.include?(key)}.values
+          else
+            instance_set = @data[:instances].values
+          end
+
+          if instance_id.length == 0 || instance_id.length == instance_set.length
+            response.status = 200
+            reservation_set = {}
+
+            instance_set.each do |instance|
+              case instance['instanceState']['name']
+              when 'pending'
+                if Time.now - instance['launchTime'] > Fog::Mock.delay
+                  instance['ipAddress']         = Fog::AWS::Mock.ip_address
+                  instance['dnsName']           = Fog::AWS::Mock.dns_name_for(instance['ipAddress'])
+                  instance['privateIpAddress']  = Fog::AWS::Mock.ip_address
+                  instance['privateDnsName']    = Fog::AWS::Mock.private_dns_name_for(instance['privateIpAddress'])
+                  instance['instanceState']     = { 'code' => 16, 'name' => 'running' }
+                end
+              when 'rebooting'
+                instance['instanceState'] = { 'code' => 16, 'name' => 'running' }
+              when 'shutting-down'
+                if Time.now - @data[:deleted_at][instance['instanceId']] > Fog::Mock.delay * 2
+                  @data[:deleted_at].delete(instance['instanceId'])
+                  @data[:instances].delete(instance['instanceId'])
+                elsif Time.now - @data[:deleted_at][instance['instanceId']] > Fog::Mock.delay
+                  instance['instanceState'] = { 'code' => 48, 'name' => 'terminating' }
+                end
+              when 'terminating'
+                if Time.now - @data[:deleted_at][instance['instanceId']] > Fog::Mock.delay
+                  @data[:deleted_at].delete(instance['instanceId'])
+                  @data[:instances].delete(instance['instanceId'])
+                end
+              end
+
+              if @data[:instances][instance['instanceId']]
+                reservation_set[instance['reservationId']] ||= {
+                  'groupSet'      => instance['groupSet'],
+                  'instancesSet'  => [],
+                  'ownerId'       => instance['ownerId'],
+                  'reservationId' => instance['reservationId']
+                }
+                reservation_set[instance['reservationId']]['instancesSet'] << instance.reject{|key,value| !['amiLaunchIndex', 'architecture', 'blockDeviceMapping', 'dnsName', 'imageId', 'instanceId', 'instanceState', 'instanceType', 'ipAddress', 'kernelId', 'keyName', 'launchTime', 'monitoring', 'placement', 'privateDnsName', 'privateIpAddress', 'productCodes', 'ramdiskId', 'reason', 'rootDeviceType'].include?(key)}
+              end
+            end
+
+            response.body = {
+              'requestId'       => Fog::AWS::Mock.request_id,
+              'reservationSet' => reservation_set.values
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID #{instance_id.inspect} does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_key_pairs.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_key_pairs.rb
new file mode 100644
index 0000000..957fc51
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_key_pairs.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_key_pairs'
+
+        # Describe all or specified key pairs
+        #
+        # ==== Parameters
+        # * key_name<~Array>:: List of key names to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'keySet'<~Array>:
+        #       * 'keyName'<~String> - Name of key
+        #       * 'keyFingerprint'<~String> - Fingerprint of key
+        def describe_key_pairs(key_name = [])
+          params = AWS.indexed_param('KeyName', key_name)
+          request({
+            'Action'    => 'DescribeKeyPairs',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeKeyPairs.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_key_pairs(key_name = [])
+          response = Excon::Response.new
+          key_name = [*key_name]
+          if key_name != []
+            key_set = @data[:key_pairs].reject {|key, value| !key_name.include?(key)}.values
+          else
+            key_set = @data[:key_pairs].values
+          end
+          if key_name.length == 0 || key_name.length == key_set.length
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'keySet'    => key_set.map do |key|
+                key.reject {|key,value| !['keyFingerprint', 'keyName'].include?(key)}
+              end
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The key pair #{key_name.inspect} does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_regions.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_regions.rb
new file mode 100644
index 0000000..d2cda7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_regions.rb
@@ -0,0 +1,61 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_regions'
+
+        # Describe all or specified regions
+        #
+        # ==== Params
+        # * region_name<~String> - List of regions to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'regionInfo'<~Array>:
+        #       * 'regionName'<~String> - Name of region
+        #       * 'regionEndpoint'<~String> - Service endpoint for region
+        def describe_regions(region_name = [])
+          params = AWS.indexed_param('RegionName', region_name)
+          request({
+            'Action'    => 'DescribeRegions',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeRegions.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_regions(region_name = [])
+          response = Excon::Response.new
+          region_name = [*region_name]
+          regions = {
+            'eu-west-1' => {"regionName"=>"eu-west-1", "regionEndpoint"=>"eu-west-1.ec2.amazonaws.com"},
+            'us-east-1' => {"regionName"=>"us-east-1", "regionEndpoint"=>"us-east-1.ec2.amazonaws.com"}
+          }
+          if region_name != []
+            region_info = regions.reject {|key, value| !region_name.include?(key)}.values
+          else
+            region_info = regions.values
+          end
+
+          if region_name.length == 0 || region_name.length == region_info.length
+            response.status = 200
+            response.body = {
+              'requestId'   => Fog::AWS::Mock.request_id,
+              'regionInfo'  => region_info
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidParameterValue => Invalid region: #{region_name.inspect}")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_reserved_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_reserved_instances.rb
new file mode 100644
index 0000000..6c2a259
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_reserved_instances.rb
@@ -0,0 +1,48 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_reserved_instances'
+
+        # Describe all or specified reserved instances
+        #
+        # ==== Parameters
+        # * reserved_instances_id<~Array> - List of reserved instance ids to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservedInstancesSet'<~Array>:
+        #       * 'availabilityZone'<~String> - availability zone of the instance
+        #       * 'duration'<~Integer> - duration of reservation, in seconds
+        #       * 'fixedPrice'<~Float> - purchase price of reserved instance
+        #       * 'instanceType'<~String> - type of instance
+        #       * 'instanceCount'<~Integer> - number of reserved instances
+        #       * 'productDescription'<~String> - reserved instance description
+        #       * 'reservedInstancesId'<~String> - id of the instance
+        #       * 'start'<~Time> - start time for reservation
+        #       * 'state'<~String> - state of reserved instance purchase, in .[pending-payment, active, payment-failed, retired]
+        #       * 'usagePrice"<~Float> - usage price of reserved instances, per hour
+        def describe_reserved_instances(reserved_instances_id = [])
+          params = AWS.indexed_param('ReservedInstancesId', reserved_instances_id)
+          request({
+            'Action'    => 'DescribeReservedInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeReservedInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_reserved_instances(reserved_instances_id = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_security_groups.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_security_groups.rb
new file mode 100644
index 0000000..e485946
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_security_groups.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_security_groups'
+
+        # Describe all or specified security groups
+        #
+        # ==== Parameters
+        # * group_name<~Array> - List of groups to describe, defaults to all
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'securityGroupInfo'<~Array>:
+        #       * 'groupDescription'<~String> - Description of security group
+        #       * 'groupName'<~String> - Name of security group
+        #       * 'ipPermissions'<~Array>:
+        #         * 'fromPort'<~Integer> - Start of port range (or -1 for ICMP wildcard)
+        #         * 'groups'<~Array>:
+        #           * 'groupName'<~String> - Name of security group
+        #           * 'userId'<~String> - AWS User Id of account
+        #         * 'ipProtocol'<~String> - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #         * 'ipRanges'<~Array>:
+        #           * 'cidrIp'<~String> - CIDR range
+        #         * 'toPort'<~Integer> - End of port range (or -1 for ICMP wildcard)
+        #       * 'ownerId'<~String> - AWS Access Key Id of the owner of the security group
+        def describe_security_groups(group_name = [])
+          params = AWS.indexed_param('GroupName', group_name)
+          request({
+            'Action'    => 'DescribeSecurityGroups',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeSecurityGroups.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_security_groups(group_name = [])
+          response = Excon::Response.new
+          group_name = [*group_name]
+          if group_name != []
+            security_group_info = @data[:security_groups].reject {|key, value| !group_name.include?(key)}.values
+          else
+            security_group_info = @data[:security_groups].values
+          end
+          if group_name.length == 0 || group_name.length == security_group_info.length
+            response.status = 200
+            response.body = {
+              'requestId'         => Fog::AWS::Mock.request_id,
+              'securityGroupInfo' => security_group_info
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group #{group_name.inspect} does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_snapshots.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_snapshots.rb
new file mode 100644
index 0000000..da5b11b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_snapshots.rb
@@ -0,0 +1,80 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_snapshots'
+
+        # Describe all or specified snapshots
+        #
+        # ==== Parameters
+        # * snapshot_id<~Array> - List of snapshots to describe, defaults to all
+        # * options<~Array>:
+        #   * 'Owner'<~String> - Owner of snapshot in ['self', 'amazon', account_id]
+        #   * 'RestorableBy'<~String> - Account id of user who can create volumes from this snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'snapshotSet'<~Array>:
+        #       * 'progress'<~String>: The percentage progress of the snapshot
+        #       * 'snapshotId'<~String>: Id of the snapshot
+        #       * 'startTime'<~Time>: Timestamp of when snapshot was initiated
+        #       * 'status'<~String>: Snapshot state, in ['pending', 'completed']
+        #       * 'volumeId'<~String>: Id of volume that snapshot contains
+        def describe_snapshots(snapshot_id = [], options = {})
+          options['Owner'] ||= 'self'
+          options.merge!(AWS.indexed_param('SnapshotId', snapshot_id))
+          request({
+            'Action'    => 'DescribeSnapshots',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeSnapshots.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def describe_snapshots(snapshot_id = [])
+          response = Excon::Response.new
+          snapshot_id = [*snapshot_id]
+          if snapshot_id != []
+            snapshot_set = @data[:snapshots].reject {|key,value| !snapshot_id.include?(key)}.values
+          else
+            snapshot_set = @data[:snapshots].values
+          end
+
+          if snapshot_id.length == 0 || snapshot_id.length == snapshot_set.length
+            snapshot_set.each do |snapshot|
+              case snapshot['status']
+              when 'in progress', 'pending'
+                if Time.now - snapshot['startTime'] > Fog::Mock.delay * 2
+                  snapshot['progress']  = '100%'
+                  snapshot['status']    = 'completed'
+                elsif Time.now - snapshot['startTime'] > Fog::Mock.delay
+                  snapshot['progress']  = '50%'
+                  snapshot['status']    = 'in progress'
+                else
+                  snapshot['progress']  = '0%'
+                  snapshot['status']    = 'in progress'
+                end
+              end
+            end
+
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'snapshotSet' => snapshot_set
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The snapshot #{snapshot_id.inspect} does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_volumes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_volumes.rb
new file mode 100644
index 0000000..9c4b8fa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/describe_volumes.rb
@@ -0,0 +1,86 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_volumes'
+
+        # Describe all or specified volumes.
+        #
+        # ==== Parameters
+        # * volume_id<~Array> - List of volumes to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'volumeSet'<~Array>:
+        #       * 'availabilityZone'<~String> - Availability zone for volume
+        #       * 'createTime'<~Time> - Timestamp for creation
+        #       * 'size'<~Integer> - Size in GiBs for volume
+        #       * 'snapshotId'<~String> - Snapshot volume was created from, if any
+        #       * 'status'<~String> - State of volume
+        #       * 'volumeId'<~String> - Reference to volume
+        #       * 'attachmentSet'<~Array>:
+        #         * 'attachmentTime'<~Time> - Timestamp for attachment
+        #         * 'device'<~String> - How value is exposed to instance
+        #         * 'instanceId'<~String> - Reference to attached instance
+        #         * 'status'<~String> - Attachment state
+        #         * 'volumeId'<~String> - Reference to volume
+        def describe_volumes(volume_id = [])
+          params = AWS.indexed_param('VolumeId', volume_id)
+          request({
+            'Action'    => 'DescribeVolumes',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeVolumes.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_volumes(volume_id = [])
+          response = Excon::Response.new
+          volume_id = [*volume_id]
+          if volume_id != []
+            volume_set = @data[:volumes].reject {|key,value| !volume_id.include?(key)}.values
+          else
+            volume_set = @data[:volumes].values
+          end
+
+          if volume_id.length == 0 || volume_id.length == volume_set.length
+            volume_set.each do |volume|
+              case volume['status']
+              when 'attaching'
+                if Time.now - volume['attachmentSet'].first['attachTime'] > Fog::Mock.delay
+                  volume['attachmentSet'].first['status'] = 'in-use'
+                  volume['status'] = 'in-use'
+                end
+              when 'creating'
+                if Time.now - volume['createTime'] > Fog::Mock.delay
+                  volume['status'] = 'available'
+                end
+              when 'deleting'
+                if Time.now - @data[:deleted_at][volume['volumeId']] > Fog::Mock.delay
+                  @data[:deleted_at].delete(volume['volumeId'])
+                  @data[:volumes].delete(volume['volumeId'])
+                end
+              end
+            end
+
+            volume_set = volume_set.reject {|volume| !@data[:volumes][volume['volumeId']]}
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'volumeSet' => volume_set
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume #{volume_id.inspect} does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/detach_volume.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/detach_volume.rb
new file mode 100644
index 0000000..7f572da
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/detach_volume.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/detach_volume'
+
+        # Detach an Amazon EBS volume from a running instance
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of amazon EBS volume to associate with instance
+        # * options<~Hash>:
+        #   * 'Device'<~String> - Specifies how the device is exposed to the instance (e.g. "/dev/sdh")
+        #   * 'Force'<~Boolean> - If true forces detach, can cause data loss/corruption
+        #   * 'InstanceId'<~String> - Id of instance to associate volume with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'attachTime'<~Time> - Time of attachment was initiated at
+        #     * 'device'<~String> - Device as it is exposed to the instance
+        #     * 'instanceId'<~String> - Id of instance for volume
+        #     * 'requestId'<~String> - Id of request
+        #     * 'status'<~String> - Status of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        def detach_volume(volume_id, options = {})
+          request({
+            'Action'    => 'DetachVolume',
+            'VolumeId'  => volume_id,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DetachVolume.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def detach_volume(volume_id, options = {})
+          response = Excon::Response.new
+          response.status = 200
+          if (volume = @data[:volumes][volume_id]) && !volume['attachmentSet'].empty?
+            data = volume['attachmentSet'].pop
+            volume['status'] = 'available'
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/disassociate_address.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/disassociate_address.rb
new file mode 100644
index 0000000..db013b7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/disassociate_address.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Disassociate an elastic IP address from its instance (if any)
+        #
+        # ==== Parameters
+        # * public_ip<~String> - Public ip to assign to instance
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def disassociate_address(public_ip)
+          request(
+            'Action'    => 'DisassociateAddress',
+            'PublicIp'  => public_ip,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def disassociate_address(public_ip)
+          response = Excon::Response.new
+          response.status = 200
+          if address = @data[:addresses][public_ip]
+            instance_id = address['instanceId']
+            instance = @data[:instances][instance_id]
+            instance['ipAddress']         = instance['originalIpAddress']
+            instance['dnsName']           = Fog::AWS::Mock.dns_name_for(instance['ipAddress'])
+            address['instanceId'] = nil
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/get_console_output.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/get_console_output.rb
new file mode 100644
index 0000000..f47fa7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/get_console_output.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/get_console_output'
+
+        # Retrieve console output for specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to get console output from
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'instanceId'<~String> - Id of instance
+        #     * 'output'<~String> - Console output
+        #     * 'requestId'<~String> - Id of request
+        #     * 'timestamp'<~Time> - Timestamp of last update to output
+        def get_console_output(instance_id)
+          request(
+            'Action'      => 'GetConsoleOutput',
+            'InstanceId'  => instance_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::GetConsoleOutput.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_console_output(instance_id)
+          response = Excon::Response.new
+          if instance = @data[:instances][instance_id]
+            response.status = 200
+            response.body = {
+              'instanceId'    => instance_id,
+              'output'        => nil,
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'timestamp'     => Time.now
+            }
+            response
+          else;
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/import_key_pair.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/import_key_pair.rb
new file mode 100644
index 0000000..1210a47
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/import_key_pair.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/import_key_pair'
+
+        # Import an existing public key to create a new key pair
+        #
+        # ==== Parameters
+        # * key_name<~String> - Unique name for key pair.
+        # * public_key_material<~String> - RSA public key
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'keyFingerprint'<~String> - SHA-1 digest of DER encoded private key
+        #     * 'keyName'<~String> - Name of key
+        #     * 'requestId'<~String> - Id of request
+        def import_key_pair(key_name, public_key_material)
+          request(
+            'Action'  => 'ImportKeyPair',
+            'KeyName' => key_name,
+            'PublicKeyMaterial' => Base64::encode64(public_key_material),
+            :parser   => Fog::Parsers::AWS::Compute::ImportKeyPair.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def import_key_pair(key_name, public_key_material)
+          response = Excon::Response.new
+          unless @data[:key_pairs][key_name]
+            response.status = 200
+            data = {
+              'keyFingerprint'  => Fog::AWS::Mock.key_fingerprint,
+              'keyName'         => key_name
+            }
+            @data[:key_pairs][key_name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidKeyPair.Duplicate => The keypair '#{key_name}' already exists.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/modify_image_attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/modify_image_attributes.rb
new file mode 100644
index 0000000..97cf25d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/modify_image_attributes.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Modify image attributes
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of machine image to modify
+        # * attribute<~String> - Attribute to modify, in ['launchPermission', 'productCodes']
+        # * operation_type<~String> - Operation to perform on attribute, in ['add', 'remove']
+        #
+        def modify_image_attributes(image_id, attribute, operation_type, options = {})
+          params = {}
+          params.merge!(AWS.indexed_param('UserId', options['UserId']))
+          params.merge!(AWS.indexed_param('UserGroup', options['UserGroup']))
+          params.merge!(AWS.indexed_param('ProductCode', options['ProductCode']))
+          request({
+            'Action'        => 'ModifyImageAttribute',
+            'Attribute'     => attribute,
+            'ImageId'       => image_id,
+            'OperationType' => operation_type,
+            :idempotent     => true,
+            :parser         => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def modify_image_attributes(image_id, attribute, operation_type, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/modify_snapshot_attribute.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/modify_snapshot_attribute.rb
new file mode 100644
index 0000000..24ac163
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/modify_snapshot_attribute.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Modify snapshot attributes
+        #
+        # ==== Parameters
+        # * snapshot_id<~String> - Id of snapshot to modify
+        # * attribute<~String> - Attribute to modify, in ['createVolumePermission']
+        # * operation_type<~String> - Operation to perform on attribute, in ['add', 'remove']
+        #
+        def modify_snapshot_attribute(snapshot_id, attribute, operation_type, options = {})
+          params = {}
+          params.merge!(AWS.indexed_param('UserId', options['UserId']))
+          params.merge!(AWS.indexed_param('UserGroup', options['UserGroup']))
+          request({
+            'Action'        => 'ModifySnapshotAttribute',
+            'Attribute'     => attribute,
+            'SnapshotId'    => snapshot_id,
+            'OperationType' => operation_type,
+            :idempotent     => true,
+            :parser         => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def modify_snapshot_attribute(snapshot_id, attribute, operation_type, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/reboot_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/reboot_instances.rb
new file mode 100644
index 0000000..7c3f59a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/reboot_instances.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Reboot specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Ids of instances to reboot
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def reboot_instances(instance_id = [])
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'RebootInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def reboot_instances(instance_id = [])
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if (@data[:instances].keys & instance_id).length == instance_id.length
+            for instance_id in instance_id
+              @data[:instances][instance_id]['status'] = 'rebooting'
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID #{instance_id.inspect} does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/register_image.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/register_image.rb
new file mode 100644
index 0000000..4299680
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/register_image.rb
@@ -0,0 +1,89 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/register_image'
+
+        # register an image
+        #
+        # ==== Parameters
+        # * Name<~String> - Name of the AMI to be registered
+        # * Description<~String> - AMI description
+        # * Location<~String> - S3 manifest location (for S3 backed AMIs)
+        # or
+        # * RootDeviceName<~String> - Name of Root Device (for EBS snapshot backed AMIs)
+        # * BlockDevices<~Array>:
+        #   * BlockDeviceOptions<~Hash>:
+        #     * DeviceName<~String> - Name of the Block Device
+        #     * VirtualName<~String> - Name of the Virtual Device
+        #     * SnapshotId<~String> - id of the EBS Snapshot
+        #     * VolumeSize<~Integer> - Size of the snapshot (optional)
+        #     * NoDevice<~Boolean> - Do not use an ebs device (def: true)
+        #     * DeleteOnTermation<~Boolean> - Delete EBS volume on instance term (def: true)
+        # * Options<~Hash>:
+        #   * Architecture<~String> - i386 or x86_64
+        #   * KernelId<~String> - kernelId
+        #   * RamdiskId<~String> - ramdiskId
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'imageId'<~String> - Id of newly created AMI
+
+        def register_image(name, description, location, block_devices=[], options={})
+          common_options = {
+            'Action'      => 'RegisterImage',
+            'Name'        => name,
+            'Description' => description,
+            :parser       => Fog::Parsers::AWS::Compute::RegisterImage.new
+          }
+
+          # This determines if we are doing a snapshot or a S3 backed AMI.
+          if(location =~ /^\/dev\/sd[a-p]\d{0,2}$/)
+            common_options['RootDeviceName'] = location
+          else
+            common_options['ImageLocation'] = location
+          end
+
+          bdi = 0
+          block_devices.each do |bd|
+            bdi += 1
+            ["DeviceName","VirtualName"].each do |n|
+              common_options["BlockDeviceMapping.#{bdi}.#{n}"] = bd["#{n}"] if bd["#{n}"]
+            end
+            ["SnapshotId","VolumeSize","NoDevice","DeleteOnTermination"].each do |n|
+              common_options["BlockDeviceMapping.#{bdi}.Ebs.#{n}"] = bd["#{n}"] if bd["#{n}"]
+            end
+
+          end
+
+          request(common_options.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def register_image(name, description, location, block_devices=[], options={})
+          response = Excon::Response.new
+          if !name.empty?
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'imageId' => Fog::AWS::Mock.image_id
+            }
+            response
+          else
+            message = 'MissingParameter => '
+            if name.empty?
+              message << 'The request must contain the parameter name'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/release_address.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/release_address.rb
new file mode 100644
index 0000000..38dc3de
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/release_address.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Release an elastic IP address.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def release_address(public_ip)
+          request(
+            'Action'    => 'ReleaseAddress',
+            'PublicIp'  => public_ip,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def release_address(public_ip)
+          response = Excon::Response.new
+          if (address = @data[:addresses].delete(public_ip))
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/revoke_security_group_ingress.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/revoke_security_group_ingress.rb
new file mode 100644
index 0000000..505c734
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/revoke_security_group_ingress.rb
@@ -0,0 +1,74 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Remove permissions from a security group
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'GroupName'<~String> - Name of group
+        #   * 'SourceSecurityGroupName'<~String> - Name of security group to authorize
+        #   * 'SourceSecurityGroupOwnerId'<~String> - Name of owner to authorize
+        #   or
+        #   * 'CidrIp' - CIDR range
+        #   * 'FromPort' - Start of port range (or -1 for ICMP wildcard)
+        #   * 'GroupName' - Name of group to modify
+        #   * 'IpProtocol' - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #   * 'ToPort' - End of port range (or -1 for ICMP wildcard)
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def revoke_security_group_ingress(options = {})
+          request({
+            'Action'    => 'RevokeSecurityGroupIngress',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def revoke_security_group_ingress(options = {})
+          response = Excon::Response.new
+          group = @data[:security_groups][options['GroupName']]
+          if group
+            if options['GroupName'] && options['SourceSecurityGroupName'] && options['SourceSecurityGroupOwnerId']
+              group['ipPermissions'].delete_if {|permission|
+                permission['groups'].first['groupName'] == options['GroupName']
+              }
+            else
+              ingress = group['ipPermissions'].select {|permission|
+                permission['fromPort']    == options['FromPort'] &&
+                permission['ipProtocol']  == options['IpProtocol'] &&
+                permission['toPort']      == options['ToPort'] &&
+                (
+                  permission['ipRanges'].empty? ||
+                  (
+                    permission['ipRanges'].first &&
+                    permission['ipRanges'].first['cidrIp'] == options['CidrIp']
+                  )
+                )
+              }.first
+              group['ipPermissions'].delete(ingress)
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{options['GroupName']}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/run_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/run_instances.rb
new file mode 100644
index 0000000..2f6ea1d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/run_instances.rb
@@ -0,0 +1,160 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/run_instances'
+
+        # Launch specified instances
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of machine image to load on instances
+        # * min_count<~Integer> - Minimum number of instances to launch. If this
+        #   exceeds the count of available instances, no instances will be
+        #   launched.  Must be between 1 and maximum allowed for your account
+        #   (by default the maximum for an account is 20)
+        # * max_count<~Integer> - Maximum number of instances to launch. If this
+        #   exceeds the number of available instances, the largest possible
+        #   number of instances above min_count will be launched instead. Must
+        #   be between 1 and maximum allowed for you account
+        #   (by default the maximum for an account is 20)
+        # * options<~Hash>:
+        #   * 'Placement.AvailabilityZone'<~String> - Placement constraint for instances
+        #   * 'BlockDeviceMapping'<~Array>: array of hashes
+        #     * 'DeviceName'<~String> - where the volume will be exposed to instance
+        #     * 'VirtualName'<~String> - volume virtual device name
+        #     * 'Ebs.SnapshotId'<~String> - id of snapshot to boot volume from
+        #     * 'Ebs.VolumeSize'<~String> - size of volume in GiBs required unless snapshot is specified
+        #     * 'Ebs.DeleteOnTermination'<~String> - specifies whether or not to delete the volume on instance termination
+        #   * 'ClientToken'<~String> - unique case-sensitive token for ensuring idempotency
+        #   * 'SecurityGroup'<~Array> or <~String> - Name of security group(s) for instances (you must omit this parameter if using Virtual Private Clouds)
+        #   * 'InstanceInitiatedShutdownBehaviour'<~String> - specifies whether volumes are stopped or terminated when instance is shutdown
+        #   * 'InstanceType'<~String> - Type of instance to boot. Valid options
+        #     in ['m1.small', 'm1.large', 'm1.xlarge', 'c1.medium', 'c1.xlarge', 'm2.2xlarge', 'm2.4xlarge']
+        #     default is 'm1.small'
+        #   * 'KernelId'<~String> - Id of kernel with which to launch
+        #   * 'KeyName'<~String> - Name of a keypair to add to booting instances
+        #   * 'Monitoring.Enabled'<~Boolean> - Enables monitoring, defaults to 
+        #     disabled
+        #   * 'RamdiskId'<~String> - Id of ramdisk with which to launch
+        #   * 'UserData'<~String> -  Additional data to provide to booting instances
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'groupSet'<~Array>: groups the instances are members in
+        #       * 'groupName'<~String> - Name of group
+        #     * 'instancesSet'<~Array>: returned instances
+        #       * instance<~Hash>:
+        #         * 'amiLaunchIndex'<~Integer> - reference to instance in launch group
+        #         * 'architecture'<~String> - architecture of image in [i386, x86_64]
+        #         * 'blockDeviceMapping'<~Array>
+        #           * 'attachTime'<~Time> - time of volume attachment
+        #           * 'deleteOnTermination'<~Boolean> - whether or not to delete volume on termination
+        #           * 'deviceName'<~String> - specifies how volume is exposed to instance
+        #           * 'status'<~String> - status of attached volume
+        #           * 'volumeId'<~String> - Id of attached volume
+        #         * 'dnsName'<~String> - public dns name, blank until instance is running
+        #         * 'imageId'<~String> - image id of ami used to launch instance
+        #         * 'instanceId'<~String> - id of the instance
+        #         * 'instanceState'<~Hash>:
+        #           * 'code'<~Integer> - current status code
+        #           * 'name'<~String> - current status name
+        #         * 'instanceType'<~String> - type of instance
+        #         * 'ipAddress'<~String> - public ip address assigned to instance
+        #         * 'kernelId'<~String> - Id of kernel used to launch instance
+        #         * 'keyName'<~String> - name of key used launch instances or blank
+        #         * 'launchTime'<~Time> - time instance was launched
+        #         * 'monitoring'<~Hash>:
+        #           * 'state'<~Boolean - state of monitoring
+        #         * 'placement'<~Hash>:
+        #           * 'availabilityZone'<~String> - Availability zone of the instance
+        #         * 'privateDnsName'<~String> - private dns name, blank until instance is running
+        #         * 'privateIpAddress'<~String> - private ip address assigned to instance
+        #         * 'productCodes'<~Array> - Product codes for the instance
+        #         * 'ramdiskId'<~String> - Id of ramdisk used to launch instance
+        #         * 'reason'<~String> - reason for most recent state transition, or blank
+        #         * 'rootDeviceName'<~String> - specifies how the root device is exposed to the instance
+        #         * 'rootDeviceType'<~String> - root device type used by AMI in [ebs, instance-store]
+        #     * 'ownerId'<~String> - Id of owner
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservationId'<~String> - Id of reservation
+        def run_instances(image_id, min_count, max_count, options = {})
+          if block_device_mapping = options.delete('BlockDeviceMapping')
+            block_device_mapping.each_with_index do |mapping, index|
+              for key, value in mapping
+                options.merge!({ format("BlockDeviceMapping.%d.#{key}", index) => value })
+              end
+            end
+          end
+          if security_groups = [*options.delete('SecurityGroup')]
+            options.merge!(AWS.indexed_param('SecurityGroup', security_groups))
+          end
+          if options['UserData']
+            options['UserData'] = Base64.encode64(options['UserData'])
+          end
+          request({
+            'Action'    => 'RunInstances',
+            'ImageId'   => image_id,
+            'MinCount'  => min_count,
+            'MaxCount'  => max_count,
+            :parser     => Fog::Parsers::AWS::Compute::RunInstances.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def run_instances(image_id, min_count, max_count, options = {})
+          response = Excon::Response.new
+          response.status = 200
+
+          group_set = [ (options['GroupId'] || 'default') ]
+          instances_set = []
+          reservation_id = Fog::AWS::Mock.reservation_id
+
+          min_count.times do |i|
+            instance_id = Fog::AWS::Mock.instance_id
+            instance = {
+              'amiLaunchIndex'      => i,
+              'blockDeviceMapping'  => [],
+              'dnsName'             => nil,
+              'imageId'             => image_id,
+              'instanceId'          => instance_id,
+              'instanceState'       => { 'code' => 0, 'name' => 'pending' },
+              'instanceType'        => options['InstanceType'] || 'm1.small',
+              'kernelId'            => options['KernelId'] || Fog::AWS::Mock.kernel_id,
+              # 'keyName'             => options['KeyName'],
+              'launchTime'          => Time.now,
+              'monitoring'          => { 'state' => options['Monitoring.Enabled'] || false },
+              'placement'           => { 'availabilityZone' => options['Placement.AvailabilityZone'] || Fog::AWS::Mock.availability_zone },
+              'privateDnsName'      => nil,
+              'productCodes'        => [],
+              'ramdiskId'           => options['RamdiskId'] || Fog::AWS::Mock.ramdisk_id,
+              'reason'              => nil,
+              'rootDeviceType'      => 'instance-store'
+            }
+            instances_set << instance
+            @data[:instances][instance_id] = instance.merge({
+              'architecture'        => 'i386',
+              'groupSet'            => group_set,
+              'ownerId'             => @owner_id,
+              'privateIpAddress'    => nil,
+              'reservationId'       => reservation_id,
+            })
+          end
+          response.body = {
+            'groupSet'      => group_set,
+            'instancesSet'  => instances_set,
+            'ownerId'       => @owner_id,
+            'requestId'     => Fog::AWS::Mock.request_id,
+            'reservationId' => reservation_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/start_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/start_instances.rb
new file mode 100644
index 0000000..f6f21e9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/start_instances.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/start_stop_instances'
+
+        # Start specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Id of instance to start
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * TODO: fill in the blanks
+        def start_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'StartInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::StartStopInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def start_instances(instance_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/stop_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/stop_instances.rb
new file mode 100644
index 0000000..eca2d05
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/stop_instances.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/start_stop_instances'
+
+        # Stop specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Id of instance to start
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * TODO: fill in the blanks
+        def stop_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'StopInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::StartStopInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def stop_instances(instance_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/terminate_instances.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/terminate_instances.rb
new file mode 100644
index 0000000..7d4afab
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/compute/terminate_instances.rb
@@ -0,0 +1,94 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/terminate_instances'
+
+        # Terminate specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Ids of instances to terminates
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'instancesSet'<~Array>:
+        #       * 'instanceId'<~String> - id of the terminated instance
+        #       * 'previousState'<~Hash>: previous state of instance
+        #         * 'code'<~Integer> - previous status code
+        #         * 'name'<~String> - name of previous state
+        #       * 'shutdownState'<~Hash>: shutdown state of instance
+        #         * 'code'<~Integer> - current status code
+        #         * 'name'<~String> - name of current state
+        def terminate_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'TerminateInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::TerminateInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def terminate_instances(instance_id)
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if (@data[:instances].keys & instance_id).length == instance_id.length
+            response.body = {
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'instancesSet'  => []
+            }
+            response.status = 200
+            for id in instance_id
+              instance = @data[:instances][id]
+              @data[:deleted_at][id] = Time.now
+              code = case instance['instanceState']['name']
+              when 'pending'
+                0
+              when 'running'
+                16
+              when 'shutting-down'
+                32
+              when 'terminated'
+                48
+              when 'stopping'
+                64
+              when 'stopped'
+                80
+              end
+              state = { 'name' => 'shutting-down', 'code' => 32}
+              response.body['instancesSet'] << {
+                'instanceId'    => id,
+                'previousState' => instance['instanceState'],
+                'currentState'  => state
+              }
+              instance['instanceState'] = state
+            end
+
+            describe_addresses.body['addressesSet'].each do |address|
+              if instance_id.include?(address['instanceId'])
+                disassociate_address(address['publicIp'])
+              end
+            end
+
+            describe_volumes.body['volumeSet'].each do |volume|
+              if volume['attachmentSet'].first && instance_id.include?(volume['attachmentSet'].first['instanceId'])
+                detach_volume(volume['volumeId'])
+              end
+            end
+
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/create_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/create_load_balancer.rb
new file mode 100644
index 0000000..6b80113
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/create_load_balancer.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/create_load_balancer'
+
+        # Create a new Elastic Load Balancer
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones for the ELB
+        # * lb_name<~String> - Name for the new ELB -- must be unique
+        # * listeners<~Array> - Array of Hashes describing ELB listeners to assign to the ELB
+        #   * 'Protocol'<~String> - Protocol to use. Either HTTP or TCP.
+        #   * 'LoadBalancerPort'<~Integer> - The port that the ELB will listen to for outside traffic
+        #   * 'InstancePort'<~Integer> - The port on the instance that the ELB will forward traffic to
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'CreateLoadBalancerResult'<~Hash>:
+        #       * 'DNSName'<~String> - DNS name for the newly created ELB
+        def create_load_balancer(availability_zones, lb_name, listeners)
+          params = ELB.indexed_param('AvailabilityZones.member', [*availability_zones])
+
+          listener_protocol = []
+          listener_lb_port = []
+          listener_instance_port = []
+          listeners.each do |listener|
+            listener_protocol.push(listener['Protocol'])
+            listener_lb_port.push(listener['LoadBalancerPort'])
+            listener_instance_port.push(listener['InstancePort'])
+          end
+
+          params.merge!(AWS.indexed_param('Listeners.member.%d.Protocol', listener_protocol))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.LoadBalancerPort', listener_lb_port))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.InstancePort', listener_instance_port))
+
+          request({
+            'Action'           => 'CreateLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::CreateLoadBalancer.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def create_load_balancer(availability_zones, lb_name, listeners)
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/delete_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/delete_load_balancer.rb
new file mode 100644
index 0000000..b4ca1f7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/delete_load_balancer.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/delete_load_balancer'
+
+        # Delete an existing Elastic Load Balancer
+        #
+        # Note that this API call, as defined by Amazon, is idempotent.
+        # That is, it will not return an error if you try to delete an
+        # ELB that does not exist.
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB to be deleted
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DeleteLoadBalancerResponse'<~nil>
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def delete_load_balancer(lb_name)
+          request({
+            'Action'           => 'DeleteLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DeleteLoadBalancer.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_load_balancer(lb_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
new file mode 100644
index 0000000..56f08b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/deregister_instances_from_load_balancer'
+
+        # Deregister an instance from an existing ELB
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - List of instance IDs to remove from ELB
+        # * lb_name<~String> - Load balancer to remove instances from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DeregisterInstancesFromLoadBalancerResult'<~Hash>:
+        #       * 'Instances'<~Array> - array of hashes describing instances currently enabled
+        #         * 'InstanceId'<~String>
+        def deregister_instances_from_load_balancer(instance_ids, lb_name)
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'DeregisterInstancesFromLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DeregisterInstancesFromLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :deregister_instances :deregister_instances_from_load_balancer
+
+      end
+
+      class Mock
+
+        def deregister_instances_from_load_balancer(instance_ids, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :deregister_instances :deregister_instances_from_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/describe_instance_health.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/describe_instance_health.rb
new file mode 100644
index 0000000..01dbf0b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/describe_instance_health.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/describe_instance_health'
+
+        # Get health status for one or more instances on an existing ELB
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Load balancer to check instances health on
+        # * instance_ids<~Array> - Optional list of instance IDs to check
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DescribeInstanceHealthResult'<~Hash>:
+        #       * 'InstanceStates'<~Array> - array of hashes describing instance health
+        #         * 'Description'<~String>
+        #         * 'State'<~String>
+        #         * 'InstanceId'<~String>
+        #         * 'ReasonCode'<~String>
+        def describe_instance_health(lb_name, instance_ids = [])
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'DescribeInstanceHealth',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DescribeInstanceHealth.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_instance_health(lb_name, instance_ids = [])
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/describe_load_balancers.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/describe_load_balancers.rb
new file mode 100644
index 0000000..1524926
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/describe_load_balancers.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/describe_load_balancers'
+
+        # Describe all or specified load balancers
+        #
+        # ==== Parameters
+        # * lb_name<~Array> - List of load balancer names to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DescribeLoadBalancersResult'<~Hash>:
+        #       * 'LoadBalancerDescriptions'<~Array>
+        #         * 'LoadBalancerName'<~String> - name of load balancer
+        #         * 'DNSName'<~String> - external DNS name of load balancer
+        #         * 'CreatedTime'<~Time> - time load balancer was created
+        #         * 'ListenerDescriptions'<~Array>
+        #           * 'PolicyNames'<~Array> - list of policies enabled
+        #           * 'Listener'<~Hash>:
+        #             * 'InstancePort'<~Integer> - port on instance that requests are sent to
+        #             * 'Protocol'<~String> - transport protocol used for routing in [TCP, HTTP]
+        #             * 'LoadBalancerPort'<~Integer> - port that load balancer listens on for requests
+        #         * 'HealthCheck'<~Hash>:
+        #           * 'HealthyThreshold'<~Integer> - number of consecutive health probe successes required before moving the instance to the Healthy state
+        #           * 'Timeout'<~Integer> - number of seconds after which no response means a failed health probe
+        #           * 'Interval'<~Integer> - interval (in seconds) between health checks of an individual instance
+        #           * 'UnhealthyThreshold'<~Integer> - number of consecutive health probe failures that move the instance to the unhealthy state
+        #           * 'Target'<~String> - string describing protocol type, port and URL to check
+        #         * 'Policies'<~Hash>:
+        #           * 'LBCookieStickinessPolicies'<~Array> - list of Load Balancer Generated Cookie Stickiness policies for the LoadBalancer
+        #           * 'AppCookieStickinessPolicies'<~Array> - list of Application Generated Cookie Stickiness policies for the LoadBalancer
+        #         * 'AvailabilityZones'<~Array> - list of availability zones covered by this load balancer
+        #         * 'Instances'<~Array> - list of instances that the load balancer balances between
+        def describe_load_balancers(lb_name = [])
+          params = AWS.indexed_param('LoadBalancerNames.member', [*lb_name])
+          request({
+            'Action'  => 'DescribeLoadBalancers',
+            :parser   => Fog::Parsers::AWS::ELB::DescribeLoadBalancers.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_load_balancers(lb_name = [])
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..0e56b4c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/disable_availability_zones_for_load_balancer'
+
+        # Disable an availability zone for an existing ELB
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones to disable on ELB
+        # * lb_name<~String> - Load balancer to disable availability zones on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DisableAvailabilityZonesForLoadBalancerResult'<~Hash>:
+        #       * 'AvailabilityZones'<~Array> - array of strings describing instances currently enabled
+        def disable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones], 1)
+          request({
+            'Action'           => 'DisableAvailabilityZonesForLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DisableAvailabilityZonesForLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :disable_zones :disable_availability_zones_for_load_balancer
+
+      end
+
+      class Mock
+
+        def disable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :disable_zones :disable_availability_zones_for_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..e074067
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/enable_availability_zones_for_load_balancer'
+
+        # Enable an availability zone for an existing ELB
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones to enable on ELB
+        # * lb_name<~String> - Load balancer to enable availability zones on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'EnableAvailabilityZonesForLoadBalancerResult'<~Hash>:
+        #       * 'AvailabilityZones'<~Array> - array of strings describing instances currently enabled
+        def enable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones], 1)
+          request({
+            'Action'           => 'EnableAvailabilityZonesForLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::EnableAvailabilityZonesForLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :enable_zones :enable_availability_zones_for_load_balancer
+
+      end
+
+      class Mock
+
+        def enable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :enable_zones :enable_availability_zones_for_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
new file mode 100644
index 0000000..8a8f678
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/register_instances_with_load_balancer'
+
+        # Register an instance with an existing ELB
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - List of instance IDs to associate with ELB
+        # * lb_name<~String> - Load balancer to assign instances to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'RegisterInstancesWithLoadBalancerResult'<~Hash>:
+        #       * 'Instances'<~Array> - array of hashes describing instances currently enabled
+        #         * 'InstanceId'<~String>
+        def register_instances_with_load_balancer(instance_ids, lb_name)
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids], 1)
+          request({
+            'Action'           => 'RegisterInstancesWithLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::RegisterInstancesWithLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :register_instances :register_instances_with_load_balancer
+
+      end
+
+      class Mock
+
+        def register_instances_with_load_balancer(instance_ids, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :register_instances :register_instances_with_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/batch_put_attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/batch_put_attributes.rb
new file mode 100644
index 0000000..ec4ebaa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/batch_put_attributes.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Put items attributes into a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * items<~Hash> - Keys are the items names and may use any UTF-8
+        #   characters valid in xml.  Control characters and sequences not allowed
+        #   in xml are not valid.  Can be up to 1024 bytes long.  Values are the
+        #   attributes to add to the given item and may use any UTF-8 characters
+        #   valid in xml. Control characters and sequences not allowed in xml are
+        #   not valid.  Each name and value can be up to 1024 bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def batch_put_attributes(domain_name, items, replace_attributes = Hash.new([]))
+          request({
+            'Action'      => 'BatchPutAttributes',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_batch_attributes(items, replace_attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def batch_put_attributes(domain_name, items, replace_attributes = Hash.new([]))
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            for item_name, attributes in items do
+              for key, value in attributes do
+                @data[:domains][domain_name][item_name] ||= {}
+                if replace_attributes[item_name] && replace_attributes[item_name].include?(key)
+                  @data[:domains][domain_name][item_name][key.to_s] = []
+                else
+                  @data[:domains][domain_name][item_name][key.to_s] ||= []
+                end
+                @data[:domains][domain_name][item_name][key.to_s] << value.to_s
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/create_domain.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/create_domain.rb
new file mode 100644
index 0000000..1078cb3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/create_domain.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Create a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String>:: Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def create_domain(domain_name)
+          request(
+            'Action'      => 'CreateDomain',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_domain(domain_name)
+          response = Excon::Response.new
+          @data[:domains][domain_name] = {}
+          response.status = 200
+          response.body = {
+            'BoxUsage'  => Fog::AWS::Mock.box_usage,
+            'RequestId' => Fog::AWS::Mock.request_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/delete_attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/delete_attributes.rb
new file mode 100644
index 0000000..f2dcd6f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/delete_attributes.rb
@@ -0,0 +1,65 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Hash> - Name/value pairs to remove from the item.  Defaults to
+        #   nil, which will delete the entire item. Attribute names and values may
+        #   use any UTF-8 characters valid in xml. Control characters and sequences
+        #   not allowed in xml are not valid.  Each name and value can be up to 1024
+        #   bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def delete_attributes(domain_name, item_name, attributes = nil)
+          request({
+            'Action'      => 'DeleteAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_attributes(attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def delete_attributes(domain_name, item_name, attributes = nil)
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            if attributes
+              for key, value in attributes
+                if @data[:domains][domain_name][key]
+                  @data[:domains][domain_name][key].delete('value')
+                end
+              end
+            else
+              @data[:domains].delete(domain_name)
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/delete_domain.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/delete_domain.rb
new file mode 100644
index 0000000..f157cfa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/delete_domain.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Delete a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String>:: Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def delete_domain(domain_name)
+          request(
+            'Action'      => 'DeleteDomain',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_domain(domain_name)
+          response = Excon::Response.new
+          if @data[:domains].delete(domain_name)
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/domain_metadata.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/domain_metadata.rb
new file mode 100644
index 0000000..fbe988e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/domain_metadata.rb
@@ -0,0 +1,75 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/domain_metadata'
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AttributeNameCount' - number of unique attribute names in domain
+        #     * 'AttributeNamesSizeBytes' - total size of unique attribute names, in bytes
+        #     * 'AttributeValueCount' - number of all name/value pairs in domain
+        #     * 'AttributeValuesSizeBytes' - total size of attributes, in bytes
+        #     * 'BoxUsage'
+        #     * 'ItemCount' - number of items in domain
+        #     * 'ItemNameSizeBytes' - total size of item names in domain, in bytes
+        #     * 'RequestId'
+        #     * 'Timestamp' - last update time for metadata.
+        def domain_metadata(domain_name)
+          request(
+            'Action'      => 'DomainMetadata',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::DomainMetadata.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_metadata(domain_name)
+          response = Excon::Response.new
+          if domain = @data[:domains][domain_name]
+            response.status = 200
+          
+            attribute_names = []
+            attribute_values = []
+            for item in domain.values
+              for key, values in item
+                attribute_names << key
+                for value in values
+                  attribute_values << value
+                end
+              end
+            end
+          
+            response.body = {
+              'AttributeNameCount'        => attribute_names.length,
+              'AttributeNamesSizeBytes'   => attribute_names.join('').length,
+              'AttributeValueCount'       => attribute_values.length,
+              'AttributeValuesSizeBytes'  => attribute_values.join('').length,
+              'BoxUsage'                  => Fog::AWS::Mock.box_usage,
+              'ItemCount'                 => domain.keys.length,
+              'ItemNamesSizeBytes'        => domain.keys.join('').length,
+              'RequestId'                 => Fog::AWS::Mock.request_id,
+              'Timestamp'                 => Time.now
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/get_attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/get_attributes.rb
new file mode 100644
index 0000000..f2b94e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/get_attributes.rb
@@ -0,0 +1,71 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/get_attributes'
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Array> - Attributes to return from the item.  Defaults to
+        #   {}, which will return all attributes. Attribute names and values may use
+        #   any UTF-8 characters valid in xml. Control characters and sequences not 
+        #   allowed in xml are not valid.  Each name and value can be up to 1024
+        #   bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Attributes' - list of attribute name/values for the item
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def get_attributes(domain_name, item_name, attributes = {})
+          
+          request({
+            'Action'      => 'GetAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::GetAttributes.new(@nil_string)
+          }.merge!(encode_attribute_names(attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def get_attributes(domain_name, item_name, attributes = nil)
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            object = {}
+            if attributes
+              for attribute in attributes
+                if @data[:domains][domain_name][item_name] && @data[:domains][domain_name][item_name]
+                  object[attribute] = @data[:domains][domain_name][item_name][attribute]
+                end
+              end
+            elsif @data[:domains][domain_name][item_name]
+              object = @data[:domains][domain_name][item_name]
+            end
+            response.status = 200
+            response.body = {
+              'Attributes'  => object,
+              'BoxUsage'    => Fog::AWS::Mock.box_usage,
+              'RequestId'   => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/list_domains.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/list_domains.rb
new file mode 100644
index 0000000..a842102
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/list_domains.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/list_domains'
+
+        # List SimpleDB domains
+        #
+        # ==== Parameters
+        # * options<~Hash> - options, defaults to {}
+        #   * 'MaxNumberOfDomains'<~Integer> - number of domains to return
+        #     between 1 and 100, defaults to 100
+        #   * 'NextToken'<~String> - Offset token to start listing, defaults to nil
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'Domains' - array of domain names.
+        #     * 'NextToken' - offset to start with if there are are more domains to list
+        #     * 'RequestId'
+        def list_domains(options = {})
+          request({
+            'Action' => 'ListDomains',
+            :parser  => Fog::Parsers::AWS::SimpleDB::ListDomains.new(@nil_string)
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_domains(options = {})
+          response = Excon::Response.new
+          keys = @data[:domains].keys
+          max = options['MaxNumberOfDomains'] || keys.size
+          offset = options['NextToken'] || 0
+          domains = []
+          for key, value in @data[:domains].keys[offset...max]
+            domains << key
+          end
+          response.status = 200
+          response.body = {
+            'BoxUsage'  => Fog::AWS::Mock.box_usage,
+            'Domains'   => domains,
+            'RequestId' => Fog::AWS::Mock.request_id
+          }
+          if max < keys.size
+            response.body['NextToken'] = max + 1
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/put_attributes.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/put_attributes.rb
new file mode 100644
index 0000000..435d23c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/put_attributes.rb
@@ -0,0 +1,78 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Put item attributes into a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Hash> - Name/value pairs to add to the item.  Attribute names
+        #   and values may use any UTF-8 characters valid in xml. Control characters
+        #   and sequences not allowed in xml are not valid.  Each name and value can
+        #   be up to 1024 bytes long.
+        # * options<~Hash> - Accepts the following keys.
+        #   :replace => [Array of keys to replace]
+        #   :expect => {name/value pairs for performing conditional put}
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def put_attributes(domain_name, item_name, attributes, options = {})
+          options[:expect] = {} unless options[:expect]
+          options[:replace] = [] unless options[:replace]
+          request({
+            'Action'      => 'PutAttributes',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string),
+            'ItemName' => item_name
+          }.merge!(encode_attributes(attributes, options[:replace], options[:expect])))
+        end
+
+      end
+
+      class Mock
+
+        def put_attributes(domain_name, item_name, attributes, options = {})
+          options[:expect] = {} unless options[:expect]
+          options[:replace] = [] unless options[:replace]
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            options[:expect].each do |ck, cv|
+              if @data[:domains][domain_name][item_name][ck] != [cv]
+                response.status = 409
+                raise(Excon::Errors.status_error({:expects => 200}, response))
+              end
+            end
+            attributes.each do |key, value|
+              @data[:domains][domain_name][item_name] ||= {}
+              @data[:domains][domain_name][item_name][key.to_s] = [] unless @data[:domains][domain_name][item_name][key.to_s]
+              if options[:replace].include?(key.to_s)
+                @data[:domains][domain_name][item_name][key.to_s] = [value.to_s]
+              else
+                @data[:domains][domain_name][item_name][key.to_s] += [value.to_s]
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/select.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/select.rb
new file mode 100644
index 0000000..2104be7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/simpledb/select.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/select'
+
+        # Select item data from SimpleDB
+        #
+        # ==== Parameters
+        # * select_expression<~String> - Expression to query domain with.
+        # * next_token<~String> - Offset token to start list, defaults to nil.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'<~Float>
+        #     * 'RequestId'<~String>
+        #     * 'Items'<~Hash> - list of attribute name/values for the items formatted as 
+        #       { 'item_name' => { 'attribute_name' => ['attribute_value'] }}
+        #     * 'NextToken'<~String> - offset to start with if there are are more domains to list
+        def select(select_expression, next_token = nil)
+          request(
+            'Action'            => 'Select',
+            'NextToken'         => next_token,
+            'SelectExpression'  => select_expression,
+            :parser             => Fog::Parsers::AWS::SimpleDB::Select.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def select(select_expression, next_token = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/copy_object.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/copy_object.rb
new file mode 100644
index 0000000..fdfff66
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/copy_object.rb
@@ -0,0 +1,72 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/copy_object'
+
+        # Copy an object from one S3 bucket to another
+        #
+        # ==== Parameters
+        # * source_bucket_name<~String> - Name of source bucket
+        # * source_object_name<~String> - Name of source object
+        # * target_bucket_name<~String> - Name of bucket to create copy in
+        # * target_object_name<~String> - Name for new copy of object
+        # * options<~Hash>:
+        #   * 'x-amz-metadata-directive'<~String> - Specifies whether to copy metadata from source or replace with data in request.  Must be in ['COPY', 'REPLACE']
+        #   * 'x-amz-copy_source-if-match'<~String> - Copies object if its etag matches this value
+        #   * 'x-amz-copy_source-if-modified_since'<~Time> - Copies object it it has been modified since this time
+        #   * 'x-amz-copy_source-if-none-match'<~String> - Copies object if its etag does not match this value
+        #   * 'x-amz-copy_source-if-unmodified-since'<~Time> - Copies object it it has not been modified since this time
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #     * 'LastModified'<~Time> - date object was last modified
+        #
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          headers = { 'x-amz-copy-source' => "/#{source_bucket_name}/#{source_object_name}" }.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{target_bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::AWS::Storage::CopyObject.new,
+            :path     => CGI.escape(target_object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          response = Excon::Response.new
+          source_bucket = @data[:buckets][source_bucket_name]
+          source_object = source_bucket && source_bucket[:objects][source_object_name]
+          target_bucket = @data[:buckets][target_bucket_name]
+
+          if source_object && target_bucket
+            response.status = 200
+            target_object = source_object.dup
+            target_object.merge!({
+              'Name' => target_object_name
+            })
+            target_bucket[:objects][target_object_name] = target_object
+            response.body = {
+              'ETag'          => target_object['ETag'],
+              'LastModified'  => Time.parse(target_object['LastModified'])
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/delete_bucket.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/delete_bucket.rb
new file mode 100644
index 0000000..5b7248e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/delete_bucket.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        def delete_bucket(bucket_name)
+          request({
+            :expects  => 204,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'DELETE'
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_bucket(bucket_name)
+          response = Excon::Response.new
+          if @data[:buckets][bucket_name].nil?
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          elsif @data[:buckets][bucket_name] && !@data[:buckets][bucket_name][:objects].empty?
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          else
+            @data[:buckets].delete(bucket_name)
+            response.status = 204
+          end
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/delete_object.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/delete_object.rb
new file mode 100644
index 0000000..75cd7c2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/delete_object.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object to delete
+        # * object_name<~String> - Name of object to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        def delete_object(bucket_name, object_name)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_object(bucket_name, object_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 204
+            bucket[:objects].delete(object_name)
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket.rb
new file mode 100644
index 0000000..ef438d1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket.rb
@@ -0,0 +1,103 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket'
+
+        # List information about objects in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'Contents'<~Array>:
+        #       * 'ETag'<~String>: Etag of object
+        #       * 'Key'<~String>: Name of object
+        #       * 'LastModified'<~String>: Timestamp of last modification of object
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'Size'<~Integer> - Size of object
+        #       * 'StorageClass'<~String> - Storage class of object
+        #
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucket.new,
+            :query    => options
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            contents = bucket[:objects].values.sort {|x,y| x['Key'] <=> y['Key']}.reject do |object|
+                (options['prefix'] && object['Key'][0...options['prefix'].length] != options['prefix']) ||
+                (options['marker'] && object['Key'] <= options['marker'])
+              end.map do |object|
+                data = object.reject {|key, value| !['ETag', 'Key', 'LastModified', 'Size', 'StorageClass'].include?(key)}
+                data.merge!({
+                  'LastModified' => Time.parse(data['LastModified']),
+                  'Owner'        => bucket['Owner'],
+                  'Size'         => data['Size'].to_i
+                })
+              data
+            end
+            max_keys = options['max-keys'] || 1000
+            size = [max_keys, 1000].min
+            truncated_contents = contents[0...size]
+
+            response.status = 200
+            response.body = {
+              'Contents'    => truncated_contents,
+              'IsTruncated' => truncated_contents.size != contents.size,
+              'Marker'      => options['marker'],
+              'MaxKeys'     => max_keys,
+              'Name'        => bucket['Name'],
+              'Prefix'      => options['prefix']
+            }
+            if options['max-keys'] && options['max-keys'] < response.body['Contents'].length
+                response.body['IsTruncated'] = true
+                response.body['Contents'] = response.body['Contents'][0...options['max-keys']]
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_acl.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_acl.rb
new file mode 100644
index 0000000..6dde209
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_acl.rb
@@ -0,0 +1,55 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/access_control_list'
+
+        # Get access control list for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get access control list for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_bucket_acl(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::AccessControlList.new,
+            :query      => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_acl(bucket_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_location.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_location.rb
new file mode 100644
index 0000000..c18b091
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_location.rb
@@ -0,0 +1,48 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_location'
+
+        # Get location constraint for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get location constraint for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'LocationConstraint'<~String> - Location constraint of the bucket
+        def get_bucket_location(bucket_name)
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucketLocation.new,
+            :query    => {'location' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_location(bucket_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 200
+            response.body = {'LocationConstraint' => bucket['LocationConstraint'] }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_logging.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_logging.rb
new file mode 100644
index 0000000..4b6101f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_logging.rb
@@ -0,0 +1,55 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_logging'
+
+        # Get logging status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get logging status for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BucketLoggingStatus'<~Hash>: (will be empty if logging is disabled)
+        #       * 'LoggingEnabled'<~Hash>:
+        #         * 'TargetBucket'<~String> - bucket where logs are stored
+        #         * 'TargetPrefix'<~String> - prefix logs are stored with
+        #         * 'TargetGrants'<~Array>:
+        #           * 'Grant'<~Hash>:
+        #             * 'Grantee'<~Hash>:
+        #                 * 'DisplayName'<~String> - Display name of grantee
+        #                 * 'ID'<~String> - Id of grantee
+        #               or
+        #                 * 'URI'<~String> - URI of group to grant access for
+        #             * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_bucket_logging(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketLogging.new,
+            :query      => {'logging' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_logging(bucket_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_object_versions.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_object_versions.rb
new file mode 100644
index 0000000..974b3e3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_object_versions.rb
@@ -0,0 +1,80 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_object_versions'
+
+        # List information about object versions in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'key-marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #   * 'version-id-marker'<~String> - limits object versions to only those that
+        #     appear lexicographically after its value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'KeyMarker'<~String> - Key marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'VersionIdMarker'<~String> - Version id marker specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not this is the totality of the bucket
+        #     * 'Versions'<~Array>:
+        #         * 'DeleteMarker'<~Hash>:
+        #           * 'IsLatest'<~Boolean> - Whether or not this is the latest version
+        #           * 'Key'<~String> - Name of object
+        #           * 'LastModified'<~String>: Timestamp of last modification of object
+        #           * 'Owner'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of object owner
+        #             * 'ID'<~String> - Id of object owner
+        #           * 'VersionId'<~String> - The id of this version
+        #       or
+        #         * 'Version'<~Hash>:
+        #           * 'ETag'<~String>: Etag of object
+        #           * 'IsLatest'<~Boolean> - Whether or not this is the latest version
+        #           * 'Key'<~String> - Name of object
+        #           * 'LastModified'<~String>: Timestamp of last modification of object
+        #           * 'Owner'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of object owner
+        #             * 'ID'<~String> - Id of object owner
+        #           * 'Size'<~Integer> - Size of object
+        #           * 'StorageClass'<~String> - Storage class of object
+        #           * 'VersionId'<~String> - The id of this version
+        #
+        def get_bucket_object_versions(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucketObjectVersions.new,
+            :query    => {'versions' => nil}.merge!(options)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_object_versions(bucket_name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_versioning.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_versioning.rb
new file mode 100644
index 0000000..24b2e68
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_bucket_versioning.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_versioning'
+
+        # Get versioning status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get versioning status for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'VersioningConfiguration'<~Hash>
+        #         * Status<~String>: Versioning status in ['Enabled', 'Suspended', nil]
+        #
+        def get_bucket_versioning(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketVersioning.new,
+            :query      => {'versioning' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_versioning(bucket_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object.rb
new file mode 100644
index 0000000..c53b9ad
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object.rb
@@ -0,0 +1,104 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = options['If-Modified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = options['If-Unmodified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          }, &block)
+        end
+
+      end
+
+      class Mock
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          response = Excon::Response.new
+          if (bucket = @data[:buckets][bucket_name]) && (object = bucket[:objects][object_name])
+            if options['If-Match'] && options['If-Match'] != object['ETag']
+              response.status = 412
+            elsif options['If-Modified-Since'] && options['If-Modified-Since'] > Time.parse(object['LastModified'])
+              response.status = 304
+            elsif options['If-None-Match'] && options['If-None-Match'] == object['ETag']
+              response.status = 304
+            elsif options['If-Unmodified-Since'] && options['If-Unmodified-Since'] < Time.parse(object['LastModified'])
+              response.status = 412
+            else
+              response.status = 200
+              response.headers = {
+                'Content-Length'  => object['Size'],
+                'Content-Type'    => object['Content-Type'],
+                'ETag'            => object['ETag'],
+                'Last-Modified'   => object['LastModified']
+              }
+              unless block_given?
+                response.body = object[:body]
+              else
+                data = StringIO.new(object[:body])
+                remaining = data.length
+                while remaining > 0
+                  chunk = data.read([remaining, Excon::CHUNK_SIZE].min)
+                  block.call(chunk)
+                  remaining -= Excon::CHUNK_SIZE
+                end
+              end
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_acl.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_acl.rb
new file mode 100644
index 0000000..fc522e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_acl.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/access_control_list'
+
+        # Get access control list for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get access control list for
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_object_acl(bucket_name, object_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::AccessControlList.new,
+            :path       => CGI.escape(object_name),
+            :query      => query
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_object_acl(bucket_name, object_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_torrent.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_torrent.rb
new file mode 100644
index 0000000..9340f4a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_torrent.rb
@@ -0,0 +1,55 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get torrent for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get torrent for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of grantee
+        #             * 'ID'<~String> - Id of grantee
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_object_torrent(bucket_name, object_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :path       => CGI.escape(object_name),
+            :query      => {'torrent' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_object_object(bucket_name, object_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_url.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_url.rb
new file mode 100644
index 0000000..ff0f09b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_object_url.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an expiring object url from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'GET',
+            :path     => CGI.escape(object_name)
+          }, expires)
+        end
+
+      end
+
+      class Mock
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'GET',
+            :path     => CGI.escape(object_name)
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_request_payment.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_request_payment.rb
new file mode 100644
index 0000000..8418ec1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_request_payment.rb
@@ -0,0 +1,48 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_request_payment'
+
+        # Get configured payer for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get payer for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Payer'<~String> - Specifies who pays for download and requests
+        def get_request_payment(bucket_name)
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetRequestPayment.new,
+            :query    => {'requestPayment' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_request_payment(bucket_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 200
+            response.body = { 'Payer' => bucket['Payer'] }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_service.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_service.rb
new file mode 100644
index 0000000..c4a959e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/get_service.rb
@@ -0,0 +1,53 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_service'
+
+        # List information about S3 buckets for authorized user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Buckets'<~Hash>:
+        #       * 'Name'<~String> - Name of bucket
+        #       * 'CreationTime'<~Time> - Timestamp of bucket creation
+        #     * 'Owner'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of bucket owner
+        #       * 'ID'<~String> - Id of bucket owner
+        def get_service
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => @host,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetService.new,
+            :url      => @host
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_service
+          response = Excon::Response.new
+          response.headers['Status'] = 200
+          buckets = @data[:buckets].values.map do |bucket|
+            bucket.reject do |key, value|
+              !['CreationDate', 'Name'].include?(key)
+            end
+          end
+          response.body = {
+            'Buckets' => buckets,
+            'Owner'   => { 'DisplayName' => 'owner', 'ID' => 'some_id'}
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/head_object.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/head_object.rb
new file mode 100644
index 0000000..b4e7833
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/head_object.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get headers for an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        def head_object(bucket_name, object_name, options={})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = options['If-Modified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = options['If-Unmodified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'HEAD',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+
+      class Mock
+
+        def head_object(bucket_name, object_name, options = {})
+          response = get_object(bucket_name, object_name, options)
+          response.body = nil
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket.rb
new file mode 100644
index 0000000..fbc07d5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket.rb
@@ -0,0 +1,65 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Create an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to create
+        # * options<~Hash> - config arguments for bucket.  Defaults to {}.
+        #   * :location_constraint<~Symbol> - sets the location for the bucket
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 200
+        def put_bucket(bucket_name, options = {})
+          if options['LocationConstraint']
+            data =
+<<-DATA
+  <CreateBucketConfiguration>
+    <LocationConstraint>#{options['LocationConstraint']}</LocationConstraint>
+  </CreateBucketConfiguration>
+DATA
+          else
+            data = nil
+          end
+          request({
+            :expects    => 200,
+            :body       => data,
+            :headers    => {},
+            :idempotent => true,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT'
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket(bucket_name, options = {})
+          response = Excon::Response.new
+          response.status = 200
+          bucket = {
+            :objects        => {},
+            'Name'          => bucket_name,
+            'CreationDate'  => Time.now,
+            'Owner'         => { 'DisplayName' => 'owner', 'ID' => 'some_id'},
+            'Payer'         => 'BucketOwner'
+          }
+          if options['LocationConstraint']
+            bucket['LocationConstraint'] = options['LocationConstraint']
+          else
+            bucket['LocationConstraint'] = ''
+          end
+          unless @data[:buckets][bucket_name]
+            @data[:buckets][bucket_name] = bucket
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_acl.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_acl.rb
new file mode 100644
index 0000000..be10ddd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_acl.rb
@@ -0,0 +1,80 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change access control list for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        def put_bucket_acl(bucket_name, acl)
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket_acl(bucket_name, acl)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_logging.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_logging.rb
new file mode 100644
index 0000000..f0da7cd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_logging.rb
@@ -0,0 +1,87 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change logging status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * logging_status<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        def put_bucket_logging(bucket_name, logging_status)
+          if logging_status['LoggingEnabled'].empty?
+            data =
+<<-DATA
+<BucketLoggingStatus xmlns="http://doc.s3.amazonaws.com/2006-03-01" />
+DATA
+          else
+            data =
+<<-DATA
+<BucketLoggingStatus xmlns="http://doc.s3.amazonaws.com/2006-03-01">
+  <LoggingEnabled>
+    <TargetBucket>#{logging_status['LoggingEnabled']['TargetBucket']}</TargetBucket>
+    <TargetPrefix>#{logging_status['LoggingEnabled']['TargetBucket']}</TargetPrefix>
+    <TargetGrants>
+DATA
+
+            acl['AccessControlList'].each do |grant|
+              data << "      <Grant>"
+              type = case grant['Grantee'].keys.sort
+              when ['DisplayName', 'ID']
+                'CanonicalUser'
+              when ['EmailAddress']
+                'AmazonCustomerByEmail'
+              when ['URI']
+                'Group'
+              end
+              data << "        <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+              for key, value in grant['Grantee']
+                data << "          <#{key}>#{value}</#{key}>"
+              end
+              data << "        </Grantee>"
+              data << "        <Permission>#{grant['Permission']}</Permission>"
+              data << "      </Grant>"
+            end
+
+            data <<
+<<-DATA
+    </TargetGrants>
+  </LoggingEnabled>
+</BucketLoggingStatus>
+DATA
+          end
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'logging' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket_logging(bucket_name, logging_status)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_versioning.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_versioning.rb
new file mode 100644
index 0000000..9f258d6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_bucket_versioning.rb
@@ -0,0 +1,40 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change versioning status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * status<~String> - Status to change to in ['Enabled', 'Suspended']
+        def put_bucket_versioning(bucket_name, status)
+          data =
+<<-DATA
+<VersioningConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+  <Status>#{status}</Status>
+</VersioningConfiguration>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'versioning' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket_versioning(bucket_name, status)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_object.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_object.rb
new file mode 100644
index 0000000..93d886a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_object.rb
@@ -0,0 +1,71 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Create an object in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * data<~File> - File or String to create object from
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-Length'<~String> - Size of object in bytes (defaults to object.read.length)
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message (defaults to Base64 encoded MD5 of object.read)
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * "x-amz-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        def put_object(bucket_name, object_name, data, options = {})
+          data = parse_data(data)
+          headers = data[:headers].merge!(options)
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_object(bucket_name, object_name, data, options = {})
+          data = parse_data(data)
+          unless data[:body].is_a?(String)
+            data[:body] = data[:body].read
+          end
+          response = Excon::Response.new
+          if (bucket = @data[:buckets][bucket_name])
+            response.status = 200
+            bucket[:objects][object_name] = {
+              :body           => data[:body],
+              'ETag'          => Fog::AWS::Mock.etag,
+              'Key'           => object_name,
+              'LastModified'  => Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000"),
+              'Size'          => data[:headers]['Content-Length'],
+              'StorageClass'  => 'STANDARD'
+            }
+            bucket[:objects][object_name]['Content-Type'] = data[:headers]['Content-Type']
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_object_url.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_object_url.rb
new file mode 100644
index 0000000..7503176
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_object_url.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an expiring object url from S3 for putting an object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :path     => CGI.escape(object_name)
+          }, expires)
+        end
+
+      end
+
+      class Mock
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :path     => CGI.escape(object_name)
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_request_payment.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_request_payment.rb
new file mode 100644
index 0000000..b6ce1f6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/requests/storage/put_request_payment.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change who pays for requests to an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * payer<~String> - valid values are BucketOwner or Requester
+        def put_request_payment(bucket_name, payer)
+          data =
+<<-DATA
+<RequestPaymentConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+  <Payer>#{payer}</Payer>
+</RequestPaymentConfiguration>
+DATA
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'requestPayment' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_request_payment(bucket_name, payer)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 200
+            bucket['Payer'] = payer
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/s3.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/s3.rb
new file mode 100644
index 0000000..a1e1991
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/s3.rb
@@ -0,0 +1,15 @@
+module Fog
+  module AWS
+    class S3
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::AWS::S3#new is deprecated, use Fog::AWS::Storage#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::AWS::Storage.new(attributes)
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/simpledb.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/simpledb.rb
new file mode 100644
index 0000000..e571c76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/simpledb.rb
@@ -0,0 +1,168 @@
+module Fog
+  module AWS
+    class SimpleDB < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+
+      request_path 'fog/aws/requests/simpledb'
+      request :batch_put_attributes
+      request :create_domain
+      request :delete_attributes
+      request :delete_domain
+      request :domain_metadata
+      request :get_attributes
+      request :list_domains
+      request :put_attributes
+      request :select
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :domains => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @data = self.class.data[@aws_access_key_id]
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to SimpleDB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and 
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   sdb = SimpleDB.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * SimpleDB object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac       = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          @host       = options[:host]      || 'sdb.amazonaws.com'
+          @nil_string = options[:nil_string]|| 'nil'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        private
+
+        def encode_attributes(attributes, replace_attributes = [], expected_attributes = {})
+          encoded_attributes = {}
+          if attributes
+
+            expected_attributes.keys.each_with_index do |exkey, index|
+              for value in Array(expected_attributes[exkey])
+                encoded_attributes["Expected.#{index}.Name"] = exkey.to_s
+                encoded_attributes["Expected.#{index}.Value"] = sdb_encode(value)
+              end
+            end
+
+            index = 0
+            for key in attributes.keys
+              for value in Array(attributes[key])
+                encoded_attributes["Attribute.#{index}.Name"] = key.to_s
+                if replace_attributes.include?(key)
+                  encoded_attributes["Attribute.#{index}.Replace"] = 'true'
+                end
+                encoded_attributes["Attribute.#{index}.Value"] = sdb_encode(value)
+                index += 1
+              end
+            end
+          end
+          encoded_attributes
+        end
+
+        def encode_attribute_names(attributes)
+          AWS.indexed_param('AttributeName', attributes.map {|attribute| attributes.to_s})
+        end
+
+        def encode_batch_attributes(items, replace_attributes = Hash.new([]))
+          encoded_attributes = {}
+          if items
+            item_index = 0
+            for item_key in items.keys
+              encoded_attributes["Item.#{item_index}.ItemName"] = item_key.to_s
+              for attribute_key in items[item_key].keys
+                attribute_index = 0
+                for value in Array(items[item_key][attribute_key])
+                  encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Name"] = attribute_key.to_s
+                  if replace_attributes[item_key].include?(attribute_key)
+                    encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Replace"] = 'true'
+                  end
+                  encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Value"] = sdb_encode(value)
+                  attribute_index += 1
+                end
+                item_index += 1
+              end
+            end
+          end
+          encoded_attributes
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          idempotent = params.delete(:idempotent)
+          parser = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :version            => '2009-04-15'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+            :host       => @host,
+            :idempotent => idempotent,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+        def sdb_encode(value)
+          if value.nil?
+            @nil_string
+          else
+            value.to_s
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/aws/storage.rb b/lib/bbcloud/vendor/fog/lib/fog/aws/storage.rb
new file mode 100644
index 0000000..a51fc85
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/aws/storage.rb
@@ -0,0 +1,211 @@
+module Fog
+  module AWS
+    class Storage < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+
+      model_path 'fog/aws/models/storage'
+      collection  :directories
+      model       :directory
+      collection  :files
+      model       :file
+
+      request_path 'fog/aws/requests/storage'
+      request :copy_object
+      request :delete_bucket
+      request :delete_object
+      request :get_bucket
+      request :get_bucket_acl
+      request :get_bucket_location
+      request :get_bucket_logging
+      request :get_bucket_object_versions
+      request :get_bucket_versioning
+      request :get_object
+      request :get_object_acl
+      request :get_object_torrent
+      request :get_object_url
+      request :get_request_payment
+      request :get_service
+      request :head_object
+      request :put_bucket
+      request :put_bucket_acl
+      request :put_bucket_logging
+      request :put_bucket_versioning
+      request :put_object
+      request :put_object_url
+      request :put_request_payment
+
+      module Utils
+
+        def parse_data(data)
+          metadata = {
+            :body => nil,
+            :headers => {}
+          }
+
+          if data.is_a?(String)
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = metadata[:body].size.to_s
+          else
+            filename = ::File.basename(data.path)
+            unless (mime_types = MIME::Types.of(filename)).empty?
+              metadata[:headers]['Content-Type'] = mime_types.first.content_type
+            end
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = ::File.size(data.path).to_s
+          end
+          # metadata[:headers]['Content-MD5'] = Base64.encode64(Digest::MD5.digest(metadata[:body])).strip
+          metadata
+        end
+
+        def url(params, expires)
+          params[:headers]['Date'] = expires.to_i
+          query = [params[:query]].compact
+          query << "AWSAccessKeyId=#{@aws_access_key_id}"
+          query << "Signature=#{CGI.escape(signature(params))}"
+          query << "Expires=#{params[:headers]['Date']}"
+          "http://#{params[:host]}/#{params[:path]}?#{query.join('&')}"
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :buckets => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @data = self.class.data[@aws_access_key_id]
+        end
+
+        def signature(params)
+          "foo"
+        end
+      end
+
+      class Real
+        include Utils
+        extend Fog::Deprecation
+        deprecate(:reset, :reload)
+
+        # Initialize connection to S3
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and 
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   s3 = S3.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * S3 object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+            when 'eu-west-1'
+              's3-eu-west-1.amazonaws.com'
+            when 'us-east-1'
+              's3.amazonaws.com'
+            when 'ap-southeast-1'
+              's3-ap-southeast-1.amazonaws.com'
+            when 'us-west-1'
+              's3-us-west-1.amazonaws.com'
+            else
+              raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+            end
+          @port   = options[:port]      || 443
+          @scheme = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent] || true)
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers]['Date'] = Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000")
+          params[:headers]['Authorization'] = "AWS #{@aws_access_key_id}:#{signature(params)}"
+
+          response = @connection.request(params, &block)
+
+          response
+        end
+
+        def signature(params)
+          string_to_sign =
+<<-DATA
+#{params[:method]}
+#{params[:headers]['Content-MD5']}
+#{params[:headers]['Content-Type']}
+#{params[:headers]['Date']}
+DATA
+
+          amz_headers, canonical_amz_headers = {}, ''
+          for key, value in params[:headers]
+            if key[0..5] == 'x-amz-'
+              amz_headers[key] = value
+            end
+          end
+          amz_headers = amz_headers.sort {|x, y| x[0] <=> y[0]}
+          for key, value in amz_headers
+            canonical_amz_headers << "#{key}:#{value}\n"
+          end
+          string_to_sign << "#{canonical_amz_headers}"
+
+          subdomain = params[:host].split(".#{@host}").first
+          unless subdomain =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+            Formatador.display_line("[yellow][WARN] fog: the specified s3 bucket name(#{subdomain}) is not a valid dns name, which will negatively impact performance.  For details see: http://docs.amazonwebservices.com/AmazonS3/latest/dev/BucketRestrictions.html[/]")
+            params[:host] = params[:host].split("#{subdomain}.")[-1]
+            if params[:path]
+              params[:path] = "#{subdomain}/#{params[:path]}"
+            else
+              params[:path] = "#{subdomain}"
+            end
+            subdomain = nil
+          end
+
+          canonical_resource  = "/"
+          unless subdomain.nil? || subdomain == @host
+            canonical_resource << "#{CGI.escape(subdomain).downcase}/"
+          end
+          canonical_resource << "#{params[:path]}"
+          canonical_resource << '?'
+          for key in (params[:query] || {}).keys
+            if ['acl', 'location', 'logging', 'requestPayment', 'torrent', 'versions', 'versioning'].include?(key)
+              canonical_resource << "#{key}&"
+            end
+          end
+          canonical_resource.chop!
+          string_to_sign << "#{canonical_resource}"
+
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/bin.rb
new file mode 100644
index 0000000..9a43987
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bin.rb
@@ -0,0 +1,79 @@
+require 'fog/credentials'
+
+module Fog
+  class << self
+
+    def providers
+      [
+        ::AWS,
+        ::Bluebox,
+        ::Brightbox,
+        ::GoGrid,
+        ::Linode,
+        ::Local,
+        ::NewServers,
+        ::Rackspace,
+        ::Slicehost,
+        ::Terremark
+      ].select {|provider| provider.available?}
+    end
+
+    def modules
+      [
+        ::Vcloud
+      ].select {|_module_| _module_.initialized?}
+    end
+
+  end
+
+  class Bin
+    class << self
+
+      def available?
+        availability = true
+        for service in services
+          begin
+            service = eval(self[service].class.to_s.split('::')[0...-1].join('::'))
+            availability &&= service.requirements.all? {|requirement| Fog.credentials.include?(requirement)}
+          rescue
+            availability = false
+          end
+        end
+
+        if availability
+          for service in services
+            for collection in self[service].collections
+              unless self.respond_to?(collection)
+                self.class_eval <<-EOS, __FILE__, __LINE__
+                  def self.#{collection}
+                    self[:#{service}].#{collection}
+                  end
+                EOS
+              end
+            end
+          end
+        end
+
+        availability
+      end
+
+      def collections
+        services.map {|service| self[service].collections}.flatten.sort_by {|service| service.to_s}
+      end
+
+    end
+  end
+
+end
+
+require 'fog/aws/bin'
+require 'fog/bluebox/bin'
+require 'fog/brightbox/bin'
+require 'fog/go_grid/bin'
+require 'fog/linode/bin'
+require 'fog/local/bin'
+require 'fog/new_servers/bin'
+require 'fog/rackspace/bin'
+require 'fog/slicehost/bin'
+require 'fog/terremark/bin'
+require 'fog/vcloud/bin'
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox.rb
new file mode 100644
index 0000000..4cddb50
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Bluebox
+
+    extend Fog::Provider
+
+    service_path 'fog/bluebox'
+    service :compute
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Bluebox#new is deprecated, use Fog::Bluebox::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Bluebox::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/bin.rb
new file mode 100644
index 0000000..e9e5ce8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/bin.rb
@@ -0,0 +1,25 @@
+class Bluebox < Fog::Bin
+  class << self
+
+      def [](service)
+        @@connections ||= Hash.new do |hash, key|
+          hash[key] = case key
+          when :blocks
+            location = caller.first
+            warning = "[yellow][WARN] Bluebox[:blocks] is deprecated, use Bluebox[:compute] instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+            Fog::Bluebox::Compute.new
+          when :compute
+            Fog::Bluebox::Compute.new
+          end
+        end
+        @@connections[service]
+      end
+
+      def services
+        [:compute]
+      end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/compute.rb
new file mode 100644
index 0000000..f245832
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/compute.rb
@@ -0,0 +1,87 @@
+module Fog
+  module Bluebox
+    class Compute < Fog::Service
+
+      requires :bluebox_api_key, :bluebox_customer_id
+
+      model_path 'fog/bluebox/models/compute'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/bluebox/requests/compute'
+      request :create_block
+      request :destroy_block
+      request :get_block
+      request :get_blocks
+      request :get_product
+      request :get_products
+      request :get_template
+      request :get_templates
+      request :reboot_block
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @bluebox_api_key = options[:bluebox_api_key]
+          @data = self.class.data[@bluebox_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @bluebox_api_key      = options[:bluebox_api_key]
+          @bluebox_customer_id  = options[:bluebox_customer_id]
+          @host   = options[:bluebox_host]    || "boxpanel.blueboxgrp.com"
+          @port   = options[:bluebox_port]    || 443
+          @scheme = options[:bluebox_scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64([@bluebox_customer_id, @bluebox_api_key].join(':')).delete("\r\n")}"
+          })
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Bluebox::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/flavor.rb
new file mode 100644
index 0000000..f246750
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :cost
+        attribute :description
+
+        def bits
+          # 64
+          raise StandardError.new("Figure me out!?!")
+        end
+
+        def cores
+          # # 2 quad-cores >= 2Ghz = 8 cores
+          # 8 * case ram
+          # when 256
+          #   1/64.0
+          # when 512
+          #   1/32.0
+          # when 1024
+          #   1/16.0
+          # when 2048
+          #   1/8.0
+          # when 4096
+          #   1/4.0
+          # when 8192
+          #   1/2.0
+          # when 15872
+          #   1
+          # end
+          raise StandardError.new("Figure me out!?!")
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/flavors.rb
new file mode 100644
index 0000000..9bef38f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/bluebox/models/compute/flavor'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Bluebox::Compute::Flavor
+
+        def all
+          data = connection.get_products.body
+          load(data)
+        end
+
+        def get(product_id)
+          response = connection.get_product(product_id)
+          new(response.body)
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/image.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/image.rb
new file mode 100644
index 0000000..47bbce1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/image.rb
@@ -0,0 +1,19 @@
+require 'fog/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :description
+        attribute :public
+        attribute :created_at, :aliases => 'created'
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/images.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/images.rb
new file mode 100644
index 0000000..9b13fef
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/images.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/bluebox/models/compute/image'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Bluebox::Compute::Image
+
+        def all
+          data = connection.get_templates.body
+          load(data)
+        end
+
+        def get(template_id)
+          response = connection.get_template(template_id)
+          new(response.body)
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/server.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/server.rb
new file mode 100644
index 0000000..3313f89
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/server.rb
@@ -0,0 +1,81 @@
+require 'fog/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class BlockInstantiationError < StandardError; end
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :memory
+        attribute :storage
+        attribute :hostname
+        attribute :cpu
+        attribute :ips
+        attribute :status
+        attribute :flavor_id
+        # attribute :image_id
+
+        attr_accessor :image_id
+        attribute :template
+
+        # Not reported by the API, but used at create time
+        attr_accessor :password, :ssh_key, :user
+
+        def destroy
+          requires :id
+          connection.destroy_block(@id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(@flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(@image_id)
+        end
+
+        def ready?
+          @status == 'running'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_block(@id, type)
+          true
+        end
+
+        def save
+          requires :flavor_id, :image_id
+          options = if !@password && !@ssh_key
+            raise(ArgumentError, "password or ssh_key is required for this operation")
+          elsif @ssh_key
+            {'ssh_public_key' => @ssh_key}
+          elsif @password
+            {'password' => @password}
+          end
+          if @user
+            options['user'] = @user
+          end
+          data = connection.create_block(@flavor_id, @image_id, options)
+          merge_attributes(data.body)
+          true
+        end
+
+        private
+
+        def product=(new_product)
+          @flavor_id = new_product['id']
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/servers.rb
new file mode 100644
index 0000000..042411d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/models/compute/servers.rb
@@ -0,0 +1,29 @@
+require 'fog/collection'
+require 'fog/bluebox/models/compute/server'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Bluebox::Compute::Server
+
+        def all
+          data = connection.get_blocks.body
+          load(data)
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_block(server_id).body
+            new(server)
+          end
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/create_block.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/create_block.rb
new file mode 100644
index 0000000..71f278a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/create_block.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Create a new block
+        #
+        # ==== Parameters
+        # * product_id<~Integer> - Id of product to create block with
+        # * template_id<~Integer> - Id of template to create block with
+        # * options<~Hash>:
+        #     * password<~String> - Password for block
+        #   or
+        #     * ssh_key<~String> - ssh public key
+        #   * username<~String> - optional, defaults to deploy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def create_block(product_id, template_id, options = {})
+          request(
+            :expects  => 200,
+            :method   => 'POST',
+            :path     => '/api/blocks.json',
+            :query    => {'product' => product_id, 'template' => template_id}.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_block(product_id, template_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/destroy_block.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/destroy_block.rb
new file mode 100644
index 0000000..ba1d12f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/destroy_block.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Destroy a block
+        #
+        # ==== Parameters
+        # * block_id<~Integer> - Id of block to destroy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def destroy_block(block_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "api/blocks/#{block_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_block(block_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_block.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_block.rb
new file mode 100644
index 0000000..ca33c79
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_block.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a block.
+        #
+        # ==== Parameters
+        # * block_id<~Integer> - Id of block to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def get_block(block_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/blocks/#{block_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_block(block_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_blocks.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_blocks.rb
new file mode 100644
index 0000000..80fd003
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_blocks.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of blocks
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'ips'<~Array> - Ip addresses for the block
+        #     * 'id'<~String> - Id of the block
+        #     * 'storage'<~Integer> - Disk space quota for the block
+        #     * 'memory'<~Integer> - RAM quota for the block
+        #     * 'cpu'<~Float> - The fractional CPU quota for this block
+        #     * 'hostname'<~String> - The hostname for the block
+        def get_blocks
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/blocks.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_slices
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_product.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_product.rb
new file mode 100644
index 0000000..d3cb34a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_product.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a product
+        #
+        # ==== Parameters
+        # * product_id<~Integer> - Id of flavor to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO
+        def get_product(product_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/block_products/#{product_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_product(product_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_products.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_products.rb
new file mode 100644
index 0000000..191ca36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_products.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of products
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String> - UUID of the product
+        #     * 'description'<~String> - Description of the product
+        #     * 'cost'<~Decimal> - Hourly cost of the product
+        def get_products
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/block_products.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_products
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_template.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_template.rb
new file mode 100644
index 0000000..024f654
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_template.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a template
+        #
+        # ==== Parameters
+        # * template_id<~Integer> - Id of template to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO
+        def get_template(template_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/block_templates/#{template_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_template(template_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_templates.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_templates.rb
new file mode 100644
index 0000000..88ecc30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/get_templates.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of OS templates
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String> - UUID of the image
+        #     * 'description'<~String> - Description of the image
+        #     * 'public'<~Boolean> - Public / Private image
+        #     * 'created'<~Datetime> - Timestamp of when the image was created
+        def get_templates
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/block_templates.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_templates
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/reboot_block.rb b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/reboot_block.rb
new file mode 100644
index 0000000..e935d74
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/bluebox/requests/compute/reboot_block.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Reboot block
+        #
+        # ==== Parameters
+        # * block_id<~String> - Id of block to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def reboot_block(block_id, type = 'SOFT')
+          request(
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "api/blocks/#{block_id}/#{'soft_' if type == 'SOFT'}reboot.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_block(block_id, type = 'SOFT')
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox.rb
new file mode 100644
index 0000000..ae5c945
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox.rb
@@ -0,0 +1,7 @@
+module Fog
+  module Brightbox
+    extend Fog::Provider
+    service_path 'fog/brightbox'
+    service 'compute'
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/bin.rb
new file mode 100644
index 0000000..58067f8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/bin.rb
@@ -0,0 +1,19 @@
+class Brightbox < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Brightbox::Compute.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/compute.rb
new file mode 100644
index 0000000..5715ac0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/compute.rb
@@ -0,0 +1,124 @@
+module Fog
+  module Brightbox
+    class Compute < Fog::Service
+
+      AUTHENTICATION_URL = "https://auth.api.gb1.brightbox.com/token"
+      API_URL = "https://api.gb1.brightbox.com/"
+
+      requires :brightbox_client_id, :brightbox_secret
+
+      model_path 'fog/brightbox/models/compute'
+      collection :servers
+      model :server
+      collection :flavors
+      model :flavor
+      collection :images
+      model :image
+      collection :zones
+      model :zone
+      collection :cloud_ips
+      model :cloud_ip
+      collection :users
+      model :user
+
+      request_path 'fog/brightbox/requests/compute'
+      request :create_account
+      request :create_api_client
+      request :create_cloud_ip
+      request :create_image
+      request :create_server
+      request :destroy_api_client
+      request :destroy_cloud_ip
+      request :destroy_image
+      request :destroy_server
+      request :get_account
+      request :get_api_client
+      request :get_cloud_ip
+      request :get_image
+      request :get_interface
+      request :get_server
+      request :get_server_type
+      request :get_user
+      request :get_zone
+      request :list_accounts
+      request :list_api_clients
+      request :list_cloud_ips
+      request :list_images
+      request :list_server_types
+      request :list_servers
+      request :list_users
+      request :list_zones
+      request :map_cloud_ip
+      request :rebuild_server
+      request :reset_ftp_password_account
+      request :resize_server
+      request :restart_server
+      request :shutdown_server
+      request :snapshot_server
+      request :start_server
+      request :stop_server
+      request :unmap_cloud_ip
+      request :update_account
+      request :update_api_client
+      request :update_image
+      request :update_server
+      request :update_user
+
+      class Mock
+
+        def request(options)
+          raise "Not implemented"
+        end
+      end
+
+      class Real
+
+        def initialize(options)
+          get_oauth_token(options)
+          api_url = options[:brightbox_api_url] || Fog.credentials[:brightbox_api_url] || API_URL
+          @connection = Fog::Connection.new(api_url)
+        end
+
+        def request(params)
+          begin
+            response = authenticated_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            get_oauth_token
+            response = authenticated_request(params)
+          end
+          response
+        end
+
+      private
+        def get_oauth_token(options = {})
+          @brightbox_client_id ||= options[:brightbox_client_id]
+          @brightbox_secret ||= options[:brightbox_secret]
+          auth_url = options[:brightbox_auth_url] || Fog.credentials[:brightbox_auth_url] || AUTHENTICATION_URL
+
+          connection = Fog::Connection.new(auth_url)
+          @authentication_body = {'client_id' => @brightbox_client_id, 'grant_type' => 'none'}.to_json
+
+          response = connection.request({
+            :path => "/token",
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic " + Base64.encode64("#{@brightbox_client_id}:#{@brightbox_secret}").chomp,
+              'Content-Type' => 'application/json'
+            },
+            :method   => 'POST',
+            :body     => @authentication_body
+          })
+          @oauth_token = JSON.parse(response.body)["access_token"]
+          return @oauth_token
+        end
+
+        def authenticated_request(options)
+          headers = options[:headers] || {}
+          headers.merge!("Authorization" => "OAuth #{@oauth_token}")
+          options[:headers] = headers
+          @connection.request(options)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/cloud_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/cloud_ip.rb
new file mode 100644
index 0000000..c6b7bb6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/cloud_ip.rb
@@ -0,0 +1,38 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIp < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+        attribute :reverse_dns
+        attribute :public_ip
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :interface_id, :aliases => "interface", :squash => "id"
+        attribute :server_id, :aliases => "server", :squash => "id"
+
+        def map(interface_to_map)
+          requires :identity
+          connection.map_cloud_ip(identity, :interface => interface_to_map)
+        end
+
+        def unmap
+          requires :identity
+          connection.unmap_cloud_ip(identity)
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/cloud_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/cloud_ips.rb
new file mode 100644
index 0000000..6f8242d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/cloud_ips.rb
@@ -0,0 +1,34 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/cloud_ip'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIps < Fog::Collection
+
+        model Fog::Brightbox::Compute::CloudIp
+
+        def all
+          data = JSON.parse(connection.list_cloud_ips.body)
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = JSON.parse(connection.get_cloud_ip(identifier).body)
+          new(data) # data is an attribute hash
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def allocate
+          data = JSON.parse(connection.create_cloud_ip.body)
+          new(data)
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/flavor.rb
new file mode 100644
index 0000000..6c5e0ac
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/flavor.rb
@@ -0,0 +1,29 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        # Need to convert units into standardised Fogs values
+        attribute :handle
+        attribute :bits
+        attribute :cores
+        attribute :disk, :aliases => "disk_size"
+        attribute :name
+        attribute :ram
+
+        attribute :resource_type
+        attribute :description
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/flavors.rb
new file mode 100644
index 0000000..9f9709e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/flavor'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Brightbox::Compute::Flavor
+
+        def all
+          data = connection.list_server_types.body
+          load(JSON.parse(data))
+        end
+
+        def get(identifier)
+          response = connection.get_server_type(identifier)
+          new(JSON.parse(response.body))
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/image.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/image.rb
new file mode 100644
index 0000000..a0c6152
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/image.rb
@@ -0,0 +1,33 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :source
+        attribute :source_type
+
+        attribute :ancestor_id, :aliases => "ancestor", :squash => "id"
+        attribute :owner_id, :aliases => "owner", :squash => "id"
+        attribute :arch
+
+        attribute :resource_type
+        attribute :description
+        attribute :public
+        attribute :official
+        attribute :virtual_size
+        attribute :disk_size
+        attribute :created_at
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/images.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/images.rb
new file mode 100644
index 0000000..0cdad49
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/images.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/image'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Brightbox::Compute::Image
+
+        def all
+          data = connection.list_images.body
+          load(JSON.parse(data))
+        end
+
+        def get(identifier)
+          response = connection.get_image(identifier)
+          new(JSON.parse(response.body))
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/server.rb
new file mode 100644
index 0000000..b51401f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/server.rb
@@ -0,0 +1,79 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Server < Fog::Model
+
+        identity  :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :hostname
+        attribute :created_at, :type => :time
+        attribute :deleted_at, :type => :time
+        attribute :started_at, :type => :time
+        attribute :user_data
+
+        attribute :resource_type
+        attribute :description
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :image_id, :aliases => "image", :squash => "id"
+        attribute :flavor_id, :aliases => "server_type", :squash => "id"
+        attribute :zone_id, :aliases => "zone", :squash => "id"
+
+        # Plural links
+        [:snapshots, :cloud_ips, :interfaces].each do |link|
+          attribute link
+          # attribute :"#{link}_hash", :aliases => "#{link}"
+          # define_method(link) do
+          #   puts "(When correctly scoped...) would do:\nconnection.#{link}"
+          # end
+        end
+
+        def reboot
+          requires :identity
+          raise "Not implemented"
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_server(identity)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(@flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(@image_id)
+        end
+
+        def ready?
+          status == 'active'
+        end
+
+        def save
+          requires :image_id
+          options = {
+            :image => @image_id,
+            :server_type => @flavor_id,
+            :name => @name,
+            :zone => @zone_id,
+            :user_data => @user_data
+          }.delete_if {|k,v| v.nil? || v == "" }
+          response = connection.create_server(options)
+          data = JSON.parse(response.body)
+          merge_attributes(data)
+          true
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/servers.rb
new file mode 100644
index 0000000..4d761d7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/servers.rb
@@ -0,0 +1,31 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/server'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Brightbox::Compute::Server
+
+        def all
+          # get list of servers
+          data = JSON.parse(connection.list_servers.body)
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          # get server matching id
+          data = JSON.parse(connection.get_server(identifier).body)
+          new(data) # data is an attribute hash
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/user.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/user.rb
new file mode 100644
index 0000000..2c7adbc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/user.rb
@@ -0,0 +1,39 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class User < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :resource_type
+        attribute :name
+        attribute :email_address
+        attribute :email_verified
+        attribute :ssh_key
+
+        attribute :account_id, :aliases => "default_account", :squash => "id"
+        attribute :accounts
+
+        def save
+          requires :identity
+
+          options = {
+            :email_address => @email_address,
+            :ssh_key => @ssh_key
+          }
+
+          response = connection.update_user(identity, options)
+          data = JSON.parse(response.body)
+          merge_attributes(data)
+          true
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/users.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/users.rb
new file mode 100644
index 0000000..4c56ba4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/users.rb
@@ -0,0 +1,29 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/user'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Users < Fog::Collection
+
+        model Fog::Brightbox::Compute::User
+
+        def all
+          data = JSON.parse(connection.list_users.body)
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = JSON.parse(connection.get_user(identifier).body)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/zone.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/zone.rb
new file mode 100644
index 0000000..a2cfab0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/zone.rb
@@ -0,0 +1,21 @@
+require 'fog/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :handle
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/zones.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/zones.rb
new file mode 100644
index 0000000..391751b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/models/compute/zones.rb
@@ -0,0 +1,31 @@
+require 'fog/collection'
+require 'fog/brightbox/models/compute/zone'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zones < Fog::Collection
+
+        model Fog::Brightbox::Compute::Zone
+
+        def all
+          # get list of zones
+          data = JSON.parse(connection.list_zones.body)
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          # get zone matching id
+          data = JSON.parse(connection.get_zone(identifier).body)
+          new(data) # data is an attribute hash
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/close_account.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/close_account.rb
new file mode 100644
index 0000000..7d0de12
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/close_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def close_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'POST',
+            :path     => "/api/v1/accounts/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def close_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_account.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_account.rb
new file mode 100644
index 0000000..7dbbfff
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_account(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/accounts",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_account(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_api_client.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_api_client.rb
new file mode 100644
index 0000000..70ca4e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_api_client(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_api_client(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_cloud_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_cloud_ip.rb
new file mode 100644
index 0000000..e71f105
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_cloud_ip(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_cloud_ip(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_image.rb
new file mode 100644
index 0000000..d020b76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_image(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_image(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_server.rb
new file mode 100644
index 0000000..fc70bc7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_server(options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_server(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_user.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_user.rb
new file mode 100644
index 0000000..6c16b48
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/create_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_user(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/api/v1/users",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_user(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_api_client.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_api_client.rb
new file mode 100644
index 0000000..d2ca8a3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_api_client(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
new file mode 100644
index 0000000..38c8dba
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_image.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_image.rb
new file mode 100644
index 0000000..2c48673
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_image(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_server.rb
new file mode 100644
index 0000000..083f7b4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/destroy_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_account.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_account.rb
new file mode 100644
index 0000000..7621cc9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/accounts/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_api_client.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_api_client.rb
new file mode 100644
index 0000000..fd3cd0a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_api_client(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_cloud_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_cloud_ip.rb
new file mode 100644
index 0000000..a368396
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_image.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_image.rb
new file mode 100644
index 0000000..31d67ab
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_image(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_interface.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_interface.rb
new file mode 100644
index 0000000..b6774bd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_interface.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_interface(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/interfaces/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_interface(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_server.rb
new file mode 100644
index 0000000..0c07f10
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_server_type.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_server_type.rb
new file mode 100644
index 0000000..bb39262
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_server_type.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server_type(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server_type(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_user.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_user.rb
new file mode 100644
index 0000000..2703696
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_user(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_user(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_zone.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_zone.rb
new file mode 100644
index 0000000..ad15416
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/get_zone.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_zone(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_accounts.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_accounts.rb
new file mode 100644
index 0000000..71e6ad1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_accounts.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_accounts(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/accounts",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_accounts(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_api_clients.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_api_clients.rb
new file mode 100644
index 0000000..c7bf4f7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_api_clients.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_api_clients(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_api_clients(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_cloud_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_cloud_ips.rb
new file mode 100644
index 0000000..e2a8388
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_cloud_ips.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_cloud_ips(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_cloud_ips(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_images.rb
new file mode 100644
index 0000000..900d058
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_images.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_images(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_interfaces.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_interfaces.rb
new file mode 100644
index 0000000..ba4357f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_interfaces.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_interfaces(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/api/v1/interfaces",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_interfaces(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_server_types.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_server_types.rb
new file mode 100644
index 0000000..728c797
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_server_types.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_server_types(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_server_types(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_servers.rb
new file mode 100644
index 0000000..1806b5d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_servers.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_servers(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_users.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_users.rb
new file mode 100644
index 0000000..bcd933c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_users.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_users(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_users(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_zones.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_zones.rb
new file mode 100644
index 0000000..a9e8738
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/list_zones.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_zones(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_zones(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/map_cloud_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/map_cloud_ip.rb
new file mode 100644
index 0000000..6b5440e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/map_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def map_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/map",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def map_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/rebuild_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/rebuild_server.rb
new file mode 100644
index 0000000..52d0fd5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/rebuild_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def rebuild_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/rebuild",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def rebuild_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
new file mode 100644
index 0000000..005f40c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def reset_ftp_password_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'POST',
+            :path     => "/1.0/accounts/#{identifier}/reset_ftp_password",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reset_ftp_password_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/resize_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/resize_server.rb
new file mode 100644
index 0000000..b22f36a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/resize_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def resize_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/resize",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def resize_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/restart_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/restart_server.rb
new file mode 100644
index 0000000..9010f14
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/restart_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def restart_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/restart",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def restart_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/shutdown_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/shutdown_server.rb
new file mode 100644
index 0000000..082be44
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/shutdown_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def shutdown_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/shutdown",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def shutdown_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/snapshot_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/snapshot_server.rb
new file mode 100644
index 0000000..d3fbbcb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/snapshot_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def snapshot_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/snapshot",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def snapshot_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/start_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/start_server.rb
new file mode 100644
index 0000000..e39bb46
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/start_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def start_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/start",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def start_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/stop_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/stop_server.rb
new file mode 100644
index 0000000..8a2c19d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/stop_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def stop_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/stop",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def stop_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
new file mode 100644
index 0000000..c9e6dc8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def unmap_cloud_ip(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/unmap",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def unmap_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_account.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_account.rb
new file mode 100644
index 0000000..0df9d3d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_account(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/accounts/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_account(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_api_client.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_api_client.rb
new file mode 100644
index 0000000..1f19832
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_api_client(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_image.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_image.rb
new file mode 100644
index 0000000..f86e698
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_image(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_server.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_server.rb
new file mode 100644
index 0000000..45a13ad
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_server(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_user.rb b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_user.rb
new file mode 100644
index 0000000..5c75b2e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/brightbox/requests/compute/update_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_user(identifier, options = {})
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_user(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/collection.rb b/lib/bbcloud/vendor/fog/lib/fog/collection.rb
new file mode 100644
index 0000000..8bace39
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/collection.rb
@@ -0,0 +1,121 @@
+module Fog
+  class Collection < Array
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    Array.public_instance_methods(false).each do |method|
+      class_eval <<-RUBY
+        def #{method}(*args)
+          unless @loaded
+            lazy_load
+          end
+          super
+        end
+      RUBY
+    end
+
+    %w[reject select].each do |method|
+      class_eval <<-RUBY
+        def #{method}(*args)
+          unless @loaded
+            lazy_load
+          end
+          data = super
+          result = self.clone.clear.concat(data)
+        end
+      RUBY
+    end
+
+    def self.model(new_model=nil)
+      if new_model == nil
+        @model
+      else
+        @model = new_model
+      end
+    end
+
+    attr_accessor :connection
+
+    def clear
+      @loaded = true
+      super
+    end
+
+    def create(attributes = {})
+      object = new(attributes)
+      object.save
+      object
+    end
+
+    def initialize(attributes = {})
+      merge_attributes(attributes)
+    end
+
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}\n"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+          data << "\n"
+        end
+        data << "#{Thread.current[:formatador].indentation}["
+        unless self.empty?
+          data << "\n"
+          Thread.current[:formatador].indent do
+            data << self.map {|member| member.inspect}.join(",\n")
+            data << "\n"
+          end
+          data << Thread.current[:formatador].indentation
+        end
+        data << "]\n"
+      end
+      data << "#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def load(objects)
+      clear
+      for object in objects
+        self << new(object)
+      end
+      self
+    end
+
+    def model
+      self.class.instance_variable_get('@model')
+    end
+
+    def new(attributes = {})
+      model.new(
+        attributes.merge(
+          :collection => self,
+          :connection => connection
+        )
+      )
+    end
+
+    def reload
+      clear
+      lazy_load
+      self
+    end
+
+    def table(attributes = nil)
+      Formatador.display_table(self.map {|instance| instance.attributes}, attributes)
+    end
+
+    def to_json
+      self.map {|member| member}.to_json
+    end
+
+    private
+
+    def lazy_load
+      self.all
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/connection.rb b/lib/bbcloud/vendor/fog/lib/fog/connection.rb
new file mode 100644
index 0000000..9a4d819
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/connection.rb
@@ -0,0 +1,35 @@
+module Fog
+  class Connection
+
+    def initialize(url, persistent=false)
+      @excon = Excon.new(url)
+      @persistent = persistent
+    end
+
+    def request(params, &block)
+      unless @persistent
+        reset
+      end
+      unless block_given?
+        if (parser = params.delete(:parser))
+          body = Nokogiri::XML::SAX::PushParser.new(parser)
+          block = lambda { |chunk| body << chunk }
+        end
+      end
+
+      response = @excon.request(params, &block)
+
+      if parser
+        body.finish
+        response.body = parser.response
+      end
+
+      response
+    end
+
+    def reset
+      @excon.reset
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/credentials.rb b/lib/bbcloud/vendor/fog/lib/fog/credentials.rb
new file mode 100644
index 0000000..1485b01
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/credentials.rb
@@ -0,0 +1,58 @@
+require 'yaml'
+module Fog
+  class << self
+
+    def credential=(new_credential)
+      @credential = new_credential
+      @credentials = nil
+    end
+
+    def credential
+      @credential || :default
+    end
+
+    def config_path
+      ENV["FOG_RC"] || '~/.fog'
+    end
+
+    def credentials
+      @credentials ||= begin
+        path = File.expand_path(config_path)
+        credentials = if File.exists?(path)
+          File.open(path) do |file|
+            YAML.load(file.read)
+          end
+        else
+          nil
+        end
+        unless credentials && credentials[credential]
+          print("\n  To run as '#{credential}', add the following to #{config_path}\n")
+          yml = <<-YML
+
+:#{credential}:
+  :aws_access_key_id:     INTENTIONALLY_LEFT_BLANK
+  :aws_secret_access_key: INTENTIONALLY_LEFT_BLANK
+  :bluebox_api_key:       INTENTIONALLY_LEFT_BLANK
+  :bluebox_customer_id:   INTENTIONALLY_LEFT_BLANK
+  :brightbox_client_id:   INTENTIONALLY_LEFT_BLANK
+  :brightbox_secret:      INTENTIONALLY_LEFT_BLANK
+  :local_root:            INTENTIONALLY_LEFT_BLANK
+  :new_servers_password:  INTENTIONALLY_LEFT_BLANK
+  :new_servers_username:  INTENTIONALLY_LEFT_BLANK
+  :public_key_path:       INTENTIONALLY_LEFT_BLANK
+  :private_key_path:      INTENTIONALLY_LEFT_BLANK
+  :rackspace_api_key:     INTENTIONALLY_LEFT_BLANK
+  :rackspace_username:    INTENTIONALLY_LEFT_BLANK
+  :slicehost_password:    INTENTIONALLY_LEFT_BLANK
+  :terremark_username:    INTENTIONALLY_LEFT_BLANK
+  :terremark_password:    INTENTIONALLY_LEFT_BLANK
+YML
+          print(yml)
+          raise(ArgumentError.new("Missing Credentials"))
+        end
+        credentials[credential]
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/deprecation.rb b/lib/bbcloud/vendor/fog/lib/fog/deprecation.rb
new file mode 100644
index 0000000..110d011
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/deprecation.rb
@@ -0,0 +1,17 @@
+module Fog
+  module Deprecation
+
+    def deprecate(older, newer)
+      class_eval <<-EOS, __FILE__, __LINE__
+        def #{older}(*args)
+          location = caller.first
+          warning = "[yellow][WARN] #{self} => ##{older} is deprecated, use ##{newer} instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          send(:#{newer}, *args)
+        end
+      EOS
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/errors.rb b/lib/bbcloud/vendor/fog/lib/fog/errors.rb
new file mode 100644
index 0000000..e42d9a0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/errors.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Errors
+
+    class Error < StandardError
+      attr_accessor :verbose
+
+      def self.slurp(error, message = nil)
+        new_error = new(message)
+        new_error.set_backtrace(error.backtrace)
+        new_error.verbose = error.message
+        new_error
+      end
+    end
+
+    class MockNotImplemented < Fog::Errors::Error; end
+
+    class NotFound < Fog::Errors::Error; end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid.rb
new file mode 100644
index 0000000..c211729
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid.rb
@@ -0,0 +1,18 @@
+module Fog
+  module GoGrid
+
+    extend Fog::Provider
+
+    service_path 'fog/go_grid'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::GoGrid#new is deprecated, use Fog::GoGrid::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Bluebox::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/bin.rb
new file mode 100644
index 0000000..7869dda
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/bin.rb
@@ -0,0 +1,25 @@
+class GoGrid < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::GoGrid::Compute.new
+        when :servers
+          location = caller.first
+          warning = "[yellow][WARN] GoGrid[:servers] is deprecated, use GoGrid[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::GoGrid::Compute.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/compute.rb
new file mode 100644
index 0000000..69c60e3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/compute.rb
@@ -0,0 +1,96 @@
+module Fog
+  module GoGrid
+    class Compute < Fog::Service
+
+      requires :go_grid_api_key
+      requires :go_grid_shared_secret
+
+      model_path 'fog/go_grid/models/compute'
+
+      request_path 'fog/go_grid/requests/compute'
+      request :common_lookup_list
+      request :grid_image_list
+      request :grid_ip_list
+      request :grid_loadbalancer_list
+      request :grid_server_add
+      request :grid_server_delete
+      request :grid_server_get
+      request :grid_server_list
+      request :grid_server_power
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @go_grid_api_key = options[:go_grid_api_key]
+          @go_grid_shared_secret = options[:go_grid_shared_secret]
+          @data = self.class.data[@go_grid_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @go_grid_api_key = options[:go_grid_api_key]
+          @go_grid_shared_secret = options[:go_grid_shared_secret]
+          @host   = options[:host]    || "api.gogrid.com"
+          @path   = options[:path]    || "/api"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params = {
+            :expects  => 200,
+            :method   => 'GET'
+          }.merge!(params)
+
+          params[:query] ||= {}
+          params[:query].merge!({
+            'api_key' => @go_grid_api_key,
+            'format'  => 'json',
+            'sig'     => Digest::MD5.hexdigest("#{@go_grid_api_key}#{@go_grid_shared_secret}#{Time.now.to_i}"),
+            'v'       => '1.4'
+          })
+
+          begin
+            response = @connection.request(
+              params.merge!(:path => "#{@path}/#{params[:path]}")
+            )
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::GoGrid::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/common_lookup_list.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/common_lookup_list.rb
new file mode 100644
index 0000000..227461d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/common_lookup_list.rb
@@ -0,0 +1,36 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List options and lookups
+        #
+        # ==== Parameters
+        # * 'lookup'<~String> - the lookup to be listed
+        # * options<~Hash>:
+        #   * 'sort'<~String> - column to sort result by in ['description', 'id', 'name']
+        #   * 'asc'<~String>  - order to sort in ['true','false']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def common_lookup_list(lookup, options={})
+          request(
+            :path     => 'common/lookup/list',
+            :query    => {'lookup' => lookup}.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def common_lookup_list(lookup, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_image_list.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_image_list.rb
new file mode 100644
index 0000000..85d2cd5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_image_list.rb
@@ -0,0 +1,39 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isPublic'<~String>   - If true only returns public images, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer>      - Page index for paginated results
+        #   * 'state'<~String>      - state to limit results to, in ['Saving', 'Available']
+        #   * 'type'<~String>       - image type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_image_list(options={})
+          request(
+            :path     => 'grid/image/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_image_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_ip_list.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_ip_list.rb
new file mode 100644
index 0000000..907c6e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_ip_list.rb
@@ -0,0 +1,38 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List ips
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'ip.state'<~String>      - state to limit results to in ip.state
+        #   * 'ip.type'<~String>       - type to limit results to in ip.type
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer>      - Page index for paginated results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_ip_list(options={})
+          request(
+            :path     => 'grid/ip/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_ip_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb
new file mode 100644
index 0000000..7fecf61
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb
@@ -0,0 +1,36 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List load balancers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_loadbalancer_list(options={})
+          request(
+            :path     => 'grid/loadbalancer/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_loadbalancer_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_add.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_add.rb
new file mode 100644
index 0000000..3870df8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_add.rb
@@ -0,0 +1,44 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Create a new server
+        #
+        # ==== Parameters
+        # * 'image'<~String>  - image to use, in grid_image_list
+        # * 'ip'<~String> - initial public ip for this server
+        # * 'name'<~String>   - name of the server, 20 or fewer characters
+        # * 'server_ram'<~String> - flavor to use, in common_lookup_list('server.ram')
+        # * 'options'<~Hash>:
+        #   * 'description'<~String>  - description of this server
+        #   * 'isSandbox'<~String>    - treat this server as image sandbox? in ['true', 'false']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_add(image, ip, name, server_ram, options={})
+          request(
+            :path     => 'grid/server/add',
+            :query    => {
+              'image'       => image,
+              'ip'          => ip,
+              'name'        => name,
+              'server.ram'  => server_ram
+            }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_add(image, ip, name, server_ram, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_delete.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_delete.rb
new file mode 100644
index 0000000..a1fc331
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_delete.rb
@@ -0,0 +1,33 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Delete a server
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_delete(server)
+          request(
+            :path     => 'grid/server/delete',
+            :query    => {'server' => server}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_delete(server)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_get.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_get.rb
new file mode 100644
index 0000000..abee279
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_get.rb
@@ -0,0 +1,33 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Get one or more servers by name
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server(s) to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_get(servers)
+          request(
+            :path     => 'grid/server/get',
+            :query    => {'server' => [*servers]}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_get(servers)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_list.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_list.rb
new file mode 100644
index 0000000..5319b5c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_list.rb
@@ -0,0 +1,38 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isSandbox'<~String> - If true only  returns Image Sandbox servers, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #   * 'server.type'<~String> - server type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_list(options={})
+          request(
+            :path     => 'grid/server/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_power.rb b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_power.rb
new file mode 100644
index 0000000..844aa15
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/go_grid/requests/compute/grid_server_power.rb
@@ -0,0 +1,34 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Start, Stop or Restart a server
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server to power
+        # * 'power'<~String>  - power operation, in ['restart', 'start', 'stop']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_delete(server, power)
+          request(
+            :path     => 'grid/server/power',
+            :query    => {'server' => server}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_delete(server)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/hmac.rb b/lib/bbcloud/vendor/fog/lib/fog/hmac.rb
new file mode 100644
index 0000000..8051947
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/hmac.rb
@@ -0,0 +1,48 @@
+module Fog
+  class HMAC
+
+    def initialize(type, key)
+      @key = key
+      case type
+      when 'sha1'
+        setup_sha1
+      when 'sha256'
+        setup_sha256
+      end
+    end
+
+    def sign(data)
+      @signer.call(data)
+    end
+
+    private
+
+    def setup_sha1
+      @digest = OpenSSL::Digest::Digest.new('sha1')
+      @signer = lambda do |data|
+        OpenSSL::HMAC.digest(@digest, @key, data)
+      end
+    end
+
+    def setup_sha256
+      begin
+        @digest = OpenSSL::Digest::Digest.new('sha256')
+        @signer = lambda do |data|
+          OpenSSL::HMAC.digest(@digest, @key, data)
+        end
+      rescue RuntimeError => error
+        unless error.message == 'Unsupported digest algorithm (sha256).'
+          raise error
+        else
+          require 'hmac-sha2'
+          @hmac = ::HMAC::SHA256.new(@key)
+          @signer = lambda do |data|
+            @hmac.update(data)
+            @hmac.digest
+          end
+        end
+      end
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode.rb b/lib/bbcloud/vendor/fog/lib/fog/linode.rb
new file mode 100644
index 0000000..48eda58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Linode
+
+    extend Fog::Provider
+
+    service_path 'fog/linode'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Linode#new is deprecated, use Fog::Linode::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Linode::Compute.new(attributes)
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/bin.rb
new file mode 100644
index 0000000..cf0fbda
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/bin.rb
@@ -0,0 +1,25 @@
+class Linode < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Linode::Compute.new
+        when :linode
+          location = caller.first
+          warning = "[yellow][WARN] Linode[:linode] is deprecated, use Linode[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::Linode::Compute.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/compute.rb
new file mode 100644
index 0000000..eac1df3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/compute.rb
@@ -0,0 +1,79 @@
+module Fog
+  module Linode
+    class Compute < Fog::Service
+
+      requires :linode_api_key
+
+      model_path 'fog/linode/models/compute'
+
+      request_path 'fog/linode/requests/compute'
+      request :avail_datacenters
+      request :avail_distributions
+      request :avail_kernels
+      request :avail_linodeplans
+      request :avail_stackscripts
+      request :linode_create
+      request :linode_delete
+      request :linode_list
+      request :linode_reboot
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @linode_api_key = options[:linode_api_key]
+          @data = self.class.data[@linode_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @linode_api_key = options[:linode_api_key]
+          @host   = options[:host]    || "api.linode.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!(:api_key => @linode_api_key)
+
+          response = @connection.request(params.merge!({:host => @host}))
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+            if data = response.body['ERRORARRAY'].first
+              error = case data['ERRORCODE']
+              when 5
+                Fog::Linode::Compute::NotFound
+              else
+                Fog::Linode::Compute::Error
+              end
+              raise error.new(data['ERRORMESSAGE'])
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_datacenters.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_datacenters.rb
new file mode 100644
index 0000000..4517303
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_datacenters.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available data centers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_datacenters
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.datacenters' }
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_datacenters
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_distributions.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_distributions.rb
new file mode 100644
index 0000000..d61e382
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_distributions.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available distributions
+        #
+        # ==== Parameters
+        # * distributionId<~Integer>: id to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_distributions(distribution_id=nil)
+          options = {}
+          if distribution_id
+            options.merge!(:distributionId => distribution_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.distributions' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_distributions(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_kernels.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_kernels.rb
new file mode 100644
index 0000000..f402fd8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_kernels.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available kernels
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * kernelId<~Integer>: id to limit results to
+        #   * isXen<~Integer>: if 1 limits results to only zen
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_kernels(options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.kernels' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_kernels(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_linodeplans.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_linodeplans.rb
new file mode 100644
index 0000000..55571cb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_linodeplans.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available plans
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_linodeplans(linodeplan_id=nil)
+          options = {}
+          if linodeplan_id
+            options.merge!(:planId => linodeplan_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.linodeplans' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_linodeplans
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_stackscripts.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_stackscripts.rb
new file mode 100644
index 0000000..9570595
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/avail_stackscripts.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available stack scripts
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * distributionId<~Integer>: Limit the results to Stackscripts that can be applied to this distribution id
+        #   * distributionVendor<~String>: Debian, Ubuntu, Fedora, etc.
+        #   * keywords<~String>: Search terms
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_stackscripts(options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.stackscripts' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_stackscripts(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_create.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_create.rb
new file mode 100644
index 0000000..4de8264
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_create.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Creates a linode and assigns you full privileges
+        #
+        # ==== Parameters
+        # * datacenter_id<~Integer>: id of datacenter to place new linode in
+        # * payment_term<~Integer>: Subscription term in months, in [1, 12, 24]
+        # * plan_id<~Integer>: id of plan to boot new linode with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_create(datacenter_id, payment_term, plan_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'linode.create',
+              :datacenterId => datacenter_id,
+              :paymentTerm  => payment_term,
+              :planId       => plan_id
+            }
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_create(datacenter_id, payment_term, plan_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_delete.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_delete.rb
new file mode 100644
index 0000000..84938cb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_delete.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # List all linodes user has access or delete to
+        #
+        # ==== Parameters
+        # * linode_id<~Integer>: id of linode to delete
+        # * options<~Hash>:
+        #   * skipChecks<~Boolean>: skips safety checks and always deletes
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_delete(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.delete', :linodeId => linode_id }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_delete(linode_id, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_list.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_list.rb
new file mode 100644
index 0000000..3baf8d0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_list.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # List all linodes user has access or delete to
+        #
+        # ==== Parameters
+        # * linodeId<~Integer>: Limit the list to the specified LinodeID
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_list(linode_id=nil)
+          options = {}
+          if linode_id
+            options.merge!(:linodeId => linode_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.list' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_reboot.rb b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_reboot.rb
new file mode 100644
index 0000000..cc30baf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/linode/requests/compute/linode_reboot.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Issues a shutdown, and then a boot job for a given linode
+        #
+        # ==== Parameters
+        # * linode_id<~Integer>: id of linode to reboot
+        # * options<~Hash>:
+        #   * configId<~Boolean>: id of config to boot server with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_reboot(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.reboot', :linodeId => linode_id }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_reboot(linode_id, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local.rb b/lib/bbcloud/vendor/fog/lib/fog/local.rb
new file mode 100644
index 0000000..ffe4eb7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Local
+
+    extend Fog::Provider
+
+    service_path 'fog/local'
+    service 'storage'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Local#new is deprecated, use Fog::Local::Storage#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Local::Storage.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/local/bin.rb
new file mode 100644
index 0000000..bd753de
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local/bin.rb
@@ -0,0 +1,25 @@
+class Local < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :files
+          location = caller.first
+          warning = "[yellow][WARN] Local[:files] is deprecated, use Local[:storage] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::Local::Storage.new
+        when :storage
+          Fog::Local::Storage.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/directories.rb b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/directories.rb
new file mode 100644
index 0000000..9d622c4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/directories.rb
@@ -0,0 +1,33 @@
+require 'fog/collection'
+require 'fog/local/models/storage/directory'
+
+module Fog
+  module Local
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Local::Storage::Directory
+
+        def all
+          data = Dir.entries(connection.local_root).select do |entry|
+            entry[0...1] != '.' && ::File.directory?(connection.path_to(entry))
+          end.map do |entry|
+            {:key => entry}
+          end
+          load(data)
+        end
+
+        def get(key)
+          if ::File.directory?(connection.path_to(key))
+            new(:key => key)
+          else
+            nil
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/directory.rb b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/directory.rb
new file mode 100644
index 0000000..c7edb24
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/directory.rb
@@ -0,0 +1,52 @@
+require 'fog/model'
+require 'fog/local/models/storage/files'
+
+module Fog
+  module Local
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key
+
+        def destroy
+          requires :key
+
+          if ::File.directory?(path)
+            Dir.rmdir(path)
+            true
+          else
+            false
+          end
+        end
+
+        def files
+          @files ||= begin
+            Fog::Local::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def save
+          requires :key
+
+          Dir.mkdir(path)
+          true
+        end
+
+        private
+
+        def path
+          connection.path_to(key)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/file.rb b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/file.rb
new file mode 100644
index 0000000..5825d58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/file.rb
@@ -0,0 +1,60 @@
+require 'fog/model'
+
+module Fog
+  module Local
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attr_accessor :body
+        attribute :content_length,  :aliases => 'Content-Length'
+        # attribute :content_type,    :aliases => 'Content-Type'
+        attribute :last_modified,   :aliases => 'Last-Modified'
+
+        def body
+          @body ||= if last_modified
+            collection.get(identity).body
+          else
+            ''
+          end
+        end
+
+        def directory
+          @directory
+        end
+
+        def destroy
+          requires :directory, :key
+          ::File.delete(path)
+          true
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          file = ::File.new(path, 'w')
+          file.write(body)
+          file.close
+          merge_attributes(
+            :content_length => ::File.size(path),
+            :last_modified  => ::File.mtime(path)
+          )
+          true
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+        def path
+          connection.path_to(::File.join(directory.key, key))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/files.rb b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/files.rb
new file mode 100644
index 0000000..fe19c0f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local/models/storage/files.rb
@@ -0,0 +1,73 @@
+require 'fog/collection'
+require 'fog/local/models/storage/file'
+
+module Fog
+  module Local
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :directory
+
+        model Fog::Local::Storage::File
+
+        def all
+          requires :directory
+          if directory.collection.get(directory.key)
+            data = Dir.entries(connection.path_to(directory.key)).select do |key|
+              key[0...1] != '.' && !::File.directory?(connection.path_to(key))
+            end.map do |key|
+              path = file_path(key)
+              {
+                :content_length => ::File.size(path),
+                :key            => key,
+                :last_modified  => ::File.mtime(path)
+              }
+            end
+            load(data)
+          else
+            nil
+          end
+        end
+
+        def get(key, &block)
+          requires :directory
+          path = file_path(key)
+          if ::File.exists?(path)
+            data = {
+              :content_length => ::File.size(path),
+              :key            => key,
+              :last_modified  => ::File.mtime(path)
+            }
+            if block_given?
+              file = ::File.open(path)
+              while (chunk = file.read(Excon::CHUNK_SIZE)) && yield(chunk); end
+              file.close
+              new(data)
+            else
+              body = nil
+              ::File.open(path) do |file|
+                body = file.read
+              end
+              new(data.merge!(:body => body))
+            end
+          else
+            nil
+          end
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+        private
+
+        def file_path(key)
+          connection.path_to(::File.join(directory.key, key))
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/local/storage.rb b/lib/bbcloud/vendor/fog/lib/fog/local/storage.rb
new file mode 100644
index 0000000..be75633
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/local/storage.rb
@@ -0,0 +1,58 @@
+module Fog
+  module Local
+  class Storage < Fog::Service
+
+      requires :local_root
+
+      model_path 'fog/local/models/storage'
+      collection  :directories
+      model       :directory
+      model       :file
+      collection  :files
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @local_root = ::File.expand_path(options[:local_root])
+          @data       = self.class.data[@local_root]
+        end
+
+        def local_root
+          @local_root
+        end
+
+        def path(partial)
+          partial
+        end
+      end
+
+      class Real
+
+        def initialize(options={})
+          @local_root = ::File.expand_path(options[:local_root])
+        end
+
+        def local_root
+          @local_root
+        end
+
+        def path_to(partial)
+          ::File.join(@local_root, partial)
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/model.rb b/lib/bbcloud/vendor/fog/lib/fog/model.rb
new file mode 100644
index 0000000..7eddb11
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/model.rb
@@ -0,0 +1,57 @@
+module Fog
+  class Model
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    attr_accessor :connection
+
+    def collection
+      @collection
+    end
+
+    def initialize(new_attributes = {})
+      merge_attributes(new_attributes)
+    end
+
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "\n#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+        end
+      end
+      data << "\n#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def reload
+      if data = collection.get(identity)
+        new_attributes = data.attributes
+        merge_attributes(new_attributes)
+        self
+      end
+    end
+
+    def to_json
+      attributes.to_json
+    end
+
+    def wait_for(timeout=600, interval=1, &block)
+      reload
+      Fog.wait_for(timeout, interval) do
+        reload or raise Fog::Errors::Error.new("Reload failed, #{self.class} #{self.identity} went away.")
+        instance_eval(&block)
+      end
+    end
+
+    private
+
+    def collection=(new_collection)
+      @collection = new_collection
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers.rb
new file mode 100644
index 0000000..b5734b4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers.rb
@@ -0,0 +1,18 @@
+module Fog
+  module NewServers
+
+    extend Fog::Provider
+
+    service_path 'fog/new_servers'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::NewServers#new is deprecated, use Fog::NewServers::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::NewServers::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/bin.rb
new file mode 100644
index 0000000..097a492
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/bin.rb
@@ -0,0 +1,25 @@
+class NewServers < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::NewServers::Compute.new
+        when :new_servers
+          location = caller.first
+          warning = "[yellow][WARN] NewServers[:servers] is deprecated, use NewServers[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::NewServers::Compute.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/compute.rb
new file mode 100644
index 0000000..7b3f3f8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/compute.rb
@@ -0,0 +1,88 @@
+require 'fog/parser'
+
+module Fog
+  module NewServers
+    class Compute < Fog::Service
+
+      requires :new_servers_password
+      requires :new_servers_username
+
+      model_path 'fog/new_servers/models/compute'
+
+      request_path 'fog/new_servers/requests/compute'
+      request :add_server
+      request :cancel_server
+      request :get_server
+      request :list_images
+      request :list_plans
+      request :list_servers
+      request :reboot_server
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @new_server_username = options[:new_servers_username]
+          @data = self.class.data[@new_server_username]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @new_servers_password = options[:new_servers_password]
+          @new_servers_username = options[:new_servers_username]
+          @host   = options[:host]    || "noc.newservers.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!({
+            :password => @new_servers_password,
+            :username => @new_servers_username
+          })
+          params[:headers] ||= {}
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::NewServers::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/add_server.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/add_server.rb
new file mode 100644
index 0000000..1ad5770
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/add_server.rb
@@ -0,0 +1,41 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Boot a new server
+        #
+        # ==== Parameters
+        # * planId<~String> - The id of the plan to boot the server with
+        # * options<~Hash>: optional extra arguments
+        #   * imageId<~String>  - Optional image to boot server from
+        #   * name<~String>     - Name to boot new server with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'server'<~Hash>:
+        #       * 'id'<~String> - Id of the image
+        #
+        def add_server(plan_id, options = {})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/addServer',
+            :query    => {'planId' => plan_id}.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def add_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/cancel_server.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/cancel_server.rb
new file mode 100644
index 0000000..e81b551
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/cancel_server.rb
@@ -0,0 +1,38 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Shutdown a running server
+        #
+        # ==== Parameters
+        # * serverId<~String> - The id of the server to shutdown
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'server'<~Hash>:
+        #       * 'id'<~String> - Id of the image
+        #
+        def cancel_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/cancelServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def cancel_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/get_server.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/get_server.rb
new file mode 100644
index 0000000..ffa24a2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/get_server.rb
@@ -0,0 +1,44 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * server<~Hash>:
+        #     * 'id'<~String>     - Id of the server
+        #     * 'ip'<~Hash>:
+        #       * 'address'<~String>  - Address of the ip
+        #       * 'name'<~String>     - Name of the ip
+        #     * 'login'<~Hash>:
+        #       * 'name'<~String>     - Name of the login
+        #       * 'password'<~String> - Password of the login
+        #       * 'username'<~String> - Username of the login
+        #     * 'name'<~String>   - Name of the server
+        #     * 'notes'<~String>  - Notes about the server
+        #     * 'state'<~String>  - State of the server
+        #
+        def get_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/getServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_images.rb
new file mode 100644
index 0000000..bf70fb2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_images.rb
@@ -0,0 +1,35 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String>  - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'size'<~String> - Size of the image
+        #
+        def list_images
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listImages'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_plans.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_plans.rb
new file mode 100644
index 0000000..bd30286
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_plans.rb
@@ -0,0 +1,38 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List available plans
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'description'<~String> - Description of the plan
+        #     * 'id'<~String>     - Id of the plan
+        #     * 'name'<~String>   - Name of the plan
+        #     * 'rate'<~String>   - Cost per hour of the plan
+        #     * 'os'<~String>     - Operating system of the plan
+        #     * 'config'<~String> - Configuration of the plan
+        #
+        def list_plans
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listPlans'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_plans
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_servers.rb
new file mode 100644
index 0000000..d4d0a14
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/list_servers.rb
@@ -0,0 +1,44 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * server<~Hash>:
+        #       * 'id'<~String>     - Id of the server
+        #       * 'ip'<~Hash>:
+        #         * 'address'<~String>  - Address of the ip
+        #         * 'name'<~String>     - Name of the ip
+        #       * 'login'<~Hash>:
+        #         * 'name'<~String>     - Name of the login
+        #         * 'password'<~String> - Password of the login
+        #         * 'username'<~String> - Username of the login
+        #       * 'name'<~String>   - Name of the server
+        #       * 'notes'<~String>  - Notes about the server
+        #       * 'state'<~String>  - State of the server
+        #
+        def list_servers
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listServers'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/reboot_server.rb b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/reboot_server.rb
new file mode 100644
index 0000000..5bcb197
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/new_servers/requests/compute/reboot_server.rb
@@ -0,0 +1,32 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Reboot a running server
+        #
+        # ==== Parameters
+        # * serverId<~String> - The id of the server to reboot
+        #
+        def reboot_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/rebootServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/parser.rb b/lib/bbcloud/vendor/fog/lib/fog/parser.rb
new file mode 100644
index 0000000..2cb7df3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/parser.rb
@@ -0,0 +1,93 @@
+module Fog
+  module Parsers
+    class Base < Nokogiri::XML::SAX::Document
+
+      attr_reader :response
+
+      def initialize
+        reset
+      end
+
+      def reset
+        @response = {}
+      end
+
+      def characters(string)
+        @value ||= ''
+        @value << string.strip
+      end
+
+      def start_element(name, attrs = [])
+        @value = nil
+      end
+
+    end
+  end
+end
+
+module Fog
+  class ToHashDocument < Nokogiri::XML::SAX::Document
+
+    def initialize
+      @stack = []
+    end
+
+    def characters(string)
+      @value ||= ''
+      @value << string.strip
+    end
+
+    def end_element(name)
+      last = @stack.pop
+      if last.empty? && @value.empty?
+        @stack.last[name.to_sym] = ''
+      elsif last == {:i_nil=>"true"}
+        @stack.last[name.to_sym] = nil
+      elsif !@value.empty?
+        @stack.last[name.to_sym] = @value
+      end
+      @value = ''
+    end
+
+    def body
+      @stack.first
+    end
+
+    def response
+      body
+    end
+
+    def start_element(name, attributes = [])
+      @value = ''
+      parsed_attributes = {}
+      until attributes.empty?
+        if attributes.first.is_a?(Array)
+          key, value = attributes.shift
+        else
+          key, value = attributes.shift, attributes.shift
+        end
+        parsed_attributes[key.gsub(':','_').to_sym] = value
+      end
+      if @stack.last.is_a?(Array)
+        @stack.last << {name.to_sym => parsed_attributes}
+      else
+        data = if @stack.empty?
+          @stack.push(parsed_attributes)
+          parsed_attributes
+        elsif @stack.last[name.to_sym]
+          unless @stack.last[name.to_sym].is_a?(Array)
+            @stack.last[name.to_sym] = [@stack.last[name.to_sym]]
+          end
+          @stack.last[name.to_sym] << parsed_attributes
+          @stack.last[name.to_sym].last
+        else
+          @stack.last[name.to_sym] = {}
+          @stack.last[name.to_sym].merge!(parsed_attributes)
+          @stack.last[name.to_sym]
+        end
+        @stack.push(data)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/provider.rb b/lib/bbcloud/vendor/fog/lib/fog/provider.rb
new file mode 100644
index 0000000..484a804
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/provider.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Provider
+
+    def service_path(new_path)
+      @service_path = new_path
+    end
+
+    def service(new_service)
+      services << new_service
+      require File.join(@service_path, new_service.to_s)
+    end
+
+    def services
+      @services ||= []
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace.rb
new file mode 100644
index 0000000..bf307e9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Rackspace
+
+    extend Fog::Provider
+
+    service_path 'fog/rackspace'
+    service 'compute'
+    service 'files'
+    service 'servers'
+    service 'storage'
+
+    def self.authenticate(options)
+      rackspace_auth_url = options[:rackspace_auth_url] || "auth.api.rackspacecloud.com"
+      connection = Fog::Connection.new("https://" + rackspace_auth_url)
+      @rackspace_api_key  = options[:rackspace_api_key]
+      @rackspace_username = options[:rackspace_username]
+      response = connection.request({
+        :expects  => 204,
+        :headers  => {
+          'X-Auth-Key'  => @rackspace_api_key,
+          'X-Auth-User' => @rackspace_username
+        },
+        :host     => rackspace_auth_url,
+        :method   => 'GET',
+        :path     => 'v1.0'
+      })
+      response.headers.reject do |key, value|
+        !['X-Server-Management-Url', 'X-Storage-Url', 'X-CDN-Management-Url', 'X-Auth-Token'].include?(key)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/bin.rb
new file mode 100644
index 0000000..e4b4b76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/bin.rb
@@ -0,0 +1,33 @@
+class Rackspace < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Rackspace::Compute.new
+        when :files
+          location = caller.first
+          warning = "[yellow][WARN] Rackspace[:files] is deprecated, use Rackspace[:storage] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::Rackspace::Storage.new
+        when :servers
+          location = caller.first
+          warning = "[yellow][WARN] Rackspace[:servers] is deprecated, use Rackspace[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::Rackspace::Compute.new
+        when :storage
+          Fog::Rackspace::Storage.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute, :storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/compute.rb
new file mode 100644
index 0000000..2c22524
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/compute.rb
@@ -0,0 +1,107 @@
+module Fog
+  module Rackspace
+    class Compute < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+
+      model_path 'fog/rackspace/models/compute'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/rackspace/requests/compute'
+      request :create_image
+      request :create_server
+      request :delete_image
+      request :delete_server
+      request :get_flavor_details
+      request :get_image_details
+      request :get_server_details
+      request :list_addresses
+      request :list_private_addresses
+      request :list_public_addresses
+      request :list_flavors
+      request :list_flavors_detail
+      request :list_images
+      request :list_images_detail
+      request :list_servers
+      request :list_servers_detail
+      request :reboot_server
+      request :update_server
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :last_modified => {
+                :images  => {},
+                :servers => {}
+              },
+              :images  => {},
+              :servers => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @rackspace_username = options[:rackspace_username]
+          @data = self.class.data[@rackspace_username]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+          uri = URI.parse(credentials['X-Server-Management-Url'])
+          @host   = uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}"
+            }))
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/files.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/files.rb
new file mode 100644
index 0000000..78bdc56
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/files.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Rackspace
+    class Files
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::Rackspace::Files#new is deprecated, use Fog::Rackspace::Storage#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::Rackspace::Storage.new(attributes)
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/flavor.rb
new file mode 100644
index 0000000..ca2fbcf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :bits
+        attribute :cores
+        attribute :disk
+        attribute :name
+        attribute :ram
+
+        def bits
+          64
+        end
+
+        def cores
+          # 2 quad-cores >= 2Ghz = 8 cores
+          8 * case ram
+          when 256
+            1/64.0
+          when 512
+            1/32.0
+          when 1024
+            1/16.0
+          when 2048
+            1/8.0
+          when 4096
+            1/4.0
+          when 8192
+            1/2.0
+          when 15872
+            1
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/flavors.rb
new file mode 100644
index 0000000..ff46681
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/rackspace/models/compute/flavor'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Rackspace::Compute::Flavor
+
+        def all
+          data = connection.list_flavors_detail.body['flavors']
+          load(data)
+        end
+
+        def get(flavor_id)
+          data = connection.get_flavor_details(flavor_id).body['flavor']
+          new(data)
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/image.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/image.rb
new file mode 100644
index 0000000..efa43e0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/image.rb
@@ -0,0 +1,47 @@
+require 'fog/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :created_at,  :aliases => 'created'
+        attribute :updated_at,  :aliases => 'updated'
+        attribute :progress
+        attribute :status
+        attribute :server_id,   :aliases => 'serverId'
+
+        def server=(new_server)
+          requires :id
+
+          @server_id = new_server.id
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_image(@id)
+          true
+        end
+
+        def ready?
+          status == 'ACTIVE'
+        end
+
+        def save
+          requires :server_id
+
+          data = connection.create_image(@server_id, 'name' => name)
+          merge_attributes(data.body['image'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/images.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/images.rb
new file mode 100644
index 0000000..ded81da
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/images.rb
@@ -0,0 +1,33 @@
+require 'fog/collection'
+require 'fog/rackspace/models/compute/image'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Rackspace::Compute::Image
+
+        attribute :server
+
+        def all
+          data = connection.list_images_detail.body['images']
+          load(data)
+          if server
+            self.replace(self.select {|image| image.server_id == server.id})
+          end
+        end
+
+        def get(image_id)
+          data = connection.get_image_details(image_id).body['image']
+          new(data)
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/server.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/server.rb
new file mode 100644
index 0000000..f670977
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/server.rb
@@ -0,0 +1,124 @@
+require 'fog/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :addresses
+        attribute :flavor_id,   :aliases => 'flavorId'
+        attribute :host_id,     :aliases => 'hostId'
+        attribute :image_id,    :aliases => 'imageId'
+        attribute :metadata
+        attribute :name
+        attribute :personality
+        attribute :progress
+        attribute :status
+
+        attr_accessor :password, :username
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path
+
+        def initialize(attributes={})
+          @flavor_id ||= 1
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.delete_server(@id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(@flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(@image_id)
+        end
+
+        def images
+          requires :id
+          connection.images(:server => self)
+        end
+
+        def ready?
+          @status == 'ACTIVE'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_server(@id, type)
+          true
+        end
+
+        def private_key_path
+          File.expand_path(@private_key_path ||= Fog.credentials[:private_key_path])
+        end
+
+        def private_key
+          @private_key ||= File.read(private_key_path)
+        end
+
+        def public_key_path
+          File.expand_path(@public_key_path ||= Fog.credentials[:public_key_path])
+        end
+
+        def public_key
+          @public_key ||= File.read(public_key_path)
+        end
+
+        def save
+          requires :flavor_id, :image_id, :name
+          options = {
+            'metadata'    => @metadata,
+            'name'        => @name,
+            'personality' => @personality
+          }
+          options = options.reject {|key, value| value.nil?}
+          data = connection.create_server(@flavor_id, @image_id, options)
+          merge_attributes(data.body['server'])
+          true
+        end
+
+        def setup(credentials = {})
+          requires :addresses, :identity, :public_key, :username
+          Fog::SSH.new(addresses['public'].first, username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json},
+            %{echo "#{metadata.to_json}" >> ~/metadata.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :addresses, :identity, :private_key, :username
+          @ssh ||= Fog::SSH.new(addresses['public'].first, username, :key_data => [private_key])
+          @ssh.run(commands)
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        private
+
+        def adminPass=(new_admin_pass)
+          @password = new_admin_pass
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/servers.rb
new file mode 100644
index 0000000..efb03b6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/compute/servers.rb
@@ -0,0 +1,36 @@
+require 'fog/collection'
+require 'fog/rackspace/models/compute/server'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Rackspace::Compute::Server
+
+        def all
+          data = connection.list_servers_detail.body['servers']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:password => server.password)
+          server
+        end
+
+        def get(server_id)
+          if server = connection.get_server_details(server_id).body['server']
+            new(server)
+          end
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/directories.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/directories.rb
new file mode 100644
index 0000000..aa97c79
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/directories.rb
@@ -0,0 +1,34 @@
+require 'fog/collection'
+require 'fog/rackspace/models/storage/directory'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Rackspace::Storage::Directory
+
+        def all
+          data = connection.get_containers.body
+          load(data)
+        end
+
+        def get(key, options = {})
+          data = connection.get_container(key, options).body
+          directory = new(:key => key)
+          directory.files.merge_attributes(options)
+          directory.files.instance_variable_set(:@loaded, true)
+          data.each do |file|
+            directory.files << directory.files.new(file)
+          end
+          directory
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/directory.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/directory.rb
new file mode 100644
index 0000000..85f41ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/directory.rb
@@ -0,0 +1,45 @@
+require 'fog/model'
+require 'fog/rackspace/models/storage/files'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key, :aliases => 'name'
+
+        attribute :bytes
+        attribute :count
+
+        def destroy
+          requires :key
+          connection.delete_container(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def files
+          @files ||= begin
+            Fog::Rackspace::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def save
+          requires :key
+          connection.put_container(key)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/file.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/file.rb
new file mode 100644
index 0000000..b4d6ac9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/file.rb
@@ -0,0 +1,61 @@
+require 'fog/model'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attr_accessor :body
+        attribute :content_length,  :aliases => 'Content-Length'
+        attribute :content_type,    :aliases => 'Content-Type'
+        attribute :etag,            :aliases => 'Etag'
+        attribute :last_modified,   :aliases => 'Last-Modified'
+
+        def body
+          @body ||= if last_modified
+            collection.get(identity).body
+          else
+            ''
+          end
+        end
+
+        def directory
+          @directory
+        end
+
+        def destroy
+          requires :directory, :key
+          connection.delete_object(directory.name, @key)
+          true
+        end
+
+        def owner=(new_owner)
+          if new_owner
+            @owner = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def save
+          requires :body, :directory, :key
+          data = connection.put_object(directory.name, @key, @body)
+          @etag = data.headers['ETag']
+          true
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/files.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/files.rb
new file mode 100644
index 0000000..55f7c3a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/models/storage/files.rb
@@ -0,0 +1,83 @@
+require 'fog/collection'
+require 'fog/rackspace/models/storage/file'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :directory
+        attribute :limit
+        attribute :marker
+        attribute :path
+        attribute :prefix
+
+        model Fog::Rackspace::Storage::File
+
+        def all(options = {})
+          requires :directory
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(key, options = {}, &block)
+          requires :directory
+          options = {
+            'limit'   => @limit,
+            'marker'  => @marker,
+            'path'    => @path,
+            'prefix'  => @prefix
+          }.merge!(options)
+          data = connection.get_object(directory.name, key, options, &block)
+          file_data = {
+            :body => data.body,
+            :key  => key
+          }
+          for key, value in data.headers
+            if ['Content-Length', 'Content-Type', 'ETag', 'Last-Modified'].include?(key)
+              file_data[key] = value
+            end
+          end
+          new(file_data)
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.name, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.name, key, options)
+          file_data = { :key => key }
+          for key, value in data.headers
+            if ['Content-Length', 'Content-Type', 'ETag', 'Last-Modified'].include?(key)
+              file_data[key] = value
+            end
+          end
+          new(file_data)
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/create_image.rb
new file mode 100644
index 0000000..6a4fdc4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/create_image.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Create an image from a running server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to create image from
+        # * options<~Hash> - Name
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'image'<~Hash>:
+        #     * 'id'<~Integer> - Id of image
+        #     * 'name'<~String> - Name of image
+        #     * 'serverId'<~Integer> - Id of server
+        def create_image(server_id, options = {})
+          data = {
+            'image' => {
+              'serverId' => server_id
+            }
+          }
+          if options['name']
+            data['image']['name'] = options['name']
+          end
+          request(
+            :body     => data.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => "images"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_image(server_id, options = {})
+          response = Excon::Response.new
+          response.status = 202
+
+          now = Time.now
+          data = {
+            'created'   => now,
+            'id'        => 123456,
+            'name'      => options['name'] || '',
+            'serverId'  => server_id,
+            'status'    => 'SAVING',
+            'updated'   => now,
+          }
+
+          @data[:last_modified][:images][data['id']] = now
+          @data[:images][data['id']] = data
+          response.body = { 'image' => data.reject {|key, value| !['id', 'name', 'serverId'].include?(key)} }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/create_server.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/create_server.rb
new file mode 100644
index 0000000..3972a97
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/create_server.rb
@@ -0,0 +1,94 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Create a new server
+        #
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor for server
+        # * image_id<~Integer> - Id of image for server
+        # * name<~String> - Name of server
+        # * options<~Hash>:
+        #   * 'metadata'<~Hash> - Up to 5 key value pairs containing 255 bytes of info
+        #   * 'name'<~String> - Name of server, defaults to "slice#{id}"
+        #   * 'personality'<~Array>: Up to 5 files to customize server
+        #     * file<~Hash>:
+        #       * 'contents'<~String> - Contents of file (10kb total of contents)
+        #       * 'path'<~String> - Path to file (255 bytes total of path strings)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'server'<~Hash>:
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'adminPass'<~String> - Admin password for server
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'id'<~Integer> - Id of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'metadata'<~Hash> - metadata
+        #     * 'name<~String> - Name of server
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'status'<~String> - Current server status
+        def create_server(flavor_id, image_id, options = {})
+          data = {
+            'server' => {
+              'flavorId'  => flavor_id,
+              'imageId'   => image_id
+            }
+          }
+          if options['metadata']
+            data['server']['metadata'] = options['metadata']
+          end
+          if options['name']
+            data['server']['name'] = options['name']
+          end
+          if options['personality']
+            data['server']['personality'] = []
+            for file in options['personality']
+              data['server']['personality'] << {
+                'contents'  => Base64.encode64(file['contents']),
+                'path'      => file['path']
+              }
+            end
+          end
+          request(
+            :body     => data.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => 'servers.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_server(flavor_id, image_id, options = {})
+          response = Excon::Response.new
+          response.status = 202
+
+          data = {
+            'addresses' => { 'private' => ['0.0.0.0'], 'public' => ['0.0.0.0'] },
+            'flavorId'  => flavor_id,
+            'id'        => 123456,
+            'imageId'   => image_id,
+            'hostId'    => "123456789ABCDEF01234567890ABCDEF",
+            'metadata'  => options['metadata'] || {},
+            'name'      => options['name'] || "server_#{rand(999)}",
+            'progress'  => 0,
+            'status'    => 'BUILD'
+          }
+          @data[:last_modified][:servers][data['id']] = Time.now
+          @data[:servers][data['id']] = data
+          response.body = { 'server' => data.merge({'adminPass' => 'password'}) }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/delete_image.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/delete_image.rb
new file mode 100644
index 0000000..db3c457
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/delete_image.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Delete an image
+        #
+        # ==== Parameters
+        # * image_id<~Integer> - Id of image to delete
+        #
+        def delete_image(image_id)
+          request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => "images/#{image_id}"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_image(image_id)
+          response = Excon::Response.new
+          if image = list_images_detail.body['images'].detect {|image| image['id'] == image_id}
+            if image['status'] == 'SAVING'
+              response.status = 409
+              raise(Excon::Errors.status_error({:expects => 202}, response))
+            else
+              @data[:last_modified][:images].delete(image_id)
+              @data[:images].delete(image_id)
+              response.status = 202
+            end
+            response
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 202}, response))
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/delete_server.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/delete_server.rb
new file mode 100644
index 0000000..6580f7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/delete_server.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Delete an existing server
+        #
+        # ==== Parameters
+        # * id<~Integer> - Id of server to delete
+        #
+        def delete_server(server_id)
+          request(
+            :expects => 202,
+            :method => 'DELETE',
+            :path   => "servers/#{server_id}"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_server(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect { |server| server['id'] == server_id }
+            if server['status'] == 'BUILD'
+              response.status = 409
+              raise(Excon::Errors.status_error({:expects => 202}, response))
+            else
+              @data[:last_modified][:servers].delete(server_id)
+              @data[:servers].delete(server_id)
+              response.status = 202
+            end
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_flavor_details.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_flavor_details.rb
new file mode 100644
index 0000000..a1848c4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_flavor_details.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details for flavor by id
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        #     * 'disk'<~Integer> - Amount of diskspace for the flavor
+        def get_flavor_details(flavor_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "flavors/#{flavor_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavor_details(flavor_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_image_details.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_image_details.rb
new file mode 100644
index 0000000..637b06e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_image_details.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details for image by id
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'serverId'<~Integer> - Id of server image was created from
+        #     * 'status'<~Integer> - Status of image
+        #     * 'updated'<~String> - Timestamp of last update
+        def get_image_details(image_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "images/#{image_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image_details(image_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_server_details.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_server_details.rb
new file mode 100644
index 0000000..60081b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/get_server_details.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details about a server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to get details for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'server'<~Hash>:
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'id'<~Integer> - Id of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'metadata'<~Hash> - metadata
+        #     * 'name<~String> - Name of server
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'status'<~String> - Current server status
+        def get_server_details(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server_details(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect { |server| server['id'] == server_id }
+            response.status = [200, 203][rand(1)]
+            response.body = { 'server' => server }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_addresses.rb
new file mode 100644
index 0000000..94fb7c6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_addresses.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'addresses'<~Array>:
+        #     * 'public'<~Array> - Public ip addresses
+        #     * 'private'<~Array> - Private ip addresses
+        def list_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect { |server| server['id'] == server_id }
+            response.status = [200, 203][rand(1)]
+            response.body = { 'addresses' => server['addresses'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_flavors.rb
new file mode 100644
index 0000000..0114f48
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_flavors.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all flavors (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        def list_flavors
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'flavors.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_flavors
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_flavors_detail.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_flavors_detail.rb
new file mode 100644
index 0000000..45ece3d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_flavors_detail.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all flavors
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        #     * 'disk'<~Integer> - Amount of diskspace for the flavor
+        def list_flavors_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'flavors/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_flavors_detail
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_images.rb
new file mode 100644
index 0000000..4af6333
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_images.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all images (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def list_images
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'images.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images
+          response = Excon::Response.new
+          data = list_images_detail.body['images']
+          images = []
+          for image in data
+            images << image.reject { |key, value| !['id', 'name'].include?(key) }
+          end
+          response.status = [200, 203][rand(1)]
+          response.body = { 'images' => images }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_images_detail.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_images_detail.rb
new file mode 100644
index 0000000..3ca7f67
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_images_detail.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'updated'<~String> - Last update timestamp for image
+        #     * 'created'<~String> - Creation timestamp for image
+        #     * 'status'<~String> - Status of image
+        def list_images_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'images/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images_detail
+          response = Excon::Response.new
+
+          images = @data[:images].values
+          for image in images
+            case image['status']
+            when 'SAVING'
+              if Time.now - @data[:last_modified][:images][image['id']] > 2
+                image['status'] = 'ACTIVE'
+              end
+            end
+          end
+
+          response.status = [200, 203][rand(1)]
+          response.body = { 'images' => images }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_private_addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_private_addresses.rb
new file mode 100644
index 0000000..94808a5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_private_addresses.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List private server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'private'<~Array> - Public ip addresses
+        def list_private_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips/private.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_private_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect { |server| server['id'] == server_id }
+            response.status = [200, 203][rand(1)]
+            response.body = { 'private' => server['addresses']['private'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_public_addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_public_addresses.rb
new file mode 100644
index 0000000..b7226ac
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_public_addresses.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List public server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'public'<~Array> - Public ip addresses
+        def list_public_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips/public.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_public_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect { |server| server['id'] == server_id }
+            response.status = [200, 203][rand(1)]
+            response.body = { 'public' => server['addresses']['public'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_servers.rb
new file mode 100644
index 0000000..0bf2baf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_servers.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all servers (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'servers'<~Array>:
+        #     * 'id'<~Integer> - Id of server
+        #     * 'name<~String> - Name of server
+        def list_servers
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'servers.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers
+          response = Excon::Response.new
+          data = list_servers_detail.body['servers']
+          servers = []
+          for server in data
+            servers << server.reject { |key, value| !['id', 'name'].include?(key) }
+          end
+          response.status = [200, 203][rand(1)]
+          response.body = { 'servers' => servers }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_servers_detail.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_servers_detail.rb
new file mode 100644
index 0000000..ade9314
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/list_servers_detail.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all servers details
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'servers'<~Array>:
+        #     * 'id'<~Integer> - Id of server
+        #     * 'name<~String> - Name of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'status'<~String> - Current server status
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'metadata'<~Hash> - metadata
+        def list_servers_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'servers/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers_detail
+          response = Excon::Response.new
+
+          servers = @data[:servers].values
+          for server in servers
+            case server['status']
+            when 'BUILD'
+              if Time.now - @data[:last_modified][:servers][server['id']] > 2
+                server['status'] = 'ACTIVE'
+              end
+            end
+          end
+
+          response.status = [200, 203][rand(1)]
+          response.body = { 'servers' => servers }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/reboot_server.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/reboot_server.rb
new file mode 100644
index 0000000..90aea77
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/reboot_server.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        def reboot_server(server_id, type = 'SOFT')
+          request(
+            :body     => { 'reboot' => { 'type' => type }}.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => "servers/#{server_id}/action.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_server(server_id, type = 'SOFT')
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/update_server.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/update_server.rb
new file mode 100644
index 0000000..834a7c2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/compute/update_server.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Update an existing server
+        #
+        # ==== Parameters
+        # # server_id<~Integer> - Id of server to update
+        # * options<~Hash>:
+        #   * adminPass<~String> - New admin password for server
+        #   * name<~String> - New name for server
+        def update_server(server_id, options = {})
+          request(
+            :body     => { 'server' => options }.to_json,
+            :expects  => 204,
+            :method   => 'PUT',
+            :path     => "servers/#{server_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_server(server_id, options)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect { |server| server['id'] == server_id }
+            if options['adminPass']
+              server['adminPass'] = options['adminPass']
+            end
+            if options['name']
+              server['name'] = options['name']
+            end
+            response.status = 204
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/delete_container.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/delete_container.rb
new file mode 100644
index 0000000..90e6a30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/delete_container.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Delete an existing container
+        #
+        # ==== Parameters
+        # * name<~String> - Name of container to delete
+        #
+        def delete_container(name)
+          response = storage_request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def delete_container(name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/delete_object.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/delete_object.rb
new file mode 100644
index 0000000..81da44d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/delete_object.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Delete an existing container
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to delete
+        # * object<~String> - Name of object to delete
+        #
+        def delete_object(container, object)
+          response = storage_request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def delete_object(container, object)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_container.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_container.rb
new file mode 100644
index 0000000..320563d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_container.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get details for container and total bytes stored
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        # * options<~String>:
+        #   * 'limit'<~String> - Maximum number of objects to return
+        #   * 'marker'<~String> - Only return objects whose name is greater than marker
+        #   * 'prefix'<~String> - Limits results to those starting with prefix
+        #   * 'path'<~String> - Return objects nested in the pseudo path
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Account-Container-Count'<~String> - Count of containers
+        #     * 'X-Account-Bytes-Used'<~String> - Bytes used
+        #   * body<~Array>:
+        #     * 'bytes'<~Integer> - Number of bytes used by container
+        #     * 'count'<~Integer> - Number of items in container
+        #     * 'name'<~String> - Name of container
+        #     * item<~Hash>:
+        #       * 'bytes'<~String> - Size of object
+        #       * 'content_type'<~String> Content-Type of object
+        #       * 'hash'<~String> - Hash of object (etag?)
+        #       * 'last_modified'<~String> - Last modified timestamp
+        #       * 'name'<~String> - Name of object
+        def get_container(container, options = {})
+          response = storage_request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => container,
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_container(container, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_containers.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_containers.rb
new file mode 100644
index 0000000..479feed
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_containers.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List existing storage containers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'limit'<~Integer> - Upper limit to number of results returned
+        #   * 'marker'<~String> - Only return objects with name greater than this value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * container<~Hash>:
+        #       * 'bytes'<~Integer>: - Number of bytes used by container
+        #       * 'count'<~Integer>: - Number of items in container
+        #       * 'name'<~String>: - Name of container
+        def get_containers(options = {})
+          response = storage_request(
+            :expects  => [200, 204],
+            :method   => 'GET',
+            :path     => '',
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_containers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_object.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_object.rb
new file mode 100644
index 0000000..6032542
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/get_object.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get details for object
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to look in
+        # * object<~String> - Name of object to look for
+        #
+        def get_object(container, object, &block)
+          response = storage_request({
+            :block    => block,
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          }, false, &block)
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_object(container, object)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_container.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_container.rb
new file mode 100644
index 0000000..271449f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_container.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List number of objects and total bytes stored
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Container-Object-Count'<~String> - Count of containers
+        #     * 'X-Container-Bytes-Used'<~String>   - Bytes used
+        def head_container(container)
+          response = storage_request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => container,
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_container(container)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_containers.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_containers.rb
new file mode 100644
index 0000000..1a59303
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_containers.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List number of containers and total bytes stored
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Account-Container-Count'<~String> - Count of containers
+        #     * 'X-Account-Bytes-Used'<~String> - Bytes used
+        def head_containers
+          response = storage_request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => '',
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_containers
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_object.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_object.rb
new file mode 100644
index 0000000..b0fec4f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/head_object.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get headers for object
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to look in
+        # * object<~String> - Name of object to look for
+        #
+        def head_object(container, object)
+          response = storage_request({
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          }, false)
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_object(container, object)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/put_container.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/put_container.rb
new file mode 100644
index 0000000..340abcb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/put_container.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Create a new container
+        #
+        # ==== Parameters
+        # * name<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        #
+        def put_container(name)
+          response = storage_request(
+            :expects  => [201, 202],
+            :method   => 'PUT',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def put_container(name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/put_object.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/put_object.rb
new file mode 100644
index 0000000..f7da63e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/requests/storage/put_object.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Create a new object
+        #
+        # ==== Parameters
+        # * container<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        #
+        def put_object(container, object, data)
+          data = parse_data(data)
+          response = storage_request(
+            :body     => data[:body],
+            :expects  => 201,
+            :headers  => data[:headers],
+            :method   => 'PUT',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def put_object(container, object, data)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/servers.rb
new file mode 100644
index 0000000..2e33b60
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/servers.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Rackspace
+    class Servers
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::Rackspace::Servers#new is deprecated, use Fog::Rackspace::Compute#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::Rackspace::Compute.new(attributes)
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/rackspace/storage.rb b/lib/bbcloud/vendor/fog/lib/fog/rackspace/storage.rb
new file mode 100644
index 0000000..4aeda1c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/rackspace/storage.rb
@@ -0,0 +1,151 @@
+module Fog
+  module Rackspace
+    class Storage < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+
+      model_path 'fog/rackspace/models/storage'
+      model       :directory
+      collection  :directories
+      model       :file
+      collection  :files
+
+      request_path 'fog/rackspace/requests/storage'
+      request :delete_container
+      request :delete_object
+      request :get_container
+      request :get_containers
+      request :get_object
+      request :head_container
+      request :head_containers
+      request :head_object
+      request :put_container
+      request :put_object
+
+      module Utils
+
+        def parse_data(data)
+          metadata = {
+            :body => nil,
+            :headers => {}
+          }
+
+          if data.is_a?(String)
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = metadata[:body].size.to_s
+          else
+            filename = ::File.basename(data.path)
+            unless (mime_types = MIME::Types.of(filename)).empty?
+              metadata[:headers]['Content-Type'] = mime_types.first.content_type
+            end
+            metadata[:body] = data.read
+            metadata[:headers]['Content-Length'] = ::File.size(data.path).to_s
+          end
+          # metadata[:headers]['Content-MD5'] = Base64.encode64(Digest::MD5.digest(metadata[:body])).strip
+          metadata
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @rackspace_username = options[:rackspace_username]
+          @data = self.class.data[@rackspace_username]
+        end
+
+      end
+
+      class Real
+        include Utils
+
+        def initialize(options={})
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+
+          if(credentials['X-CDN-Management-Url'])
+            cdn_uri = URI.parse(credentials['X-CDN-Management-Url'])
+            @cdn_host   = cdn_uri.host
+            @cdn_path   = cdn_uri.path
+            @cdn_port   = cdn_uri.port
+            @cdn_scheme = cdn_uri.scheme
+            @cdn_connection = Fog::Connection.new("#{@cdn_scheme}://#{@cdn_host}:#{@cdn_port}", options[:persistent])
+          end
+
+          storage_uri = URI.parse(credentials['X-Storage-Url'])
+          @storage_host   = storage_uri.host
+          @storage_path   = storage_uri.path
+          @storage_port   = storage_uri.port
+          @storage_scheme = storage_uri.scheme
+          @storage_connection = Fog::Connection.new("#{@storage_scheme}://#{@storage_host}:#{@storage_port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def cdn_request(params)
+          begin
+            response = @cdn_connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @cdn_host,
+              :path     => "#{@cdn_path}/#{params[:path]}",
+            }))
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Storage::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          if !response.body.empty? && parse_json && response.headers['Content-Type'] =~ %r{application/json}
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+        def storage_request(params, parse_json = true, &block)
+          begin
+            response = @storage_connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @storage_host,
+              :path     => "#{@storage_path}/#{params[:path]}",
+            }), &block)
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Storage::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          if !response.body.empty? && parse_json && response.headers['Content-Type'] =~ %r{application/json}
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/service.rb b/lib/bbcloud/vendor/fog/lib/fog/service.rb
new file mode 100644
index 0000000..a55061f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/service.rb
@@ -0,0 +1,139 @@
+module Fog
+  class Service
+
+    class Error < Fog::Errors::Error; end
+    class NotFound < Fog::Errors::NotFound; end
+
+    module Collections
+
+      def collections
+        service.collections
+      end
+
+      def requests
+        service.requests
+      end
+
+    end
+
+    class << self
+
+      def inherited(child)
+        child.class_eval <<-EOS, __FILE__, __LINE__
+          module Collections
+            include Fog::Service::Collections
+
+            def service
+              #{child}
+            end
+          end
+
+          def self.service
+            #{child}
+          end
+        EOS
+      end
+
+      def new(options={})
+        if Fog.bin
+          default_credentials = Fog.credentials.reject {|key, value| !requirements.include?(key)}
+          options = default_credentials.merge(options)
+        end
+
+        missing = []
+        for requirement in requirements
+          missing << requirement unless options[requirement]
+        end
+        unless missing.empty?
+          if missing.length == 1
+            raise(ArgumentError, [missing.first, "is required for this service"].join(' '))
+          else
+            raise(ArgumentError, [missing[0...-1].join(", "), 'and', missing[-1], 'are required for this service'].join(' '))
+          end
+        end
+
+        setup_requirements
+
+        if Fog.mocking?
+          service::Mock.send(:include, service::Collections)
+          service::Mock.new(options)
+        else
+          service::Real.send(:include, service::Collections)
+          service::Real.new(options)
+        end
+      end
+
+      def setup_requirements
+        if superclass.respond_to?(:setup_requirements)
+          superclass.setup_requirements
+        end
+
+        unless @required
+          for collection in collections
+            require [@model_path, collection].join('/')
+            constant = collection.to_s.split('_').map {|characters| characters[0...1].upcase << characters[1..-1]}.join('')
+            service::Collections.module_eval <<-EOS, __FILE__, __LINE__
+              def #{collection}(attributes = {})
+                #{service}::#{constant}.new({:connection => self}.merge(attributes))
+              end
+            EOS
+          end
+          for model in models
+            require [@model_path, model].join('/')
+          end
+          for request in requests
+            require [@request_path, request].join('/')
+          end
+          @required = true
+        end
+      end
+
+      def model_path(new_path)
+        @model_path = new_path
+      end
+
+      def collection(new_collection)
+        collections << new_collection
+      end
+
+      def collections
+        @collections ||= []
+      end
+
+      def model(new_model)
+        models << new_model
+      end
+
+      def models
+        @models ||= []
+      end
+
+      def request_path(new_path)
+        @request_path = new_path
+      end
+
+      def request(new_request)
+        requests << new_request
+      end
+
+      def requests
+        @requests ||= []
+      end
+
+      def requires(*args)
+        requirements.concat(args)
+      end
+
+      def requirements
+        @requirements ||= []
+      end
+
+      def reset_data(keys=Mock.data.keys)
+        Mock.reset_data(keys)
+      end
+
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost.rb
new file mode 100644
index 0000000..26eb780
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Slicehost
+
+    extend Fog::Provider
+
+    service_path 'fog/slicehost'
+    service :compute
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Slicehost#new is deprecated, use Fog::Bluebox::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Slicehost::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/bin.rb
new file mode 100644
index 0000000..7119913
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/bin.rb
@@ -0,0 +1,25 @@
+class Slicehost < Fog::Bin
+  class << self
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Slicehost::Compute.new
+        when :slices
+          location = caller.first
+          warning = "[yellow][WARN] Slicehost[:blocks] is deprecated, use Bluebox[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          Fog::Slicehost::Compute.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/compute.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/compute.rb
new file mode 100644
index 0000000..bdacefc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/compute.rb
@@ -0,0 +1,91 @@
+module Fog
+  module Slicehost
+    class Compute < Fog::Service
+
+      requires :slicehost_password
+
+      model_path 'fog/slicehost/models/compute'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/slicehost/requests/compute'
+      request :create_slice
+      request :delete_slice
+      request :get_backups
+      request :get_flavor
+      request :get_flavors
+      request :get_image
+      request :get_images
+      request :get_slice
+      request :get_slices
+      request :reboot_slice
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @slicehost_password = options[:slicehost_password]
+          @data = self.class.data[@slicehost_password]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @slicehost_password = options[:slicehost_password]
+          @host   = options[:host]    || "api.slicehost.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(@slicehost_password).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::Error => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Slicehost::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/flavor.rb
new file mode 100644
index 0000000..c738114
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :price
+        attribute :ram
+
+        def bits
+          # 64
+          raise StandardError.new("Figure me out!?!")
+        end
+
+        def cores
+          # # 2 quad-cores >= 2Ghz = 8 cores
+          # 8 * case ram
+          # when 256
+          #   1/64.0
+          # when 512
+          #   1/32.0
+          # when 1024
+          #   1/16.0
+          # when 2048
+          #   1/8.0
+          # when 4096
+          #   1/4.0
+          # when 8192
+          #   1/2.0
+          # when 15872
+          #   1
+          # end
+          raise StandardError.new("Figure me out!?!")
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/flavors.rb
new file mode 100644
index 0000000..4366ea5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/collection'
+require 'fog/slicehost/models/compute/flavor'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Slicehost::Compute::Flavor
+
+        def all
+          data = connection.get_flavors.body['flavors']
+          load(data)
+        end
+
+        def get(flavor_id)
+          data = connection.get_flavor(flavor_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/image.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/image.rb
new file mode 100644
index 0000000..ec7111a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/image.rb
@@ -0,0 +1,17 @@
+require 'fog/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/images.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/images.rb
new file mode 100644
index 0000000..3b925c0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/images.rb
@@ -0,0 +1,27 @@
+require 'fog/collection'
+require 'fog/slicehost/models/compute/image'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Slicehost::Compute::Image
+
+        def all
+          data = connection.get_images.body['images']
+          load(data)
+        end
+
+        def get(image_id)
+          connection.get_image(image_id)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/server.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/server.rb
new file mode 100644
index 0000000..4e4366f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/server.rb
@@ -0,0 +1,64 @@
+require 'fog/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :addresses
+        attribute :backup_id,     :aliases => 'backup-id'
+        attribute :bandwidth_in,  :aliases => 'bw-in'
+        attribute :bandwidth_out, :aliases => 'bw-out'
+        attribute :flavor_id,     :aliases => 'flavor-id'
+        attribute :image_id,      :aliases => 'image-id'
+        attribute :name
+        attribute :password,      :aliases => 'root-password'
+        attribute :progress
+        attribute :status
+
+        def initialize(attributes={})
+          @flavor_id ||= 1
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.delete_slice(@id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(@flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(@image_id)
+        end
+
+        def ready?
+          @status == 'active'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_slice(@id, type)
+          true
+        end
+
+        def save
+          requires :flavor_id, :image_id, :name
+          data = connection.create_slice(@flavor_id, @image_id, @name)
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/servers.rb
new file mode 100644
index 0000000..278c693
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/models/compute/servers.rb
@@ -0,0 +1,31 @@
+require 'fog/collection'
+require 'fog/slicehost/models/compute/server'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Slicehost::Compute::Server
+
+        def all
+          data = connection.get_slices.body['slices']
+          load(data)
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_slice(server_id).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/create_slice.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/create_slice.rb
new file mode 100644
index 0000000..99ed717
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/create_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class CreateSlice < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @response['addresses'] ||= []
+              @response['addresses'] << @value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @response[name] = @value.to_i
+            when 'bw-in', 'bw-out'
+              @response[name] = @value.to_f
+            when 'name', 'root-password', 'status'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_backups.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_backups.rb
new file mode 100644
index 0000000..16a3af0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_backups.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetBackups < Fog::Parsers::Base
+
+          def reset
+            @backup = {}
+            @response = { 'backups' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'backup'
+              @response['backups'] << @backup
+              @backup = {}
+            when 'date'
+              @backup[name] = Time.parse(@value)
+            when 'id', 'slice-id'
+              @backup[name] = @value.to_i
+            when 'name'
+              @backup[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_flavor.rb
new file mode 100644
index 0000000..0d973d2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_flavor.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetFlavor < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'price', 'ram'
+              @response[name] = @value.to_i
+            when 'name'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_flavors.rb
new file mode 100644
index 0000000..255d78b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_flavors.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetFlavors < Fog::Parsers::Base
+
+          def reset
+            @flavor = {}
+            @response = { 'flavors' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'flavor'
+              @response['flavors'] << @flavor
+              @flavor = {}
+            when 'id', 'price', 'ram'
+              @flavor[name] = @value.to_i
+            when 'name'
+              @flavor[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_image.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_image.rb
new file mode 100644
index 0000000..6f62185
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_image.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetImage < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @response[name] = @value.to_i
+            when 'name'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_images.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_images.rb
new file mode 100644
index 0000000..b9997fe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_images.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetImages < Fog::Parsers::Base
+
+          def reset
+            @image = {}
+            @response = { 'images' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @image[name] = @value.to_i
+            when 'image'
+              @response['images'] << @image
+              @image = {}
+            when 'name'
+              @image[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_slice.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_slice.rb
new file mode 100644
index 0000000..46e1cdd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetSlice < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @response['addresses'] ||= []
+              @response['addresses'] << @value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @response[name] = @value.to_i
+            when 'bw-in', 'bw-out'
+              @response[name] = @value.to_f
+            when 'name', 'status'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_slices.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_slices.rb
new file mode 100644
index 0000000..4dfa919
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/parsers/compute/get_slices.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetSlices < Fog::Parsers::Base
+
+          def reset
+            @slice = {}
+            @response = { 'slices' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @slice['addresses'] ||= []
+              @slice['addresses'] << @value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @slice[name] = @value.to_i
+            when 'bw-in', 'bw-out'
+              @slice[name] = @value.to_f
+            when 'name', 'status'
+              @slice[name] = @value
+            when 'slice'
+              @response['slices'] << @slice
+              @slice = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/create_slice.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/create_slice.rb
new file mode 100644
index 0000000..eb009be
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/create_slice.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/create_slice'
+
+        # Get list of slices
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to create slice with
+        # * image_id<~Integer> - Id of image to create slice with
+        # * name<~String> - Name of slice
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Integer> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Integer> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor-id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'root-password'<~String> - Root password of slice
+        #     * 'status'<~String> - Current status of the slice
+        def create_slice(flavor_id, image_id, name)
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><slice><flavor-id type="integer">#{flavor_id}</flavor-id><image-id type="integer">#{image_id}</image-id><name>#{name}</name></slice>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::Compute::CreateSlice.new,
+            :path     => 'slices.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_slice(flavor_id, image_id, name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/delete_slice.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/delete_slice.rb
new file mode 100644
index 0000000..548ee36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/delete_slice.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        # Get list of slices
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to create slice with
+        # * image_id<~Integer> - Id of image to create slice with
+        # * name<~String> - Name of slice
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Integer> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Integer> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor-id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'root-password'<~String> - Root password of slice
+        #     * 'status'<~String> - Current status of the slice
+        def delete_slice(slice_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "slices/#{slice_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_slice(slice_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_backups.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_backups.rb
new file mode 100644
index 0000000..518c26e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_backups.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_backups'
+
+        # Get list of backups
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'date'<~Time> - Timestamp of backup creation
+        #     * 'id'<~Integer> - Id of the backup
+        #     * 'name'<~String> - Name of the backup
+        #     * 'slice-id'<~Integer> - Id of slice the backup was made from
+        def get_backups
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetBackups.new,
+            :path     => 'backups.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_backups
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_flavor.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_flavor.rb
new file mode 100644
index 0000000..ffedb5b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_flavor.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_flavor'
+
+        # Get details of a flavor
+        #
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'price'<~Integer> - Price in cents
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        def get_flavor(flavor_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetFlavor.new,
+            :path     => "flavors/#{flavor_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavor(flavor_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_flavors.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_flavors.rb
new file mode 100644
index 0000000..5e8122e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_flavors.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_flavors'
+
+        # Get list of flavors
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'price'<~Integer> - Price in cents
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        def get_flavors
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetFlavors.new,
+            :path     => 'flavors.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavors
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_image.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_image.rb
new file mode 100644
index 0000000..366c71f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_image.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_image'
+
+        # Get details of an image
+        #
+        # ==== Parameters
+        # * image_id<~Integer> - Id of image to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def get_image(image_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetImage.new,
+            :path     => "images/#{image_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image(image_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_images.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_images.rb
new file mode 100644
index 0000000..8b72084
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_images.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_images'
+
+        # Get list of images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def get_images
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetImages.new,
+            :path     => 'images.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_images
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_slice.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_slice.rb
new file mode 100644
index 0000000..7200595
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_slice.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_slice'
+
+        # Get details of a slice
+        #
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of slice to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_slice(slice_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlice.new,
+            :path     => "/slices/#{slice_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_slice(id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_slices.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_slices.rb
new file mode 100644
index 0000000..1ca6199
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/get_slices.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_slices'
+
+        # Get list of slices
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_slices
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlices.new,
+            :path     => 'slices.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_slices
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/reboot_slice.rb b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/reboot_slice.rb
new file mode 100644
index 0000000..d266e58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/slicehost/requests/compute/reboot_slice.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        # Reboot slice
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of server to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def reboot_slice(slice_id, type = 'SOFT')
+          request(
+            :expects  => 200,
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlice.new,
+            :path     => "/slices/#{slice_id}/#{'hard_' if type == 'HARD'}reboot.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_slice(id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/ssh.rb b/lib/bbcloud/vendor/fog/lib/fog/ssh.rb
new file mode 100644
index 0000000..962cb7d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/ssh.rb
@@ -0,0 +1,117 @@
+module Fog
+  module SSH
+
+    def self.new(address, username, options = {})
+      unless options[:key_data] || options[:keys] || options[:password]
+        raise ArgumentError.new(':key_data, :keys or :password are required to initialize SSH')
+      end
+      if Fog.mocking?
+        Fog::SSH::Mock.new(address, username, options)
+      else
+        Fog::SSH::Real.new(address, username, options)
+      end
+    end
+
+    def self.reset_data(keys=Mock.data.keys)
+      Mock.reset_data(keys)
+    end
+
+    class Mock
+
+      def self.data
+        @data ||= Hash.new do |hash, key|
+          hash[key] = {}
+        end
+      end
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options
+      end
+
+      def run(commands)
+        Fog::Mock.not_implemented
+      end
+
+    end
+
+    class Real
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options.merge(:paranoid => false)
+        @options.merge(:verbose => true)
+      end
+
+      def run(commands)
+        commands = [*commands]
+        results  = []
+        begin
+          Net::SSH.start(@address, @username, @options) do |ssh|
+            commands.each do |command|
+              sudoable_command  = command.sub(/^sudo/, %{sudo -p 'fog sudo password:'})
+              escaped_command   = sudoable_command.sub(/'/, %{'"'"'})
+              result = Result.new(escaped_command)
+              ssh.open_channel do |channel|
+                channel.request_pty
+                channel.exec(%{bash -lc '#{escaped_command}'}) do |channel, success|
+                  unless success
+                    raise "Could not execute command: #{command.inspect}"
+                  end
+
+                  channel.on_data do |channel, data|
+                    result.stdout << data
+                  end
+
+                  channel.on_extended_data do |channel, type, data|
+                    next unless type == 1
+                    result.stderr << data
+                  end
+
+                  channel.on_request('exit-status') do |channel, data|
+                    result.status = data.read_long
+                  end
+
+                  channel.on_request('exit-signal') do |channel, data|
+                    result.status = 255
+                  end
+                end
+              end
+              ssh.loop
+              results << result
+            end
+          end
+        rescue Net::SSH::HostKeyMismatch => exception
+          exception.remember_host!
+          sleep 0.2
+          retry
+        end
+        results
+      end
+
+    end
+
+    class Result
+
+      attr_accessor :command, :stderr, :stdout, :status
+
+      def display_stdout
+        Formatador.display_line(stdout.split("\r\n"))
+      end
+
+      def display_stderr
+        Formatador.display_line(stderr.split("\r\n"))
+      end
+
+      def initialize(command)
+        @command = command
+        @stderr = ''
+        @stdout = ''
+      end
+
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark.rb
new file mode 100644
index 0000000..ec499fe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark.rb
@@ -0,0 +1,11 @@
+require 'fog/terremark/shared'
+require 'fog/terremark/parser'
+require 'fog/terremark/ecloud'
+require 'fog/terremark/vcloud'
+
+module Fog
+  module Terremark
+    ECLOUD_OPTIONS = [:terremark_ecloud_username, :terremark_ecloud_password]
+    VCLOUD_OPTIONS = [:terremark_vcloud_username, :terremark_vcloud_password]
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/bin.rb
new file mode 100644
index 0000000..3df7b3b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/bin.rb
@@ -0,0 +1,36 @@
+class Terremark < Fog::Bin
+  class << self
+
+    def available?
+      Fog::Terremark::ECLOUD_OPTIONS.all? {|requirement| Fog.credentials.include?(requirement)} ||
+      Fog::Terremark::VCLOUD_OPTIONS.all? {|requirement| Fog.credentials.include?(requirement)}
+    end
+
+    def terremark_service(service)
+      case service
+      when :ecloud
+        Fog::Terremark::Ecloud
+      when :vcloud
+        Fog::Terremark::Vcloud
+      else
+        raise "Unsupported Terremark Service"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        credentials = Fog.credentials.reject do |k,v|
+          case key
+          when :ecloud
+            !Fog::Terremark::ECLOUD_OPTIONS.include?(k)
+          when :vcloud
+            !Fog::Terremark::VCLOUD_OPTIONS.include?(k)
+          end
+        end
+        hash[key] = terremark_service(key).new(credentials)
+      end
+      @@connections[service]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/ecloud.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/ecloud.rb
new file mode 100644
index 0000000..bcbb6c5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/ecloud.rb
@@ -0,0 +1,66 @@
+module Fog
+  module Terremark
+   module Ecloud
+
+     module Bin
+     end
+
+     module Defaults
+       HOST   = 'services.enterprisecloud.terremark.com'
+       PATH   = '/api/v0.8a-ext2.0'
+       PORT   = 443
+       SCHEME = 'https'
+     end
+
+     extend Fog::Terremark::Shared
+
+     def self.new(options={})
+
+       unless @required
+         shared_requires
+         @required = true
+       end
+
+       check_shared_options(options)
+
+       if Fog.mocking?
+          Fog::Terremark::Ecloud::Mock.new(options)
+        else
+          Fog::Terremark::Ecloud::Real.new(options)
+        end
+     end
+
+     class Real
+
+       include Fog::Terremark::Shared::Real
+       include Fog::Terremark::Shared::Parser
+
+        def initialize(options={})
+          @terremark_password = options[:terremark_ecloud_password]
+          @terremark_username = options[:terremark_ecloud_username]
+          @host   = options[:host]   || Fog::Terremark::Ecloud::Defaults::HOST
+          @path   = options[:path]   || Fog::Terremark::Ecloud::Defaults::PATH
+          @port   = options[:port]   || Fog::Terremark::Ecloud::Defaults::PORT
+          @scheme = options[:scheme] || Fog::Terremark::Ecloud::Defaults::SCHEME
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+      end
+
+     class Mock
+       include Fog::Terremark::Shared::Mock
+       include Fog::Terremark::Shared::Parser
+
+       def initialize(option = {})
+         super
+         @base_url = Fog::Terremark::Ecloud::Defaults::SCHEME + "://" +
+                     Fog::Terremark::Ecloud::Defaults::HOST +
+                     Fog::Terremark::Ecloud::Defaults::PATH
+         @data = self.class.data[:terremark_ecloud_username]
+       end
+     end
+
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/address.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/address.rb
new file mode 100644
index 0000000..4f3ccb7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/address.rb
@@ -0,0 +1,29 @@
+require 'fog/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Address < Fog::Model
+
+        identity :id
+
+        attribute :ip, :aliases => 'name'
+
+        def destroy
+         requires :id
+         connection.delete_public_ip(@id)
+         true
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/addresses.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/addresses.rb
new file mode 100644
index 0000000..decc67a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/addresses.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def addresses(options = {})
+          Fog::Terremark::Shared::Addresses.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def addresses(options = {})
+          Fog::Terremark::Shared::Addresses.new(options.merge(:connection => self))
+        end
+      end
+
+      class Addresses < Fog::Collection
+
+        model Fog::Terremark::Shared::Address
+
+        def all
+          load(connection.get_public_ips(vdc_id).body['PublicIpAddresses'])
+        end
+
+        def get(ip_id)
+          if ip_id && ip = connection.get_public_ip(ip_id).body
+            new(ip)
+          elsif !ip_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/network.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/network.rb
new file mode 100644
index 0000000..eb06727
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/network.rb
@@ -0,0 +1,35 @@
+require 'fog/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Network < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :subnet
+        attribute :gateway
+        attribute :netmask
+        attribute :fencemode
+        attribute :links
+
+        def ips
+          #Until there is a real model for these ?
+          connection.get_network_ips(@id).body['IpAddresses']
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/networks.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/networks.rb
new file mode 100644
index 0000000..6e39c30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/networks.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def networks(options = {})
+          Fog::Terremark::Shared::Networks.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def networks(options = {})
+          Fog::Terremark::Shared::Networks.new(options.merge(:connection => self))
+        end
+      end
+
+      class Networks < Fog::Collection
+
+        model Fog::Terremark::Shared::Network
+
+        def all
+          data = connection.get_vdc(vdc_id).body['AvailableNetworks'].map do |network|
+            connection.get_network(network["href"].split("/").last).body
+          end
+          load(data)
+        end
+
+        def get(network_id)
+          if network_id && network = connection.get_network(network_id).body
+            new(network)
+          elsif !network_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/server.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/server.rb
new file mode 100644
index 0000000..e653306
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/server.rb
@@ -0,0 +1,110 @@
+require 'fog/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :status
+        attribute :OperatingSystem
+        attribute :VirtualHardware
+
+        def destroy
+          requires :id
+          data = connection.power_off(@id).body
+          task = connection.tasks.new(data)
+          task.wait_for { ready? }
+          connection.delete_vapp(@id)
+          true
+        end
+
+        # { '0' => 'Being created', '2' => 'Powered Off', '4' => 'Powered On'}
+        def ready?
+          @status == '2'
+        end
+
+        def on?
+          @status == '4'
+        end
+
+        def off?
+          @status == '2'
+        end
+
+        def power_on(options = {})
+          requires :id
+          begin
+            connection.power_on(@id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered on/
+          end
+          true
+        end
+
+        def power_off
+          requires :id
+          begin
+            connection.power_off(@id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered off/
+          end
+          true
+        end
+
+        def shutdown
+          requires :id
+          begin
+            connection.power_shutdown(@id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered off/
+          end
+          true
+        end
+
+        def power_reset
+          requires :id
+          connection.power_reset(@id)
+          true
+        end
+
+        def graceful_restart
+          requires :id
+          shutdown
+          wait_for { off? }
+          power_on
+        end
+
+        def save
+          requires :name
+          data = connection.instantiate_vapp(@name)
+          merge_attributes(data.body)
+          task = connection.deploy_vapp(@id)
+          task.wait_for { ready? }
+          task = connection.power_on(@id)
+          task.wait_for { ready? }
+          true
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); @type = new_type; end
+        def size=(new_size); @size = new_size; end
+        def IpAddress=(new_ipaddress); @IpAddress = new_ipaddress; end
+        def Links=(new_links); @Links = new_links; end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/servers.rb
new file mode 100644
index 0000000..8d4668f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/servers.rb
@@ -0,0 +1,55 @@
+require 'fog/collection'
+require 'fog/terremark/models/shared/server'
+
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def servers(options = {})
+          Fog::Terremark::Shared::Servers.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def servers(options = {})
+          Fog::Terremark::Shared::Servers.new(options.merge(:connection => self))
+        end
+      end
+
+      class Servers < Fog::Collection
+
+        model Fog::Terremark::Shared::Server
+
+        def all
+          data = connection.get_vdc(vdc_id).body['ResourceEntities'].select do |entity|
+            entity['type'] == 'application/vnd.vmware.vcloud.vApp+xml'
+          end
+          load(data)
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_vapp(server_id).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/task.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/task.rb
new file mode 100644
index 0000000..150f66f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/task.rb
@@ -0,0 +1,50 @@
+require 'fog/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Task < Fog::Model
+
+        identity :id
+
+        attribute :end_time,    :aliases => 'endTime'
+        attribute :owner,       :aliases => 'Owner'
+        attribute :result,      :aliases => 'Result'
+        attribute :start_time,  :aliases => 'startTime'
+        attribute :status
+        attribute :link,        :aliases => 'Link'
+        attribute :error,       :aliases => 'Error'
+
+        def initialize(attributes = {})
+          new_owner  = attributes.delete('Owner')
+          new_result = attributes.delete('Result')
+          new_error = attributes.delete('Error')
+          new_cancel_link = attributes.delete('Link')
+
+          super
+          @owner  = connection.parse(new_owner)
+          if new_result
+            @result = connection.parse(new_result)
+          end
+          @error = connection.parse(new_error) if new_error
+          @cancel_link = connection.parse(new_cancel_link) if new_cancel_link
+        end
+
+        def ready?
+          @status == 'success'
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/tasks.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/tasks.rb
new file mode 100644
index 0000000..79e6017
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/tasks.rb
@@ -0,0 +1,58 @@
+require 'fog/collection'
+require 'fog/terremark/models/shared/server'
+
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def tasks
+          Fog::Terremark::Shared::Tasks.new(:connection => self)
+        end
+      end
+
+      module Real
+        def tasks
+          Fog::Terremark::Shared::Tasks.new(:connection => self)
+        end
+      end
+
+      class Tasks < Fog::Collection
+
+        model Fog::Terremark::Shared::Task
+
+        def all
+          data = connection.get_tasks_list(task_list_id).body['Tasks']
+          load(data)
+        end
+
+        def get(task_id)
+          if task_id && task = connection.get_task(task_id).body
+            new(task)
+          elsif !task_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def task_list_id
+          @task_list_id ||=
+            if connection.default_organization_id && organization = connection.get_organization(connection.default_organization_id).body
+              organization['Links'].detect {|link| link['type'] == 'application/vnd.vmware.vcloud.tasksList+xml'}['href'].split('/').last.to_i
+            else
+              nil
+            end
+        end
+
+        private
+
+        def task_list_id=(new_task_list_id)
+          @task_list_id = new_task_list_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/vdc.rb
new file mode 100644
index 0000000..0231129
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/vdc.rb
@@ -0,0 +1,39 @@
+require 'fog/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Vdc < Fog::Model
+
+        identity :id
+
+        attribute :name
+
+        def networks
+          connection.networks(:vdc_id => @id)
+        end
+
+        def addresses
+          connection.addresses(:vdc_id => @id)
+        end
+
+        def servers
+          connection.servers(:vdc_id => @id)
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+        def rel=(new_rel); end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/vdcs.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/vdcs.rb
new file mode 100644
index 0000000..d47793f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/models/shared/vdcs.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def vdcs(options = {})
+          Fog::Terremark::Shared::Vdcs.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def vdcs(options = {})
+          Fog::Terremark::Shared::Vdcs.new(options.merge(:connection => self))
+        end
+      end
+
+      class Vdcs < Fog::Collection
+
+        model Fog::Terremark::Shared::Vdc
+
+        def all
+          data = connection.get_organization(organization_id).body['Links'].select do |entity|
+            entity['type'] == 'application/vnd.vmware.vcloud.vdc+xml'
+          end
+          load(data)
+        end
+
+        def get(vdc_id)
+          if vdc_id && vdc = connection.get_vdc(vdc_id).body
+            new(vdc)
+          elsif !vdc_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def organization_id
+          @vdc_id ||= connection.default_organization_id
+        end
+
+        private
+
+        def organization_id=(new_organization_id)
+          @organization_id = new_organization_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parser.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parser.rb
new file mode 100644
index 0000000..c2327db
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parser.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Terremark
+    module Shared
+      module Parser
+
+        def parse(data)
+          case data['type']
+          when 'application/vnd.vmware.vcloud.vApp+xml'
+            servers.new(data.merge!(:connection => self))
+          else
+            data
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_catalog.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_catalog.rb
new file mode 100644
index 0000000..f426c31
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_catalog.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetCatalog < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CatalogItems' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'CatalogItem'
+              catalog_item = {}
+              until attributes.empty?
+                catalog_item[attributes.shift] = attributes.shift
+              end            
+              @response['CatalogItems'] << catalog_item
+            when 'Catalog'
+              catalog = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  catalog[attribute.first] = attribute.last
+                else
+                  catalog[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = catalog['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_catalog_item.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_catalog_item.rb
new file mode 100644
index 0000000..b6effc2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_catalog_item.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetCatalogItem < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Entity' => {}, 'Properties' => {} }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Entity'
+              until attributes.empty?
+                @response['Entity'][attributes.shift] = attributes.shift
+              end
+            when 'CatalogItem'
+              catalog_item = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  catalog_item[attribute.first] = attribute.last
+                else
+                  catalog_item[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = catalog_item['name']
+            when 'Property'
+              @property_key = attributes.last
+            end
+          end
+
+          def end_element(name)
+            if name == 'Property'
+              @response['Properties'][@property_key] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_internet_services.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_internet_services.rb
new file mode 100644
index 0000000..1aaf049
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_internet_services.rb
@@ -0,0 +1,60 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetInternetServices < Fog::Parsers::Base
+
+          def reset
+            @in_public_ip_address = false
+            @internet_service = {}
+            @response = { 'InternetServices' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'PublicIpAddress'
+              @in_public_ip_address = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Protocol'
+              @internet_service[name] = @value
+            when 'Enabled'
+              if @value == 'true'
+                @internet_service[name] = true
+              else
+                @internet_service[name] = false
+              end
+            when 'Href', 'Name'
+              if @in_public_ip_address
+                @internet_service['PublicIpAddress'] ||= {}
+                @internet_service['PublicIpAddress'][name] = @value
+              else
+                @internet_service[name] = @value
+              end
+            when 'Id'
+              if @in_public_ip_address
+                @internet_service['PublicIpAddress'] ||= {}
+                @internet_service['PublicIpAddress'][name] = @value.to_i
+              else
+                @internet_service[name] = @value.to_i
+              end
+            when 'InternetService'
+              @response['InternetServices'] << @internet_service
+              @internet_service = {}
+            when 'Port', 'Timeout'
+              @internet_service[name] = @value.to_i
+            when 'PublicIpAddress'
+              @in_public_ip_address = false
+            end
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_network_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_network_ips.rb
new file mode 100644
index 0000000..12e5970
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_network_ips.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetNetworkIps< Fog::Parsers::Base
+
+          def reset
+            @ip_address = {}
+            @response = { 'IpAddresses' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Name', 'Status', 'Server'
+              @ip_address[name.downcase] = @value
+            when 'IpAddress'
+              @response['IpAddresses'] << @ip_address
+              @ip_address = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_node_services.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_node_services.rb
new file mode 100644
index 0000000..8acae66
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_node_services.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetNodeServices < Fog::Parsers::Base
+
+          def reset
+            @node_service = {}
+            @response = { 'NodeServices' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Href', 'Name', 'IpAddress'
+              @node_service[name] = @value
+            when 'Enabled'
+              if @value == 'true'
+                @node_service[name] = true
+              else
+                @node_service[name] = false
+              end
+            when 'Id', 'Port'
+              @node_service[name] = @value.to_i
+            when 'NodeService'
+              @response['NodeServices'] << @node_service
+              @node_service = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_organization.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_organization.rb
new file mode 100644
index 0000000..33cf14c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_organization.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetOrganization < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end            
+              @response['Links'] << link
+            when 'Org'
+              org = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  org[attribute.first] = attribute.last
+                else
+                  org[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = org['href']
+              @response['name'] = org['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_organizations.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_organizations.rb
new file mode 100644
index 0000000..b0426f3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_organizations.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetOrganizations < Fog::Parsers::Base
+
+          def reset
+            @response = { 'OrgList' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            if name == 'Org'
+              organization = {}
+              until attributes.empty?
+                organization[attributes.shift] = attributes.shift
+              end
+              @response['OrgList'] << organization
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_public_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_public_ips.rb
new file mode 100644
index 0000000..98d9d2e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_public_ips.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetPublicIps< Fog::Parsers::Base
+
+          def reset
+            @ip_address = {}
+            @response = { 'PublicIpAddresses' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Href', 'Name'
+              @ip_address[name.downcase] = @value
+            when 'Id'
+              @ip_address['id'] = @value.to_i
+            when 'PublicIPAddress'
+              @response['PublicIpAddresses'] << @ip_address
+              @ip_address = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_tasks_list.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_tasks_list.rb
new file mode 100644
index 0000000..4cffd45
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_tasks_list.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetTasksList < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Tasks' => [] }
+            @task = {}
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Owner', 'Result'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              @task[name] = data
+            when 'Task'
+              until attributes.empty?
+                @task[attributes.shift] = attributes.shift
+              end
+            when 'TasksList'
+              tasks_list = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  tasks_list[attribute.first] = attribute.last
+                else
+                  tasks_list[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = tasks_list['href']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Task'
+              @response['Tasks'] << @task
+              @task = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_vapp_template.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_vapp_template.rb
new file mode 100644
index 0000000..0bda28b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_vapp_template.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetVappTemplate < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end            
+              @response['Links'] << link
+            when 'VAppTemplate'
+              vapp_template = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vapp_template[attribute.first] = attribute.last
+                else
+                  vapp_template[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = vapp_template['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response['Description'] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_vdc.rb
new file mode 100644
index 0000000..f05d6a2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/get_vdc.rb
@@ -0,0 +1,108 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetVdc < Fog::Parsers::Base
+
+          def reset
+            @in_storage_capacity = false
+            @in_cpu = false
+            @in_memory = false
+            @in_instantiated_vms_quota = false
+            @in_deployed_vms_quota = false
+            @response = { 
+              'links' => [],
+              'AvailableNetworks' => [],
+              'ComputeCapacity'   => {
+                'Cpu' => {},
+                'DeployedVmsQuota' => {},
+                'InstantiatedVmsQuota' => {},
+                'Memory' => {}
+              },
+              'StorageCapacity'  => {},
+              'ResourceEntities' => []
+            }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Cpu'
+              @in_cpu = true
+            when 'DeployedVmsQuota'
+              @in_deployed_vms_quota = true
+            when 'InstantiatedVmsQuota'
+              @in_instantiated_vms_quota = true
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response['links'] << link
+            when 'Memory'
+              @in_memory = true
+            when 'Network'
+              network = {}
+              until attributes.empty?
+                network[attributes.shift] = attributes.shift
+              end
+              @response['AvailableNetworks'] << network
+            when 'ResourceEntity'
+              resource_entity = {}
+              until attributes.empty?
+                resource_entity[attributes.shift] = attributes.shift
+              end
+              @response['ResourceEntities'] << resource_entity
+            when 'StorageCapacity'
+              @in_storage_capacity = true
+            when 'Vdc'
+              vdc = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vdc[attribute.first] = attribute.last
+                else
+                  vdc[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = vdc['href']
+              @response['name'] = vdc['name']
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Allocated', 'Limit', 'Units', 'Used'
+              if @in_cpu
+                @response['ComputeCapacity']['Cpu'][name] = @value
+              elsif @in_deployed_vms_quota
+                @response['ComputeCapacity']['DeployedVmsQuota'][name] = @value
+              elsif @in_instantiated_vms_quota
+                @response['ComputeCapacity']['InstantiatedVmsQuota'][name] = @value
+              elsif @in_memory
+                @response['ComputeCapacity']['Memory'][name] = @value
+              elsif @in_storage_capacity
+                @response['StorageCapacity'][name] = @value
+              end
+            when 'Cpu'
+              @in_cpu = false
+            when 'DeployedVmsQuota'
+              @in_deployed_vms_quota = false
+            when 'InstantiatedVmsQuota'
+              @in_instantiated_vms_quota = false
+            when 'Memory'
+              @in_memory = false
+            when 'StorageCapacity'
+              @in_storage_capacity = false
+            when 'Type'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
new file mode 100644
index 0000000..1f27a60
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class InstantiateVappTemplate < Fog::Parsers::Base
+
+          def reset
+            @property_key
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response['Links'] << link
+            when 'VApp'
+              vapp_template = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vapp_template[attribute.first] = attribute.last
+                else
+                  vapp_template[attributes.shift] = attributes.shift
+                end
+              end
+              @response.merge!(vapp_template.reject {|key, value| !['href', 'name', 'size', 'status', 'type'].include?(key)})
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/internet_service.rb
new file mode 100644
index 0000000..86bc25f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/internet_service.rb
@@ -0,0 +1,65 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class InternetService < Fog::Parsers::Base
+
+          def reset
+            @in_public_ip_address = false
+            @response = { 'PublicIpAddress' => {} }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Href'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = data
+              else
+                @response[name] = data
+              end
+            when 'PublicIpAddress'
+              @in_public_ip_address = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Protocol'
+              @response[name] = @value
+            when 'Enabled'
+              if @value == 'false'
+                @response[name] = false
+              else
+                @response[name] = true
+              end
+            when 'Id'
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = @value.to_i
+              else
+                @response[name] = @value.to_i
+              end
+            when 'Name'
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = @value
+              else
+                @response[name] = @value
+              end
+            when 'Port', 'Timeout'
+              @response[name] = @value.to_i
+            when 'PublicIpAddress'
+              @in_public_ip_address = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/network.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/network.rb
new file mode 100644
index 0000000..24f5481
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/network.rb
@@ -0,0 +1,51 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Network < Fog::Parsers::Base
+
+          def reset
+            @response = {
+              "links" => []
+            }
+          end
+
+          def start_element(name,attributes=[])
+            super
+            case name
+            when "Network"
+              until attributes.empty?
+                val = attributes.shift
+                if val.is_a?(String)
+                  @response[val] = attributes.shift
+                end
+              end
+              if @response.has_key?("name")
+                @response["subnet"] = @response["name"]
+              end
+              if @response.has_key?("href")
+                @response["id"] = @response["href"].split("/").last
+              end
+            when "Link"
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response["links"] << link
+            end
+          end
+
+          def end_element(name)
+            case name
+            when "Gateway", "Netmask", "FenceMode"
+              @response[name.downcase] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/node_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/node_service.rb
new file mode 100644
index 0000000..d4e4338
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/node_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class NodeService < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Href', 'IpAddress', 'Name', 'Protocol'
+              @response[name] = @value
+            when 'Enabled'
+              if @value == 'false'
+                @response[name] = false
+              else
+                @response[name] = true
+              end
+            when 'Id', 'Port'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/public_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/public_ip.rb
new file mode 100644
index 0000000..40191e2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/public_ip.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class PublicIp < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Href', 'Name'
+              @response[name.downcase] = @value
+            when 'Id'
+              @response['id'] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/task.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/task.rb
new file mode 100644
index 0000000..23f5987
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/task.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Task < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Owner', 'Result', 'Link', 'Error'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              @response[name] = data
+            when 'Task'
+              task = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  task[attribute.first] = attribute.last
+                else
+                  task[attributes.shift] = attributes.shift
+                end
+              end
+              @response.merge!(task.reject {|key,value| !['endTime', 'href', 'startTime', 'status', 'type'].include?(key)})
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/vapp.rb
new file mode 100644
index 0000000..5778316
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/parsers/shared/vapp.rb
@@ -0,0 +1,77 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Vapp < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [], 'VirtualHardware' => {}, 'OperatingSystem' => {} }
+            @in_operating_system = false
+            @resource_type = nil
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+              when 'Link'
+                link = {}
+                until attributes.empty?
+                  link[attributes.shift] = attributes.shift
+                end
+                @response['Links'] << link
+              when 'OperatingSystemSection'
+                @in_operating_system = true
+             when 'VApp'
+                vapp = {}
+                until attributes.empty?
+                  if attributes.first.is_a?(Array)
+                    attribute = attributes.shift
+                    vapp[attribute.first] = attribute.last
+                  else
+                    vapp[attributes.shift] = attributes.shift
+                  end
+                end
+                @response.merge!(vapp.reject {|key,value| !['href', 'name', 'size', 'status', 'type'].include?(key)})
+             end
+          end
+
+          def end_element(name)
+            case name
+            when 'IpAddress'
+              @response['IpAddress'] = @value
+            when 'Description'
+              if @in_operating_system
+                @response['OperatingSystem'][name] = @value
+                @in_operating_system = false
+              end
+            when 'ResourceType'
+              @resource_type = @value
+              case @value
+              when '3'
+                @get_cpu = true # cpu
+              when '4'  # memory
+                @get_ram = true
+              when '17' # disks
+                @get_disks = true
+              end
+            when 'VirtualQuantity'
+              case @resource_type
+              when '3'
+                @response['VirtualHardware']['cpu'] = @value
+              when '4'
+                @response['VirtualHardware']['ram'] = @value
+              when '17'
+                @response['VirtualHardware']['disks'] ||= []
+                @response['VirtualHardware']['disks'] << @value
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/add_internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/add_internet_service.rb
new file mode 100644
index 0000000..f8d683e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/add_internet_service.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * ip_id<~Integer> - Id of ip to add service to
+        # * name<~String> - Name of service
+        # * protocol<~String> - Protocol of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def add_internet_service(ip_id, name, protocol, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <InternetService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createInternetService">
+    <Name>#{name}</Name>
+    <Protocol>#{protocol.upcase}</Protocol>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </InternetService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "publicIps/#{ip_id}/internetServices"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def add_internet_service(ip_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/add_node_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/add_node_service.rb
new file mode 100644
index 0000000..fbb2ca0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/add_node_service.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * service_id<~String> - Id of service to add node to
+        # * ip<~String> - Private ip of server to add to node
+        # * name<~String> - Name of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def add_node_service(service_id, ip, name, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <NodeService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createNodeService">
+    <IpAddress>#{ip}</IpAddress>
+    <Name>#{name}</Name>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </NodeService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "internetServices/#{service_id}/nodes"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def add_node_service(ip)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/create_internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/create_internet_service.rb
new file mode 100644
index 0000000..8040d44
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/create_internet_service.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vDc to add internet service to
+        # * name<~String> - Name of service
+        # * protocol<~String> - Protocol of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def create_internet_service(vdc_id, name, protocol, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <InternetService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createInternetService">
+    <Name>#{name}</Name>
+    <Protocol>#{protocol.upcase}</Protocol>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </InternetService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "vdc/#{vdc_id}/internetServices"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def create_internet_service(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_internet_service.rb
new file mode 100644
index 0000000..d835b4b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_internet_service.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy an internet service
+        #
+        # ==== Parameters
+        # * internet_service_id<~Integer> - Id of service to destroy
+        #
+        def delete_internet_service(internet_service_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "InternetServices/#{internet_service_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_internet_service(internet_service_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_node_service.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_node_service.rb
new file mode 100644
index 0000000..100d0c0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_node_service.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a node
+        #
+        # ==== Parameters
+        # * node_service_id<~Integer> - Id of node to destroy
+        #
+        def delete_node_service(node_service_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "nodeServices/#{node_service_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_node_service(node_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_public_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_public_ip.rb
new file mode 100644
index 0000000..2646635
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_public_ip.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a public ip
+        #
+        # ==== Parameters
+        # * public_ip_id<~Integer> - Id of public ip to destroy
+        #
+        def delete_public_ip(public_ip_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "publicIps/#{public_ip_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_public_ip(public_ip_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_vapp.rb
new file mode 100644
index 0000000..60134d4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/delete_vapp.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to destroy
+        #
+        def delete_vapp(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'DELETE',
+            :path     => "vApp/#{vapp_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_vapp(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/deploy_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/deploy_vapp.rb
new file mode 100644
index 0000000..0c252ad
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/deploy_vapp.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vApp to deploy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def deploy_vapp(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/action/deploy"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def deploy_vapp(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_catalog.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_catalog.rb
new file mode 100644
index 0000000..44fdee7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_catalog.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a catalog
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to view catalog for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_catalog(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetCatalog.new,
+            :path     => "vdc/#{vdc_id}/catalog"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_catalog(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_catalog_item.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_catalog_item.rb
new file mode 100644
index 0000000..e039937
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_catalog_item.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a catalog item
+        #
+        # ==== Parameters
+        # * catalog_item_id<~Integer> - Id of catalog item to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_catalog_item(catalog_item_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetCatalogItem.new,
+            :path     => "catalogItem/#{catalog_item_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_catalog_item(catalog_item_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_internet_services.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_internet_services.rb
new file mode 100644
index 0000000..1e48e83
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_internet_services.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        require 'fog/terremark/parsers/shared/get_internet_services'
+
+        # Get a list of all internet services for a vdc
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vDc to get list of internet services for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'InternetServices'<~Array>
+        #       * 'id'<~String> => id of the internet service
+        #       * 'name'<~String> => name of service
+        #       * 'PublicIPAddress'<~Hash>
+        #       *   'Id'<~String> => id of the public IP
+        #       *   'name'<~String> => actual ip address
+        #
+        def get_internet_services(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetInternetServices.new,
+            :path     => "vdc/#{vdc_id}/internetServices"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_internet_services(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_network.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_network.rb
new file mode 100644
index 0000000..c45878b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_network.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a Network
+        #
+        # ==== Parameters
+        # * network_id<~Integer> - Id of the network to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   FIXME
+        def get_network(network_id)
+         request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Network.new,
+            :path     => "network/#{network_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_network(network_id)
+          network_id = network_id.to_i
+          response = Excon::Response.new
+          if network = @data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:id] == network_id }
+
+            body = { "links" => [],
+                     "type" => "application/vnd.vmware.vcloud.network+xml",
+                     "href" => "#{@base_url}/network/#{network_id}" }
+
+            network.each_key do |key|
+              body[key.to_s] = network[key]
+            end
+
+            link = { "name" => "IP Addresses",
+                     "rel"  => "down",
+                     "type" => "application/xml" }
+            link["href"] = case self
+            when Fog::Terremark::Ecloud::Mock
+              "#{@base_url}/extensions/network/#{network_id}/ips"
+            when Fog::Terremark::Vcloud::Mock
+              "#{@base_url}/network/#{network_id}/ipAddresses"
+            end
+            body["links"] << link
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, 
+              case self
+              when Fog::Terremark::Ecloud::Mock
+                "application/vnd.vmware.vcloud.network+xml"
+              when Fog::Terremark::Vcloud::Mock
+                "application/xml; charset=utf-8"
+              end
+            )
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_network_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_network_ips.rb
new file mode 100644
index 0000000..c131b9a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_network_ips.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a Network
+        #
+        # ==== Parameters
+        # * network_id<~Integer> - Id of the network to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   FIXME
+        def get_network_ips(network_id)
+          opts =  {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetNetworkIps.new,
+            :path     => "network/#{network_id}/ipAddresses"
+          }
+          if self.is_a?(Fog::Terremark::Ecloud::Real)
+            opts[:path] = "/extensions/network/#{network_id}/ips"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_network_ips(network_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_node_services.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_node_services.rb
new file mode 100644
index 0000000..ef615c7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_node_services.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        require 'fog/terremark/parsers/shared/get_node_services'
+
+        # Get a list of all internet services for a vdc
+        #
+        # ==== Parameters
+        # * service_id<~Integer> - Id of internet service that we want a list of nodes for
+         #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+       
+        #       
+        def get_node_services(service_id)
+           request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetNodeServices.new,
+            :path     => "InternetServices/#{service_id}/nodes"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_node_services(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_organization.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_organization.rb
new file mode 100644
index 0000000..40247d3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_organization.rb
@@ -0,0 +1,86 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of an organization
+        #
+        # ==== Parameters
+        # * organization_id<~Integer> - Id of organization to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'description'<~String> - Description of organization
+        #     * 'links'<~Array> - An array of links to entities in the organization
+        #       * 'href'<~String> - location of link
+        #       * 'name'<~String> - name of link
+        #       * 'rel'<~String> - action to perform
+        #       * 'type'<~String> - type of link
+        #     * 'name'<~String> - Name of organization
+        def get_organization(organization_id)
+          response = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetOrganization.new,
+            :path     => "org/#{organization_id}"
+          )
+          response
+        end
+
+      end
+
+      module Mock
+
+        def get_organization(organization_id)
+          organization_id = organization_id.to_i
+          response = Excon::Response.new
+
+          if org = @data[:organizations].detect { |org| org[:info][:id] == organization_id }
+
+            body = { "name" => org[:info][:name],
+                     "href" => "#{@base_url}/org/#{org[:info][:id]}",
+                     "Links" => [] }
+
+            body["Links"] = case self
+            when Fog::Terremark::Vcloud::Mock
+              _vdc_links(org[:vdcs][0])
+            when Fog::Terremark::Ecloud::Mock
+              org[:vdcs].map do |vdc|
+                _vdc_links(vdc)
+              end.flatten
+            end
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.org+xml")
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+        private
+
+        def _vdc_links(vdc)
+          [{ "name" => vdc[:name],
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.vdc+xml" },
+           { "name" => "#{vdc[:name]} Catalog",
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}/catalog",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.catalog+xml" },
+           { "name" => "#{vdc[:name]} Tasks List",
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}/taskslist",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.tasksList+xml" }
+          ]
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_organizations.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_organizations.rb
new file mode 100644
index 0000000..0036526
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_organizations.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of organizations
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'description'<~String> - Description of organization
+        #     * 'links'<~Array> - An array of links to entities in the organization
+        #     * 'name'<~String> - Name of organization
+        def get_organizations
+          request({
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic #{Base64.encode64("#{@terremark_username}:#{@terremark_password}").chomp!}",
+              # Terremark said they're going to remove passing in the Content-Type to login in a future release
+              'Content-Type'  => "application/vnd.vmware.vcloud.orgList+xml"
+            },
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::GetOrganizations.new,
+            :path     => 'login'
+          })
+        end
+
+      end
+
+      module Mock
+
+        def get_organizations
+          response = Excon::Response.new
+          org_list = @data[:organizations].map do |organization|
+            { "name" => organization[:info][:name],
+              "href" => "#{@base_url}/org/#{organization[:info][:id]}",
+              "type" => "application/vnd.vmware.vcloud.org+xml"
+            }
+          end
+          response.body = { "OrgList" => org_list }
+          response.status = 200
+          response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.orgList+xml")
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_public_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_public_ip.rb
new file mode 100644
index 0000000..a3cc166
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_public_ip.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a public ip
+        #
+        # ==== Parameters
+        # * public_ip_id<~Integer> - Id of public ip to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PublicIpAddresses'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        def get_public_ip(public_ip_id)
+          opts = {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::PublicIp.new,
+            :path     => "publicIps/#{public_ip_id}"
+          }
+          if self.class == Fog::Terremark::Ecloud::Real
+            opts[:path] = "extensions/publicIp/#{public_ip_id}"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_public_ip(public_ip_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_public_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_public_ips.rb
new file mode 100644
index 0000000..3a6ac41
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_public_ips.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of public ips
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to find public ips for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PublicIpAddresses'<~Array>
+        #       * 'href'<~String> - link to item
+        #       * 'name'<~String> - name of item
+        def get_public_ips(vdc_id)
+          opts = {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetPublicIps.new,
+            :path     => "vdc/#{vdc_id}/publicIps"
+          }
+          if self.class == Fog::Terremark::Ecloud::Real
+            opts[:path] = "extensions/vdc/#{vdc_id}/publicIps"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_public_ips(vdc_id)
+          vdc_id = vdc_id.to_i
+          response = Excon::Response.new
+
+          if vdc = @data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == vdc_id }
+            body = { "PublicIpAddresses" => [] }
+            vdc[:public_ips].each do |ip|
+              ip = { "name" => ip[:name],
+                     "href" => case self
+                                when Fog::Terremark::Ecloud::Mock
+                                  "#{@base_url}/extensions/publicIp/#{ip[:id]}"
+                                when Fog::Terremark::Vcloud::Mock
+                                  "#{@base_url}/PublicIps/#{ip[:id]}"
+                                end,
+                     "id"   => ip[:id].to_s }
+              body["PublicIpAddresses"] << ip
+            end
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body,
+                              case self
+                              when Fog::Terremark::Ecloud::Mock
+                                "application/vnd.tmrk.ecloud.publicIpsList+xml"
+                              when Fog::Terremark::Vcloud::Mock
+                                "application/xml; charset=utf-8"
+                              end
+            )
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_task.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_task.rb
new file mode 100644
index 0000000..37be4dc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_task.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a task
+        #
+        # ==== Parameters
+        # * task_id<~Integer> - Id of task to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        #     * 'Result'<~String> -
+        #       * 'href'<~String> - href of result
+        #       * 'name'<~String> - name of result
+        #       * 'type'<~String> - type of result
+        def get_task(task_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "task/#{task_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_task(task_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_tasks_list.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_tasks_list.rb
new file mode 100644
index 0000000..a700175
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_tasks_list.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of tasks
+        #
+        # ==== Parameters
+        # * tasks_list_id<~Integer> - Id of tasks lists to view
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_tasks_list(tasks_list_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetTasksList.new,
+            :path     => "tasksList/#{tasks_list_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_tasks_list(tasks_list_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vapp.rb
new file mode 100644
index 0000000..47f9b7e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vapp.rb
@@ -0,0 +1,50 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        #     * 'Result'<~String> -
+        #       * 'href'<~String> - href of result
+        #       * 'name'<~String> - name of result
+        #       * 'type'<~String> - type of result
+        def get_vapp(vapp_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Vapp.new,
+            :path     => "vapp/#{vapp_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vapp(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vapp_template.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vapp_template.rb
new file mode 100644
index 0000000..e382ebb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vapp_template.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vapp template
+        #
+        # ==== Parameters
+        # * vapp_template_id<~Integer> - Id of vapp template to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_vapp_template(vapp_template_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetVappTemplate.new,
+            :path     => "vAppTemplate/#{vapp_template_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vapp_template(vapp_template_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vdc.rb
new file mode 100644
index 0000000..2eb2d10
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/get_vdc.rb
@@ -0,0 +1,125 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vdc
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_vdc(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetVdc.new,
+            :path     => "vdc/#{vdc_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vdc(vdc_id)
+          vdc_id = vdc_id.to_i
+          response = Excon::Response.new
+
+          if vdc = @data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == vdc_id }
+
+            body = { "name" => vdc[:name],
+                     "href" => "#{@base_url}/vdc/#{vdc[:id]}",
+                     "StorageCapacity" => {},
+                     "ComputeCapacity" => { "InstantiatedVmsQuota" => {},
+                                            "DeployedVmsQuota" => {},
+                                            "Cpu" => {},
+                                            "Memory" => {} },
+                     "ResourceEntities" => [],
+                     "AvailableNetworks" => [],
+                     "links" => [] }
+
+            case self
+            when Fog::Terremark::Ecloud::Mock
+              body["StorageCapacity"] = { "Units" => "bytes * 10^9" }
+              vdc[:storage].each { |k,v| body["StorageCapacity"][k.to_s.capitalize] = v.to_s }
+
+              body["ComputeCapacity"] = { "InstantiatedVmsQuota" => {"Limit" => "-1", "Used" => "-1"},
+                                           "DeployedVmsQuota" => {"Limit" => "-1", "Used" => "-1"},
+                                           "Cpu" => { "Units" => "hz * 10^6" },
+                                           "Memory" => { "Units" => "bytes * 2^20" } }
+
+              [:cpu, :memory].each do |key|
+                vdc[key].each { |k,v| body["ComputeCapacity"][key.to_s.capitalize][k.to_s.capitalize] = v.to_s }
+              end
+
+              body["links"] << { "name" => "Public IPs",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/publicIps",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.publicIpsList+xml" }
+
+              body["links"] << { "name" => "Internet Services",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/internetServices",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.internetServicesList+xml" }
+
+              body["links"] << { "name" => "Firewall Access List",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/firewallAcls",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.firewallAclsList+xml" }
+
+            when Fog::Terremark::Vcloud::Mock
+              body["links"] << { "name" => "Public IPs",
+                                 "href" => "#{@base_url}/vdc/#{vdc[:id]}/publicIps",
+                                 "rel"  => "down",
+                                 "type" => "application/xml" }
+
+              body["links"] << { "name" => "Internet Services",
+                                 "href" => "#{@base_url}/vdc/#{vdc[:id]}/internetServices",
+                                 "rel"  => "down",
+                                 "type" => "application/xml" }
+            end
+
+            vdc[:vms].each do |vm|
+              body["ResourceEntities"] << { "name" => vm[:name],
+                                            "href" => "#{@base_url}/vapp/#{vm[:id]}",
+                                            "type" => "application/vnd.vmware.vcloud.vApp+xml" }
+            end
+
+            vdc[:networks].each do |network|
+              body["AvailableNetworks"] << { "name" => network[:name],
+                                             "href" => "#{@base_url}/network/#{network[:id]}",
+                                             "type" => "application/vnd.vmware.vcloud.network+xml" }
+            end
+
+            body["links"] << { "name" => vdc[:name],
+                               "href" => "#{@base_url}/vdc/#{vdc[:id]}/catalog",
+                               "rel"  => "down",
+                               "type" => "application/vnd.vmware.vcloud.catalog+xml" }
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.org+xml")
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
new file mode 100644
index 0000000..4a463dc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
@@ -0,0 +1,79 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Instatiate a vapp template
+        #
+        # ==== Parameters
+        # * name<~String>: Name of the resulting vapp .. must start with letter, up to 15 chars alphanumeric.
+        # * options<~Hash>:
+        # * cpus<~Integer>: Number of cpus in [1, 2, 4, 8], defaults to 1
+        # * memory<~Integer>: Amount of memory either 512 or a multiple of 1024, defaults to 512
+        # * vapp_template<~String>: id of the vapp template to be instantiated
+        # ==== Returns
+        # * response<~Excon::Response>:
+        # * body<~Hash>:
+        # * 'Links;<~Array> (e.g. up to vdc)
+        # * 'href'<~String> Link to the resulting vapp
+        # * 'name'<~String> - name of item
+        # * 'type'<~String> - type of item
+        # * 'status'<~String> - 0(pending) --> 2(off) -->4(on)
+        def instantiate_vapp_template(name, vapp_template, options = {})
+          unless name.length < 15
+            raise ArgumentError.new('Name must be fewer than 15 characters')
+          end
+          options['cpus'] ||= 1
+          options['memory'] ||= 512
+          options['network_id'] ||= default_network_id
+          options['vdc_id'] ||= default_vdc_id
+
+          data = <<-DATA
+<?xml version="1.0" encoding="UTF-8"?>
+<InstantiateVAppTemplateParams name="#{name}" xmlns="http://www.vmware.com/vcloud/v0.8" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.vmware.com/vcloud/v0.8 http://services.vcloudexpress.terremark.com/api/v0.8/ns/vcloud.xsd">
+  <VAppTemplate href="#{@scheme}://#{@host}/#{@path}/vAppTemplate/#{vapp_template}" />
+  <InstantiationParams xmlns:vmw="http://www.vmware.com/schema/ovf">
+    <ProductSection xmlns:ovf="http://schemas.dmtf.org/ovf/envelope/1" xmlns:q1="http://www.vmware.com/vcloud/v0.8"/>
+    <VirtualHardwareSection xmlns:q1="http://www.vmware.com/vcloud/v0.8">
+      <Item xmlns="http://schemas.dmtf.org/ovf/envelope/1">
+        <InstanceID xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">1</InstanceID>
+        <ResourceType xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">3</ResourceType>
+        <VirtualQuantity xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">#{options['cpus']}</VirtualQuantity>
+      </Item>
+      <Item xmlns="http://schemas.dmtf.org/ovf/envelope/1">
+        <InstanceID xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">2</InstanceID>
+        <ResourceType xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">4</ResourceType>
+        <VirtualQuantity xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">#{options['memory']}</VirtualQuantity>
+      </Item>
+    </VirtualHardwareSection>
+    <NetworkConfigSection>
+      <NetworkConfig>
+        <NetworkAssociation href="#{@scheme}://#{@host}/#{@path}/network/#{options['network_id']}"/>
+      </NetworkConfig>
+    </NetworkConfigSection>
+  </InstantiationParams>
+</InstantiateVAppTemplateParams>
+DATA
+
+          request(
+            :body => data,
+            :expects => 200,
+            :headers => { 'Content-Type' => 'application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml' },
+            :method => 'POST',
+            :parser => Fog::Parsers::Terremark::Shared::InstantiateVappTemplate.new,
+            :path => "vdc/#{options['vdc_id']}/action/instantiatevAppTemplate"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def instatiate_vapp_template(vapp_template_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_off.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_off.rb
new file mode 100644
index 0000000..947712c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_off.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Power off a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to power off
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_off(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/powerOff"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def power_off(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_on.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_on.rb
new file mode 100644
index 0000000..abb2672
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_on.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Power on a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to power on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_on(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/powerOn"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def power_on(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_reset.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_reset.rb
new file mode 100644
index 0000000..d513a22
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_reset.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reset a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to reset
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_reset(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/reset"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def reset(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_shutdown.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_shutdown.rb
new file mode 100644
index 0000000..9cf51f0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/requests/shared/power_shutdown.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Shutdown a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to shutdown
+        #
+        # ==== Returns
+        # Nothing
+        def power_shutdown(vapp_id)
+          request(
+            :expects  => 204,
+            :method   => 'POST',
+            :path     => "vApp/#{vapp_id}/power/action/shutdown"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def power_shutdown(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/shared.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/shared.rb
new file mode 100644
index 0000000..88f3e33
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/shared.rb
@@ -0,0 +1,289 @@
+module Fog
+  module Terremark
+    module Shared
+
+      # Commond methods shared by Real and Mock
+      module Common
+
+        def default_organization_id
+          @default_organization_id ||= begin
+            org_list = get_organizations.body['OrgList']
+            if org_list.length == 1
+              org_list.first['href'].split('/').last.to_i
+            else
+              nil
+            end
+          end
+        end
+
+      end
+
+      module Parser
+
+        def parse(data)
+          case data['type']
+          when 'application/vnd.vmware.vcloud.vApp+xml'
+            servers.new(data.merge!(:connection => self))
+          else
+            data
+          end
+        end
+
+      end
+
+      module Real
+        include Common
+
+        private
+
+        def auth_token
+          response = @connection.request({
+            :expects   => 200,
+            :headers   => {
+              'Authorization' => "Basic #{Base64.encode64("#{@terremark_username}:#{@terremark_password}").chomp!}",
+              'Content-Type'  => "application/vnd.vmware.vcloud.orgList+xml"
+            },
+            :host      => @host,
+            :method    => 'POST',
+            :parser    => Fog::Parsers::Terremark::Shared::GetOrganizations.new,
+            :path      => "#{@path}/login"
+          })
+          response.headers['Set-Cookie']
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          unless @cookie
+            @cookie = auth_token
+          end
+          begin
+            do_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            @cookie = auth_token
+            do_request(params)
+          end
+        end
+
+        def do_request(params)
+          headers = {}
+          if @cookie
+            headers.merge!('Cookie' => @cookie)
+          end
+          @connection.request({
+            :body     => params[:body],
+            :expects  => params[:expects],
+            :headers  => headers.merge!(params[:headers] || {}),
+            :host     => @host,
+            :method   => params[:method],
+            :parser   => params[:parser],
+            :path     => "#{@path}/#{params[:path]}"
+          })
+        end
+
+      end
+
+      module Mock
+        include Common
+
+        def self.mock_data
+        {
+          :organizations =>
+          [
+            {
+              :info => {
+                :name => "Boom Inc.",
+                :id => 1
+              },
+              :vdcs => [
+                { :id => 21,
+                  :name => "Boomstick",
+                  :storage => { :used => 105, :allocated => 200 },
+                  :cpu => { :allocated => 10000 },
+                  :memory => { :allocated => 20480 },
+                  :networks => [
+                    { :id => 31,
+                      :name => "1.2.3.0/24",
+                      :subnet => "1.2.3.0/24",
+                      :gateway => "1.2.3.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    },
+                    { :id => 32,
+                      :name => "4.5.6.0/24",
+                      :subnet => "4.5.6.0/24",
+                      :gateway => "4.5.6.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    },
+                  ],
+                  :vms => [
+                    { :id => 41,
+                      :name => "Broom 1"
+                    },
+                    { :id => 42,
+                      :name => "Broom 2"
+                    },
+                    { :id => 43,
+                      :name => "Email!"
+                    }
+                  ],
+                  :public_ips => [
+                    { :id => 51,
+                      :name => "99.1.2.3"
+                    },
+                    { :id => 52,
+                      :name => "99.1.2.4"
+                    },
+                    { :id => 53,
+                      :name => "99.1.9.7"
+                    }
+                  ]
+                },
+                { :id => 22,
+                  :storage => { :used => 40, :allocated => 150 },
+                  :cpu => { :allocated => 1000 },
+                  :memory => { :allocated => 2048 },
+                  :name => "Rock-n-Roll",
+                  :networks => [
+                    { :id => 33,
+                      :name => "7.8.9.0/24",
+                      :subnet => "7.8.9.0/24",
+                      :gateway => "7.8.9.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    }
+                  ],
+                  :vms => [
+                    { :id => 44,
+                      :name => "Master Blaster"
+                    }
+                  ],
+                  :public_ips => [
+                    { :id => 54,
+                      :name => "99.99.99.99"
+                    }
+                  ]
+                }
+              ]
+            }
+          ]
+        }
+        end
+
+        def self.error_headers
+          {"X-Powered-By"=>"ASP.NET",
+           "Date"=> Time.now.to_s,
+           "Content-Type"=>"text/html",
+           "Content-Length"=>"0",
+           "Server"=>"Microsoft-IIS/7.0",
+           "Cache-Control"=>"private"}
+        end
+
+        def self.unathorized_status
+          401
+        end
+
+        def self.headers(body, content_type)
+          {"X-Powered-By"=>"ASP.NET",
+           "Date"=> Time.now.to_s,
+           "Content-Type"=> content_type,
+           "Content-Length"=> body.to_s.length,
+           "Server"=>"Microsoft-IIS/7.0",
+           "Set-Cookie"=>"vcloud-token=ecb37bfc-56f0-421d-97e5-bf2gdf789457; path=/",
+           "Cache-Control"=>"private"}
+        end
+
+        def self.status
+          200
+        end
+
+        def initialize(options={})
+          self.class.instance_eval '
+            def self.data
+              @data ||= Hash.new do |hash, key|
+                hash[key] = Fog::Terremark::Shared::Mock.mock_data
+              end
+            end'
+          self.class.instance_eval '
+            def self.reset_data(keys=data.keys)
+              for key in [*keys]
+                data.delete(key)
+              end
+            end'
+        end
+      end
+
+      def check_shared_options(options)
+        %w{ecloud vcloud}.each do |cloud|
+          cloud_option_keys = options.keys.select { |key| key.to_s =~ /^terremark_#{cloud}_.*/ }
+          unless cloud_option_keys.length == 0 || cloud_option_keys.length == 2
+            raise ArgumentError.new("terremark_#{cloud}_username and terremark_#{cloud}_password required to access teremark")
+          end
+        end
+      end
+
+      def shared_requires
+        require 'fog/terremark/models/shared/address'
+        require 'fog/terremark/models/shared/addresses'
+        require 'fog/terremark/models/shared/network'
+        require 'fog/terremark/models/shared/networks'
+        require 'fog/terremark/models/shared/server'
+        require 'fog/terremark/models/shared/servers'
+        require 'fog/terremark/models/shared/task'
+        require 'fog/terremark/models/shared/tasks'
+        require 'fog/terremark/models/shared/vdc'
+        require 'fog/terremark/models/shared/vdcs'
+        require 'fog/terremark/parsers/shared/get_catalog'
+        require 'fog/terremark/parsers/shared/get_catalog_item'
+        require 'fog/terremark/parsers/shared/get_internet_services'
+        require 'fog/terremark/parsers/shared/get_network_ips'
+        require 'fog/terremark/parsers/shared/get_node_services'
+        require 'fog/terremark/parsers/shared/get_organization'
+        require 'fog/terremark/parsers/shared/get_organizations'
+        require 'fog/terremark/parsers/shared/get_public_ips'
+        require 'fog/terremark/parsers/shared/get_tasks_list'
+        require 'fog/terremark/parsers/shared/get_vapp_template'
+        require 'fog/terremark/parsers/shared/get_vdc'
+        require 'fog/terremark/parsers/shared/instantiate_vapp_template'
+        require 'fog/terremark/parsers/shared/internet_service'
+        require 'fog/terremark/parsers/shared/network'
+        require 'fog/terremark/parsers/shared/node_service'
+        require 'fog/terremark/parsers/shared/public_ip'
+        require 'fog/terremark/parsers/shared/task'
+        require 'fog/terremark/parsers/shared/vapp'
+        require 'fog/terremark/requests/shared/add_internet_service'
+        require 'fog/terremark/requests/shared/add_node_service'
+        require 'fog/terremark/requests/shared/create_internet_service'
+        require 'fog/terremark/requests/shared/delete_internet_service'
+        require 'fog/terremark/requests/shared/delete_public_ip'
+        require 'fog/terremark/requests/shared/delete_node_service'
+        require 'fog/terremark/requests/shared/delete_vapp'
+        require 'fog/terremark/requests/shared/deploy_vapp'
+        require 'fog/terremark/requests/shared/get_catalog'
+        require 'fog/terremark/requests/shared/get_catalog_item'
+        require 'fog/terremark/requests/shared/get_internet_services'
+        require 'fog/terremark/requests/shared/get_network'
+        require 'fog/terremark/requests/shared/get_network_ips'
+        require 'fog/terremark/requests/shared/get_node_services'
+        require 'fog/terremark/requests/shared/get_organization'
+        require 'fog/terremark/requests/shared/get_organizations'
+        require 'fog/terremark/requests/shared/get_public_ip'
+        require 'fog/terremark/requests/shared/get_public_ips'
+        require 'fog/terremark/requests/shared/get_task'
+        require 'fog/terremark/requests/shared/get_tasks_list'
+        require 'fog/terremark/requests/shared/get_vapp'
+        require 'fog/terremark/requests/shared/get_vapp_template'
+        require 'fog/terremark/requests/shared/get_vdc'
+        require 'fog/terremark/requests/shared/instantiate_vapp_template'
+        require 'fog/terremark/requests/shared/power_off'
+        require 'fog/terremark/requests/shared/power_on'
+        require 'fog/terremark/requests/shared/power_reset'
+        require 'fog/terremark/requests/shared/power_shutdown'
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/terremark/vcloud.rb b/lib/bbcloud/vendor/fog/lib/fog/terremark/vcloud.rb
new file mode 100644
index 0000000..9c50697
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/terremark/vcloud.rb
@@ -0,0 +1,113 @@
+module Fog
+  module Terremark
+   module Vcloud
+
+     module Bin
+     end
+
+     module Defaults
+       HOST   = 'services.vcloudexpress.terremark.com'
+       PATH   = '/api/v0.8'
+       PORT   = 443
+       SCHEME = 'https'
+     end
+
+     extend Fog::Terremark::Shared
+
+     def self.new(options={})
+
+       unless @required
+         shared_requires
+         @required = true
+       end
+
+       check_shared_options(options)
+
+       if Fog.mocking?
+          Fog::Terremark::Vcloud::Mock.new(options)
+        else
+          Fog::Terremark::Vcloud::Real.new(options)
+        end
+     end
+
+     class Real
+
+       include Fog::Terremark::Shared::Real
+       include Fog::Terremark::Shared::Parser
+
+        def initialize(options={})
+          @terremark_password = options[:terremark_vcloud_password]
+          @terremark_username = options[:terremark_vcloud_username]
+          @host   = options[:host]   || Fog::Terremark::Vcloud::Defaults::HOST
+          @path   = options[:path]   || Fog::Terremark::Vcloud::Defaults::PATH
+          @port   = options[:port]   || Fog::Terremark::Vcloud::Defaults::PORT
+          @scheme = options[:scheme] || Fog::Terremark::Vcloud::Defaults::SCHEME
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def default_vdc_id
+          if default_organization_id
+            @default_vdc_id ||= begin
+              vdcs = get_organization(default_organization_id).body['Links'].select {|link|
+                link['type'] == 'application/vnd.vmware.vcloud.vdc+xml'
+              }
+              if vdcs.length == 1
+                vdcs.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+
+        def default_network_id
+          if default_vdc_id
+            @default_network_id ||= begin
+              networks = get_vdc(default_vdc_id).body['AvailableNetworks']
+              if networks.length == 1
+                networks.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+
+        def default_public_ip_id
+          if default_vdc_id
+            @default_public_ip_id ||= begin
+              ips = get_public_ips(default_vdc_id).body['PublicIpAddresses']
+              if ips.length == 1
+                ips.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+      end
+
+     class Mock
+       include Fog::Terremark::Shared::Mock
+       include Fog::Terremark::Shared::Parser
+
+       def initialize(option = {})
+         super
+         @base_url = Fog::Terremark::Vcloud::Defaults::SCHEME + "://" +
+                     Fog::Terremark::Vcloud::Defaults::HOST +
+                     Fog::Terremark::Vcloud::Defaults::PATH
+         @data = self.class.data[:terremark_vcloud_username]
+       end
+     end
+
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud.rb
new file mode 100644
index 0000000..bc48d7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud.rb
@@ -0,0 +1,418 @@
+require 'builder'
+require 'fog/vcloud/model'
+require 'fog/vcloud/collection'
+require 'fog/vcloud/generators'
+# ecloud/vcloud requires at the bottom so that the following will be defined
+
+module URI
+  class Generic
+    def host_url
+      @host_url ||= "#{self.scheme}://#{self.host}#{self.port ? ":#{self.port}" : ''}"
+    end
+  end
+end
+
+module Fog
+  class Vcloud < Fog::Service
+
+    requires :username, :password, :versions_uri
+
+    model_path 'fog/vcloud/models'
+    model :vdc
+    collection :vdcs
+
+    request_path 'fog/vcloud/requests'
+    request :login
+    request :get_versions
+    request :get_vdc
+    request :get_organization
+    request :get_network
+
+    class UnsupportedVersion < Exception ; end
+
+    module Shared
+
+      def default_organization_uri
+        @default_organization_uri ||= begin
+          unless @login_results
+            do_login
+          end
+          case @login_results.body[:Org]
+          when Array
+            @login_results.body[:Org].first[:href]
+          when Hash
+            @login_results.body[:Org][:href]
+          else
+            nil
+          end
+        end
+      end
+
+      # login handles the auth, but we just need the Set-Cookie
+      # header from that call.
+      def do_login
+        @login_results = login
+        @cookie = @login_results.headers['Set-Cookie']
+      end
+
+      def supported_versions
+        @supported_versions ||= get_versions(@versions_uri).body[:VersionInfo]
+      end
+
+      def xmlns
+        { "xmlns" => "http://www.vmware.com/vcloud/v0.8",
+          "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance",
+          "xmlns:xsd" => "http://www.w3.org/2001/XMLSchema" }
+      end
+
+      # private
+
+      def ensure_unparsed(uri)
+        if uri.is_a?(String)
+          uri
+        else
+          uri.to_s
+        end
+      end
+
+    end
+
+    class Real
+      include Shared
+      extend Fog::Vcloud::Generators
+
+      attr_accessor :login_uri
+      attr_reader :versions_uri
+
+      def supporting_versions
+        ["0.8"]
+      end
+
+      def initialize(options = {})
+        @connections = {}
+        @versions_uri = URI.parse(options[:versions_uri])
+        @module = options[:module]
+        @version = options[:version]
+        @username = options[:username]
+        @password = options[:password]
+        @persistent = options[:persistent]
+      end
+
+      def default_organization_uri
+        @default_organization_uri ||= begin
+          unless @login_results
+            do_login
+          end
+          case @login_results.body[:Org]
+          when Array
+            @login_results.body[:Org].first[:href]
+          when Hash
+            @login_results.body[:Org][:href]
+          else
+            nil
+          end
+        end
+      end
+
+      def reload
+        @connections.each_value { |k,v| v.reset if v }
+      end
+
+      # If the cookie isn't set, do a get_organizations call to set it
+      # and try the request.
+      # If we get an Unauthorized error, we assume the token expired, re-auth and try again
+      def request(params)
+        unless @cookie
+          do_login
+        end
+        begin
+          do_request(params)
+        rescue Excon::Errors::Unauthorized => e
+          do_login
+          do_request(params)
+        end
+      end
+
+      private
+
+      def ensure_parsed(uri)
+        if uri.is_a?(String)
+          URI.parse(uri)
+        else
+          uri
+        end
+      end
+
+      def supported_version_numbers
+        case supported_versions
+        when Array
+          supported_versions.map { |version| version[:Version] }
+        when Hash
+          [ supported_versions[:Version] ]
+        end
+      end
+
+      def get_login_uri
+        check_versions
+        URI.parse case supported_versions
+        when Array
+          supported_versions.detect {|version| version[:Version] == @version }[:LoginUrl]
+        when Hash
+          supported_versions[:LoginUrl]
+        end
+      end
+
+      # If we don't support any versions the service does, then raise an error.
+      # If the @version that super selected isn't in our supported list, then select one that is.
+      def check_versions
+        if @version
+          unless supported_version_numbers.include?(@version.to_s)
+            raise UnsupportedVersion.new("#{@version} is not supported by the server.")
+          end
+          unless supporting_versions.include?(@version.to_s)
+            raise UnsupportedVersion.new("#{@version} is not supported by #{self.class}")
+          end
+        else
+          unless @version = (supported_version_numbers & supporting_versions).sort.first
+            raise UnsupportedVersion.new("\nService @ #{@versions_uri} supports: #{supported_version_numbers.join(', ')}\n" +
+                                         "#{self.class} supports: #{supporting_versions.join(', ')}")
+          end
+        end
+      end
+
+      # Don't need to  set the cookie for these or retry them if the cookie timed out
+      def unauthenticated_request(params)
+        do_request(params)
+      end
+
+      # Use this to set the Authorization header for login
+      def authorization_header
+        "Basic #{Base64.encode64("#{@username}:#{@password}").chomp!}"
+      end
+
+      def login_uri
+        @login_uri ||= get_login_uri
+      end
+
+      # login handles the auth, but we just need the Set-Cookie
+      # header from that call.
+      def do_login
+        @login_results = login
+        @cookie = @login_results.headers['Set-Cookie']
+      end
+
+      # Actually do the request
+      def do_request(params)
+        # Convert the uri to a URI if it's a string.
+        if params[:uri].is_a?(String)
+          params[:uri] = URI.parse(params[:uri])
+        end
+
+        # Hash connections on the host_url ... There's nothing to say we won't get URI's that go to
+        # different hosts.
+        @connections[params[:uri].host_url] ||= Fog::Connection.new(params[:uri].host_url, @persistent)
+
+        # Set headers to an empty hash if none are set.
+        headers = params[:headers] || {}
+
+        # Add our auth cookie to the headers
+        if @cookie
+          headers.merge!('Cookie' => @cookie)
+        end
+
+        # Make the request
+        response = @connections[params[:uri].host_url].request({
+          :body     => params[:body] || '',
+          :expects  => params[:expects] || 200,
+          :headers  => headers,
+          :method   => params[:method] || 'GET',
+          :path     => params[:uri].path
+        })
+
+        # Parse the response body into a hash
+        #puts response.body
+        unless response.body.empty?
+          if params[:parse]
+            document = Fog::ToHashDocument.new
+            parser = Nokogiri::XML::SAX::PushParser.new(document)
+            parser << response.body
+            parser.finish
+
+            response.body = document.body
+          end
+        end
+
+        response
+      end
+    end
+
+    class Mock
+      include Shared
+
+      def self.base_url
+        "https://fakey.com/api/v0.8"
+      end
+
+      def self.data_reset
+        @mock_data = nil
+      end
+
+      def self.data( base_url = self.base_url )
+        @mock_data ||=
+        {
+          :versions => [
+            { :version => "v0.8", :login_url => "#{base_url}/login", :supported => true }
+          ],
+          :vdc_resources => [
+            {
+              :type => "application/vnd.vmware.vcloud.vApp+xml",
+              :href => "#{base_url}/vapp/61",
+              :name => "Foo App 1"
+            },
+            {
+              :type => "application/vnd.vmware.vcloud.vApp+xml",
+              :href => "#{base_url}/vapp/62",
+              :name => "Bar App 1"
+            },
+            {
+              :type => "application/vnd.vmware.vcloud.vApp+xml",
+              :href => "#{base_url}/vapp/63",
+              :name => "Bar App 2"
+            }
+          ],
+          :organizations =>
+          [
+            {
+              :info => {
+                :href => "#{base_url}/org/1",
+                :name => "Boom Inc.",
+              },
+              :vdcs => [
+
+                { :href => "#{base_url}/vdc/21",
+                  :id => "21",
+                  :name => "Boomstick",
+                  :storage => { :used => "105", :allocated => "200" },
+                  :cpu => { :allocated => "10000" },
+                  :memory => { :allocated => "20480" },
+                  :networks => [
+                    { :id => "31",
+                      :href => "#{base_url}/network/31",
+                      :name => "1.2.3.0/24",
+                      :subnet => "1.2.3.0/24",
+                      :gateway => "1.2.3.1",
+                      :netmask => "255.255.255.0",
+                      :dns => "8.8.8.8",
+                      :features => [
+                        { :type => :FenceMode, :value => "isolated" }
+                      ],
+                      :ips => { "1.2.3.3" => "Broom 1", "1.2.3.4" => "Broom 2", "1.2.3.10" => "Email" }
+                    },
+                    { :id => "32",
+                      :href => "#{base_url}/network/32",
+                      :name => "4.5.6.0/24",
+                      :subnet => "4.5.6.0/24",
+                      :gateway => "4.5.6.1",
+                      :netmask => "255.255.255.0",
+                      :dns => "8.8.8.8",
+                      :features => [
+                        { :type => :FenceMode, :value => "isolated" }
+                      ],
+                      :ips => { }
+                    },
+                  ],
+                  :vms => [
+                    { :href => "#{base_url}/vap/41",
+                      :name => "Broom 1"
+                    },
+                    { :href => "#{base_url}/vap/42",
+                      :name => "Broom 2"
+                    },
+                    { :href => "#{base_url}/vap/43",
+                      :name => "Email!"
+                    }
+                  ]
+                },
+                { :href => "#{base_url}/vdc/22",
+                  :id => "22",
+                  :storage => { :used => "40", :allocated => "150" },
+                  :cpu => { :allocated => "1000" },
+                  :memory => { :allocated => "2048" },
+                  :name => "Rock-n-Roll",
+                  :networks => [
+                    { :id => "33",
+                      :href => "#{base_url}/network/33",
+                      :name => "7.8.9.0/24",
+                      :subnet => "7.8.9.0/24",
+                      :gateway => "7.8.9.1",
+                      :dns => "8.8.8.8",
+                      :netmask => "255.255.255.0",
+                      :features => [
+                        { :type => :FenceMode, :value => "isolated" }
+                      ],
+                      :ips => { "7.8.9.10" => "Master Blaster" }
+                    }
+                  ],
+                  :vms => [
+                    { :href => "#{base_url}/vap/44",
+                      :name => "Master Blaster"
+                    }
+                  ]
+                }
+              ]
+            }
+          ]
+        }
+      end
+
+      def vdc_from_uri(uri)
+        match = Regexp.new(%r:.*/vdc/(\d+):).match(uri.to_s)
+        if match
+          mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == match[1] }
+        end
+      end
+
+      def ip_from_uri(uri)
+        match = Regexp.new(%r:.*/publicIp/(\d+):).match(uri.to_s)
+        if match
+          mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.compact.detect { |public_ip| public_ip[:id] == match[1] }
+        end
+      end
+
+      def initialize(options = {})
+        @versions_uri = URI.parse('https://vcloud.fakey.com/api/versions')
+      end
+
+      def mock_it(status, mock_data, mock_headers = {})
+        response = Excon::Response.new
+
+        #Parse the response body into a hash
+        if mock_data.empty?
+          response.body = mock_data
+        else
+          document = Fog::ToHashDocument.new
+          parser = Nokogiri::XML::SAX::PushParser.new(document)
+          parser << mock_data
+          parser.finish
+          response.body = document.body
+        end
+
+        response.status = status
+        response.headers = mock_headers
+        response
+      end
+
+      def mock_error(expected, status, body='', headers={})
+        raise Excon::Errors::Unauthorized.new("Expected(#{expected}) <=> Actual(#{status})")
+      end
+
+      def mock_data
+        Fog::Vcloud::Mock.data
+      end
+
+    end
+  end
+end
+
+require 'fog/vcloud/terremark/ecloud'
+require 'fog/vcloud/terremark/vcloud'
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/bin.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/bin.rb
new file mode 100644
index 0000000..b9c05a5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/bin.rb
@@ -0,0 +1,57 @@
+module Vcloud
+  class << self
+
+    def services
+      if Fog.credentials.has_key?(:vcloud)
+        Fog.credentials[:vcloud].keys.sort { |a,b| a.to_s <=> b.to_s }
+      else
+        []
+      end
+    end
+
+    def registered_services
+      Vcloud.services.map { |service| ":" << service.to_s }.join(", ")
+    end
+
+    def complete_service_options?(service)
+      if Fog.credentials.has_key?(:vcloud)
+        if Fog.credentials[:vcloud].has_key?(service)
+          service = Fog.credentials[:vcloud][service]
+          if Fog::Vcloud.requirements.all? { |option| service.has_key?(option) }
+            return true
+          end
+        end
+      end
+      false
+    end
+
+    if Vcloud.services.any? && Vcloud.services.all? { |service| Vcloud.complete_service_options?(service) }
+
+      def initialized?
+        true
+      end
+
+      def startup_notice
+        Formatador.display_line("You have access to the following Vcloud services: #{Vcloud.registered_services}.")
+      end
+
+      def [](service)
+        @@connections ||= Hash.new do |hash, key|
+          if credentials = Fog.credentials[:vcloud][key]
+            hash[key] = eval(credentials[:module]).new(credentials)
+          else
+            raise ArgumentError.new("Unregistered service: :#{key}. Registered services are: #{Vcloud.registered_services}")
+          end
+        end
+        @@connections[service]
+      end
+
+    else
+
+      def initialized?
+        false
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/collection.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/collection.rb
new file mode 100644
index 0000000..3bdff2c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/collection.rb
@@ -0,0 +1,12 @@
+module Fog
+  class Vcloud < Fog::Service
+    class Collection < Fog::Collection
+
+      def load(objects)
+        objects = [ objects ] if objects.is_a?(Hash)
+        super
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/generators.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/generators.rb
new file mode 100644
index 0000000..c975339
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/generators.rb
@@ -0,0 +1,33 @@
+module Fog
+  class Vcloud < Fog::Service
+    module Generators
+
+      def unauthenticated_basic_request(*args)
+        self.class_eval <<-EOS, __FILE__,__LINE__
+          def #{args[0]}(uri)
+            unauthenticated_request({
+              :expects => #{args[1] || 200},
+              :method  => '#{args[2] || 'GET'}',
+              :headers => #{args[3] ? args[3].inspect : '{}'},
+              :parse => true,
+              :uri     => uri })
+          end
+        EOS
+      end
+
+      def basic_request(*args)
+        self.class_eval <<-EOS, __FILE__,__LINE__
+          def #{args[0]}(uri)
+            request({
+              :expects => #{args[1] || 200},
+              :method  => '#{args[2] || 'GET'}',
+              :headers => #{args[3] ? args[3].inspect : '{}'},
+              :body => '#{args[4] ? args[4] : ''}',
+              :parse => true,
+              :uri     => uri })
+          end
+        EOS
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/model.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/model.rb
new file mode 100644
index 0000000..a11d17b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/model.rb
@@ -0,0 +1,22 @@
+module Fog
+  class Vcloud < Fog::Service
+    class Model < Fog::Model
+
+      attr_accessor :loaded
+      alias_method :loaded?, :loaded
+
+      def reload
+        instance = super
+        @loaded = true
+        instance
+      end
+
+      def load_unless_loaded!
+        unless @loaded
+          reload
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/models/vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/models/vdc.rb
new file mode 100644
index 0000000..bf1ec7d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/models/vdc.rb
@@ -0,0 +1,26 @@
+module Fog
+  class Vcloud
+    class Vdc < Fog::Vcloud::Model
+
+      identity :href
+
+      ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd
+
+      attribute :name
+      attribute :type
+      attribute :description, :aliases => :Description
+      attribute :other_links, :aliases => :Link
+      attribute :compute_capacity, :aliases => :ComputeCapacity
+      attribute :storage_capacity, :aliases => :StorageCapacity
+      attribute :available_networks, :aliases => :AvailableNetworks, :squash => :Network
+      attribute :resource_entities, :aliases => :ResourceEntities, :squash => :ResourceEntity
+      attribute :enabled, :aliases => :IsEnabled
+      attribute :vm_quota, :aliases => :VmQuota
+      attribute :nic_quota, :aliases => :NicQuota
+      attribute :network_quota, :aliases => :NetworkQuota
+      attribute :allocation_model, :aliases => :AllocationModel
+
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/models/vdcs.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/models/vdcs.rb
new file mode 100644
index 0000000..9ffa986
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/models/vdcs.rb
@@ -0,0 +1,35 @@
+require 'fog/vcloud/models/vdc'
+
+module Fog
+  class Vcloud
+    class Vdcs < Fog::Vcloud::Collection
+
+      model Fog::Vcloud::Vdc
+
+      def all
+        data = connection.get_organization(organization_uri).body[:Link].select { |link| link[:type] == "application/vnd.vmware.vcloud.vdc+xml" }
+        data.each { |link| link.delete_if { |key, value| [:rel].include?(key) } }
+        load(data)
+      end
+
+      def get(uri)
+        if data = connection.get_vdc(uri)
+          new(data.body)
+        end
+      rescue Fog::Errors::NotFound
+        nil
+      end
+
+      def organization_uri
+        @organizatio_uri ||= connection.default_organization_uri
+      end
+
+      private
+
+      def organization_uri=(new_organization_uri)
+        @organization_uri = new_organization_uri
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_network.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_network.rb
new file mode 100644
index 0000000..cc947c3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_network.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+
+    class Real
+      basic_request :get_network
+    end
+
+    class Mock
+
+      def get_network(network_uri)
+        #
+        # Based off of:
+        # vCloud API Guide v0.8 - Page 50
+        #
+        # Did not implement AssociatedNetwork, seems redundant, haven't seen it in use yet
+        # Did not implement the following features: Dhcp, Nat & Firewall
+        #
+        network_uri = ensure_unparsed(network_uri)
+        type = "application/vnd.vmware.vcloud.network+xml"
+        response = Excon::Response.new
+        if network = mock_data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:href] == network_uri.to_s }
+          xml = Builder::XmlMarkup.new
+          mock_it 200,
+            xml.Network(xmlns.merge(:href => network[:href], :name => network[:name], :type => type)) {
+              xml.Description(network[:name])
+              xml.Configuration {
+                xml.Gateway(network[:gateway])
+                xml.Netmask(network[:netmask])
+                xml.Dns(network[:dns])
+              }
+              if network[:features]
+                xml.Features {
+                  if feature = network[:features].detect { |feature| feature[:type] == :fencemode }
+                    xml.FenceMode(feature[:value])
+                  end
+                }
+              end
+            },
+            { 'Content-Type' => type }
+        else
+          mock_error 200, "401 Unauthorized"
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_organization.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_organization.rb
new file mode 100644
index 0000000..e4eb923
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_organization.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+
+    class Real
+      basic_request :get_organization
+    end
+
+    class Mock
+
+      def get_organization(organization_uri)
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=540&Lang=1&SID=
+        # 
+        # vCloud API Guide v0.9 - Page 26
+        #
+        organization_uri = ensure_unparsed(organization_uri)
+        if org = mock_data[:organizations].detect { |org| org[:info][:href] == organization_uri }
+          xml = Builder::XmlMarkup.new
+
+          mock_it 200,
+            xml.Org(xmlns.merge(:href => org[:info][:href], :name => org[:info][:name])) {
+
+              org[:vdcs].each do |vdc|
+                xml.Link(:rel => "down",
+                         :href => vdc[:href],
+                         :type => "application/vnd.vmware.vcloud.vdc+xml",
+                         :name => vdc[:name])
+                xml.Link(:rel => "down",
+                         :href => "#{vdc[:href]}/catalog",
+                         :type => "application/vnd.vmware.vcloud.catalog+xml",
+                         :name => "#{vdc[:name]} Catalog")
+                xml.Link(:rel => "down",
+                         :href => "#{vdc[:href]}/tasksList",
+                         :type => "application/vnd.vmware.vcloud.tasksList+xml",
+                         :name => "#{vdc[:name]} Tasks List")
+              end
+            },
+            {'Content-Type' => "application/vnd.vmware.vcloud.org+xml" }
+        else
+          mock_error 200, "401 Unauthorized"
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_vdc.rb
new file mode 100644
index 0000000..fd89fd8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_vdc.rb
@@ -0,0 +1,82 @@
+module Fog
+  class Vcloud
+
+    class Real
+      basic_request :get_vdc
+    end
+
+    class Mock
+      # WARNING: Incomplete
+      #Based off of:
+      #vCloud API Guide v0.9 - Page 27
+
+      def get_vdc(vdc_uri)
+        vdc_uri = ensure_unparsed(vdc_uri)
+        if vdc = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:href] == vdc_uri }
+          xml = Builder::XmlMarkup.new
+          mock_it 200,
+            xml.Vdc(xmlns.merge(:href => vdc[:href], :name => vdc[:name])) {
+              xml.Link(:rel => "up",
+                       :href => Fog::Vcloud::Mock.data[:organizations].detect { |org| org[:vdcs].detect { |_vdc| vdc[:href] == _vdc[:href] }[:href] == vdc[:href] }[:info][:href],
+                       :type => "application/vnd.vmware.vcloud.org+xml")
+              xml.Link(:rel => "add",
+                       :href => vdc[:href] + "/action/uploadVAppTemplate",
+                       :type => "application/vnd.vmware.vcloud.uploadVAppTemplateParams+xml")
+              xml.Link(:rel => "add",
+                       :href => vdc[:href] + "/media",
+                       :type => "application/vnd.vmware.vcloud.media+xml")
+              xml.Link(:rel => "add",
+                       :href => vdc[:href] + "/action/instantiateVAppTemplate",
+                       :type => "application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml")
+              xml.Link(:rel => "add",
+                       :type => "application/vnd.vmware.vcloud.cloneVAppParams+xml",
+                       :href => vdc[:href] + "/action/cloneVApp")
+              xml.Link(:rel => "add",
+                       :type => "application/vnd.vmware.vcloud.captureVAppParams+xml",
+                       :href => vdc[:href] + "/action/captureVApp")
+              xml.Link(:rel => "add",
+                       :type => "application/vnd.vmware.vcloud.composeVAppParams+xml",
+                       :href => vdc[:href] + "/action/composeVApp")
+              xml.AllocationModel("AllocationPool")
+              xml.Description(vdc[:name] + " VDC")
+              xml.ResourceEntities {
+                Fog::Vcloud::Mock.data[:vdc_resources].each do |resource|
+                  xml.ResourceEntity(resource)
+                end
+              }
+              xml.AvailableNetworks {
+                vdc[:networks].each do |network|
+                  xml.Network( :name => network[:name], :href => network[:href], :type => "application/vnd.vmware.vcloud.network+xml" )
+                end
+              }
+              xml.ComputeCapacity{
+                xml.Cpu {
+                  xml.Units("Mhz")
+                  xml.Allocated(vdc[:cpu][:allocated])
+                  xml.Limit(vdc[:cpu][:allocated])
+                }
+                xml.Memory {
+                  xml.Units("MB")
+                  xml.Allocated(vdc[:memory][:allocated])
+                  xml.Limit(vdc[:memory][:allocated])
+                }
+              }
+              xml.StorageCapacity{
+                xml.Units("MB")
+                xml.Allocated(vdc[:storage][:allocated])
+                xml.Limit(vdc[:storage][:allocated])
+              }
+              xml.VmQuota(0)
+              xml.NicQuota(0)
+              xml.IsEnabled('true')
+              xml.NetworkQuota(0)
+              #FIXME: Incomplete
+            }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml' }
+        else
+          mock_error 200, "401 Unauthorized"
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_versions.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_versions.rb
new file mode 100644
index 0000000..276f13d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/get_versions.rb
@@ -0,0 +1,34 @@
+module Fog
+  class Vcloud
+
+    class Real
+      unauthenticated_basic_request :get_versions
+    end
+
+    class Mock
+
+      def get_versions(versions_uri)
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=535&Lang=1&SID=
+        # https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/02-get-versions.aspx
+        # vCloud API Guide v0.9 - Page 89
+        #
+        xml = Builder::XmlMarkup.new
+
+        mock_it 200,
+          xml.SupportedVersions( xmlns.merge("xmlns" => "http://www.vmware.com/vcloud/versions")) {
+
+            mock_data[:versions].select {|version| version[:supported] }.each do |version|
+              xml.VersionInfo {
+                xml.Version(version[:version])
+                xml.LoginUrl(version[:login_url])
+              }
+            end
+          }
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/login.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/login.rb
new file mode 100644
index 0000000..81953c1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/requests/login.rb
@@ -0,0 +1,46 @@
+module Fog
+  class Vcloud
+
+    class Real
+
+
+      def login
+        unauthenticated_request({
+          :expects  => 200,
+          :headers  => {
+            'Authorization' => authorization_header
+          },
+          :method   => 'POST',
+          :parse    => true,
+          :uri      => login_uri
+        })
+      end
+
+    end
+
+    class Mock
+
+      def login
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=536&Lang=1&SID=
+        # https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/01-get-login-token.aspx
+        # vCloud API Guide v0.9 - Page 17
+        #
+        xml = Builder::XmlMarkup.new
+
+        mock_it 200,
+          xml.OrgList(xmlns) {
+              mock_data[:organizations].each do |org|
+                xml.Org( :type => "application/vnd.vmware.vcloud.org+xml", :href => org[:info][:href], :name => org[:info][:name] )
+              end
+            },
+            { 'Set-Cookie' => 'vcloud-token=fc020a05-21d7-4f33-9b2a-25d8cd05a44e; path=/',
+              'Content-Type' => 'application/vnd.vmware.vcloud.orgslist+xml' }
+
+      end
+
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud.rb
new file mode 100644
index 0000000..95a79f5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud.rb
@@ -0,0 +1,204 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud < Fog::Vcloud
+
+        model_path 'fog/vcloud/terremark/ecloud/models'
+        model :catalog_item
+        model :catalog
+        model :firewall_acl
+        collection :firewall_acls
+        model :internet_service
+        collection :internet_services
+        model :ip
+        collection :ips
+        model :network
+        collection :networks
+        model :node
+        collection :nodes
+        model :public_ip
+        collection :public_ips
+        model :server
+        collection :servers
+        model :task
+        collection :tasks
+        model :vdc
+        collection :vdcs
+
+        request_path 'fog/vcloud/terremark/ecloud/requests'
+        request :add_internet_service
+        request :add_node
+        request :clone_vapp
+        request :configure_internet_service
+        request :configure_network
+        request :configure_network_ip
+        request :configure_node
+        request :configure_vapp
+        request :delete_internet_service
+        request :delete_node
+        request :delete_vapp
+        request :get_catalog
+        request :get_catalog_item
+        request :get_customization_options
+        request :get_firewall_acls
+        request :get_firewall_acl
+        request :get_internet_services
+        request :get_network
+        request :get_network_ip
+        request :get_network_ips
+        request :get_network_extensions
+        request :get_node
+        request :get_nodes
+        request :get_public_ip
+        request :get_public_ips
+        request :get_task
+        request :get_task_list
+        request :get_vapp
+        request :get_vapp_template
+        request :get_vdc
+        request :instantiate_vapp_template
+        request :power_off
+        request :power_on
+        request :power_reset
+        request :power_shutdown
+
+        class Mock < Fog::Vcloud::Mock
+
+          def initialize(options={})
+          end
+
+          def self.base_url
+            "https://fakey.com/api/v0.8b-ext2.3"
+          end
+
+          def self.data_reset
+            @mock_data = nil
+            Fog::Vcloud::Mock.data_reset
+          end
+
+          def self.extension_url
+            self.base_url + "/extensions"
+          end
+
+          def self.data( base_url = self.base_url )
+            @mock_data ||= begin
+              vcloud_data = Fog::Vcloud::Mock.data(base_url)
+              vcloud_data.delete( :versions )
+              vcloud_data.merge!( :versions => [ { :version => "v0.8b-ext2.3", :login_url => "#{base_url}/login", :supported => true } ] )
+
+              vcloud_data[:organizations][0][:vdcs][0][:public_ips] =
+                  [
+                    { :id => "51",
+                      :href => extension_url + "/publicIp/51",
+                      :name => "99.1.2.3",
+                      :services => [
+                        { :id => "71", :href => extension_url + "/internetService/71", :port => "80", :protocol => 'HTTP', :enabled => "true",
+                          :timeout => "2", :name => 'Web Site', :description => 'Web Servers', :redirect_url => 'http://fakey.com',
+                          :nodes => [ {:id => "81", :href => extension_url + "/nodeService/81", :ip_address => "1.2.3.5",
+                                       :name => "Test Node 1", :port => "80", :enabled => "true", :description => "web 1" },
+                                      {:id => "82", :href => extension_url + "/nodeService/82", :ip_address => "1.2.3.6",
+                                       :name => "Test Node 2", :port => "80", :enabled => "true", :description => "web 2" },
+                                    ] },
+                        { :id => "72", :href => extension_url + "/internetService/72", :port => "7000", :protocol => 'HTTP', :enabled => "true",
+                          :timeout => "2", :name => 'An SSH Map', :description => 'SSH 1', :redirect_url => '',
+                          :nodes => [ {:id => "83", :href => extension_url + "/nodeService/83", :ip_address => "1.2.3.5",
+                                       :name => "SSH", :port => "22", :enabled => "true", :description => "web ssh" } 
+                                    ] }
+                      ]
+                    },
+                    { :id => "52",
+                      :href => extension_url + "/publicIp/52",
+                      :name => "99.1.2.4",
+                      :services => [
+                        { :id => "73", :href => extension_url + "/internetService/73", :port => "80", :protocol => 'HTTP', :enabled => "true",
+                          :timeout => "2", :name => 'Web Site', :description => 'Web Servers', :redirect_url => 'http://fakey.com',
+                          :nodes => [] },
+                        { :id => "74", :href => extension_url + "/internetService/74", :port => "7000", :protocol => 'HTTP', :enabled => "true",
+                          :timeout => "2", :name => 'An SSH Map', :description => 'SSH 2', :redirect_url => '',
+                          :nodes => [] }
+                      ]
+                    },
+                    { :id => "53",
+                      :href => extension_url + "/publicIp/53",
+                      :name => "99.1.9.7",
+                      :services => []
+                    }
+                  ]
+
+              vcloud_data[:organizations][0][:vdcs][1][:public_ips] =
+                  [
+                    { :id => "54",
+                      :href => extension_url + "/publicIp/54",
+                      :name => "99.99.99.99",
+                      :services => []
+                    }
+                  ]
+
+              vcloud_data[:organizations].each do |organization|
+                organization[:info][:extension_href] = extension_url
+                organization[:vdcs].each do | vdc|
+                  vdc[:extension_href] = "#{base_url}/extensions/vdc/#{vdc[:id]}"
+                  vdc[:networks].each do |network|
+                    network[:extension_href] = "#{extension_url}/network/#{network[:id]}"
+                    network[:rnat] = vdc[:public_ips].first[:name]
+                  end
+                end
+              end
+
+              vcloud_data
+            end
+          end
+
+          def self.public_ip_href(ip)
+            "#{base_url}/extensions/publicIp/#{ip[:id]}"
+          end
+
+          def self.internet_service_href(internet_service)
+            "#{base_url}/extensions/internetService/#{internet_service[:id]}"
+          end
+
+          def ecloud_xmlns
+            { :xmlns => "urn:tmrk:eCloudExtensions-2.3", :"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance" }
+          end
+
+          def mock_ip_from_service_url(uri)
+            mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.compact.detect { |pip| pip[:services].detect { |service| service[:href] == uri } }
+          end
+
+          def mock_ip_and_service_from_service_url(uri)
+            if ip = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.compact.detect { |pip| pip[:services].detect { |service| service[:href] == uri } }
+              if service = ip[:services].detect { |service| service[:href] == uri }
+                [ip, service]
+              else
+                [ip, nil]
+              end
+            else
+              [nil, nil]
+            end
+          end
+
+          def mock_node_from_url(uri)
+            mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.map { |pip| pip[:services] }.flatten.map { |service| service[:nodes] }.flatten.detect { |node| node[:href] == uri }
+          end
+
+          def mock_service_from_node_url(uri)
+            mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.map { |pip| pip[:services] }.flatten.map { |service| service }.detect {|service| service[:nodes].map { |node| node[:href] }.include?(uri) }
+          end
+
+          def mock_data
+            Fog::Vcloud::Terremark::Ecloud::Mock.data
+          end
+        end
+
+        class Real < Fog::Vcloud::Real
+
+          def supporting_versions
+            ["v0.8b-ext2.3", "0.8b-ext2.3"]
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/catalog.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/catalog.rb
new file mode 100644
index 0000000..0f80aff
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/catalog.rb
@@ -0,0 +1,30 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Catalog < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::CatalogItem
+
+          attribute :href, :aliases => :Href
+
+          def all
+            if data = connection.get_catalog(href).body[:CatalogItems][:CatalogItem]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_catalog_item(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb
new file mode 100644
index 0000000..2314565
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb
@@ -0,0 +1,31 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class CatalogItem < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+          attribute :type
+          attribute :name
+          attribute :entity, :aliases => :Entity
+          attribute :link, :aliases => :Link
+          attribute :property, :aliases => :Property
+
+          def customization_options
+            load_unless_loaded!
+            if data = connection.get_customization_options( link[:href] ).body
+              data.delete_if { |key, value| [:xmlns_i, :xmlns].include?(key) }
+              data
+            else
+              nil
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb
new file mode 100644
index 0000000..d75e027
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb
@@ -0,0 +1,28 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class FirewallAcl < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+          attribute :protocol, :aliases => :Protocol
+          attribute :source, :aliases => :Source
+          attribute :destination, :aliases => :Destination
+          attribute :permission, :aliases => :Permission
+          attribute :port_start, :aliases => :PortStart
+          attribute :port_end, :aliases => :PortEnd
+          attribute :port_type, :aliases => :PortType
+          attribute :type, :aliases => :Type
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb
new file mode 100644
index 0000000..ebe143d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb
@@ -0,0 +1,33 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/firewall_acl'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class FirewallAcls < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::FirewallAcl
+
+          attribute :href, :aliases => :Href
+
+          def all
+            if data = connection.get_firewall_acls(href).body[:FirewallAcl]
+              data = [ data ] if data.is_a?(Hash)
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_firewall_acl(uri).body
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/internet_service.rb
new file mode 100644
index 0000000..68f7ebe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/internet_service.rb
@@ -0,0 +1,84 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class InternetService < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+          attribute :protocol, :aliases => :Protocol
+          attribute :port, :aliases => :Port
+          attribute :enabled, :aliases => :Enabled
+          attribute :description, :aliases => :Description
+          attribute :public_ip, :aliases => :PublicIpAddress
+          attribute :timeout, :aliases => :Timeout
+          attribute :redirect_url, :aliases => :RedirectURL
+          attribute :monitor, :aliases => :Monitor
+
+          def delete
+            requires :href
+
+            connection.delete_internet_service( href )
+          end
+
+          def save
+            if new_record?
+              result = connection.add_internet_service( collection.href, _compose_service_data )
+              merge_attributes(result.body)
+            else
+              connection.configure_internet_service( href, _compose_service_data, _compose_ip_data )
+            end
+          end
+
+          def monitor=(new_monitor = {})
+            if new_monitor.nil? || new_monitor.empty?
+              @monitor = nil
+            elsif new_monitor.is_a?(Hash)
+              @monitor = {}
+              @monitor[:type] = new_monitor[:MonitorType] || new_monitor[:type]
+              @monitor[:url_send_string] = new_monitor[:UrlSendString] || new_monitor[:url_send_string]
+              @monitor[:http_headers] = new_monitor[:HttpHeader] || new_monitor[:http_headers]
+              @monitor[:http_headers] = @monitor[:http_headers].split("\n") unless @monitor[:http_headers].is_a?(Array)
+              @monitor[:receive_string] = new_monitor[:ReceiveString] || new_monitor[:receive_string]
+              @monitor[:interval] = new_monitor[:Interval] || new_monitor[:interval]
+              @monitor[:response_timeout] = new_monitor[:ResponseTimeOut] || new_monitor[:response_timeout]
+              @monitor[:downtime] = new_monitor[:DownTime] || new_monitor[:downtime]
+              @monitor[:retries] = new_monitor[:Retries] || new_monitor[:retries]
+              @monitor[:is_enabled] = new_monitor[:IsEnabled] || new_monitor[:is_enabled]
+            else
+              raise RuntimeError.new("monitor needs to either be nil or a Hash")
+            end
+          end
+
+          def nodes
+            @nodes ||= Fog::Vcloud::Terremark::Ecloud::Nodes.new( :connection => connection, :href => href + "/nodeServices" )
+          end
+
+          private
+
+          def _compose_service_data
+            #For some reason inject didn't work
+            service_data = {}
+            self.class.attributes.select{ |attribute| !send(attribute).nil? }.each { |attribute| service_data[attribute] = send(attribute) }
+            service_data
+          end
+
+          def _compose_ip_data
+            if public_ip.nil?
+              {}
+            else
+              { :id => public_ip[:Id], :href => public_ip[:Href], :name => public_ip[:Name] }
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/internet_services.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/internet_services.rb
new file mode 100644
index 0000000..98cba61
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/internet_services.rb
@@ -0,0 +1,35 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/internet_service'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class InternetServices < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::InternetService
+
+          attribute :href, :aliases => :Href
+
+          def all
+            if data = connection.get_internet_services(href).body[:InternetService]
+              load(data)
+            end
+          end
+
+          # Optimize later, no need to get_internet_services again?
+          def get(uri)
+            internet_services = connection.get_internet_services(href).body[:InternetService]
+            internet_services = [ internet_services ] if internet_services.is_a?(Hash)
+            if data = internet_services.detect { |service| service[:Href] == uri }
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/ip.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/ip.rb
new file mode 100644
index 0000000..e9bf790
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/ip.rb
@@ -0,0 +1,51 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Ip < Fog::Vcloud::Model
+
+          ignore_attributes :xmlns_i, :xmlns
+
+          identity :href, :aliases => :Href
+
+          attribute :name, :aliases => :Name
+          attribute :status, :aliases => :Status
+          attribute :server, :aliases => :Server
+          attribute :rnat, :aliases => :RnatAddress
+          attribute :id, :aliases => :Id, :type => :integer
+
+          def rnat=(new_rnat)
+            @rnat = new_rnat
+            @changed = true
+          end
+
+          def save
+            if @changed
+              connection.configure_network_ip( href, _compose_network_ip_data )
+            end
+            true
+          end
+
+          def reload
+            super
+            @changed = false
+            true
+          end
+
+          private
+          def _compose_network_ip_data
+            {
+              :id => id,
+              :href => href,
+              :name => name,
+              :status => status,
+              :server => server,
+              :rnat => rnat
+            }
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/ips.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/ips.rb
new file mode 100644
index 0000000..f377920
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/ips.rb
@@ -0,0 +1,34 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/ip'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Ips < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Ip
+
+          undef_method :create
+
+          attribute :href
+
+          def all
+            if data = connection.get_network_ips(href).body[:IpAddress]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_network_ip(uri).body
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/network.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/network.rb
new file mode 100644
index 0000000..79ca6f4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/network.rb
@@ -0,0 +1,73 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Network < Fog::Vcloud::Model
+
+          identity :href
+
+          ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd, :xmlns_i, :Configuration
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+          attribute :features, :aliases => :Features, :type => :array
+          attribute :links, :aliases => :Link, :type => :array
+          attribute :type
+          attribute :gateway, :aliases => :GatewayAddress
+          attribute :broadcast, :aliases => :BroadcastAddress
+          attribute :address, :aliases => :Address
+          attribute :rnat, :aliases => :RnatAddress
+          attribute :extension_href, :aliases => :Href
+
+          def ips
+            load_unless_loaded!
+            @ips ||= Fog::Vcloud::Terremark::Ecloud::Ips.
+              new( :connection => connection,
+                   :href => links.detect { |link| link[:name] == "IP Addresses" }[:href] )
+          end
+
+          def rnat=(new_rnat)
+            @rnat = new_rnat
+            @changed = true
+          end
+
+          def save
+            if @changed
+              connection.configure_network( extension_href, _compose_network_data )
+            end
+            true
+          end
+
+          def reload
+            super
+            merge_attributes(extension_data.body)
+          end
+
+          private
+
+          def extension_data
+            connection.get_network_extensions( extensions_link[:href] )
+          end
+
+          def extensions_link
+            links.detect { |link| link[:name] == name }
+          end
+
+          def _compose_network_data
+            {
+              :id => id,
+              :href => extension_href,
+              :name => name,
+              :rnat => rnat,
+              :address => address,
+              :broadcast => broadcast,
+              :gateway => gateway
+            }
+          end
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/networks.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/networks.rb
new file mode 100644
index 0000000..dcace7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/networks.rb
@@ -0,0 +1,35 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/network'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Networks < Fog::Vcloud::Collection
+
+          undef_method :create
+
+          model Fog::Vcloud::Terremark::Ecloud::Network
+
+          attribute :href
+
+          def all
+            if data = connection.get_vdc(href).body[:AvailableNetworks][:Network]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_network(uri)
+              new(data.body)
+            end
+            rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/node.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/node.rb
new file mode 100644
index 0000000..c699117
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/node.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Node < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+          
+          attribute :ip_address, :aliases => :IpAddress
+          attribute :description, :aliases => :Description
+          attribute :name, :aliases => :Name
+          attribute :port, :aliases => :Port
+          attribute :enabled, :aliases => :Enabled
+          attribute :id, :aliases => :Id
+
+          def delete
+            requires :href
+
+            connection.delete_node( href )
+          end
+
+          def save
+            if new_record?
+              result = connection.add_node( collection.href, _compose_node_data )
+              merge_attributes(result.body)
+            else
+              connection.configure_node( href, _compose_node_data )
+            end
+          end
+
+          private
+
+          def _compose_node_data
+            node_data = {}
+            self.class.attributes.select{ |attribute| !send(attribute).nil? }.each { |attribute| node_data[attribute] = send(attribute).to_s }
+            node_data
+          end
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/nodes.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/nodes.rb
new file mode 100644
index 0000000..d3caac5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/nodes.rb
@@ -0,0 +1,32 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/node'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Nodes < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Node
+
+          attribute :href, :aliases => :Href
+
+          def all
+            if data = connection.get_nodes(href).body[:NodeService]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_node(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/public_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/public_ip.rb
new file mode 100644
index 0000000..d042af8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/public_ip.rb
@@ -0,0 +1,25 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class PublicIp < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+
+          def internet_services
+            load_unless_loaded!
+            @internet_services ||= Fog::Vcloud::Terremark::Ecloud::InternetServices.
+              new( :connection => connection,
+                   :href => href.to_s + "/internetServices" )
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/public_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/public_ips.rb
new file mode 100644
index 0000000..4bd8985
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/public_ips.rb
@@ -0,0 +1,38 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/public_ip'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class PublicIps < Fog::Vcloud::Collection
+
+          undef_method :create
+
+          attribute :href, :aliases => :Href
+
+          model Fog::Vcloud::Terremark::Ecloud::PublicIp
+
+          #get_request :get_public_ip
+          #vcloud_type "application/vnd.tmrk.ecloud.publicIp+xml"
+          #all_request lambda { |public_ips| public_ips.connection.get_public_ips(public_ips.href) }
+
+          def all
+            if data = connection.get_public_ips(href).body[:PublicIPAddress]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_public_ip(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/server.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/server.rb
new file mode 100644
index 0000000..f03bc35
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/server.rb
@@ -0,0 +1,199 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Server < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+          attribute :type
+          attribute :name
+          attribute :status
+          attribute :network_connections, :aliases => :NetworkConnectionSection, :squash => :NetworkConnection
+          attribute :os, :aliases => :OperatingSystemSection
+          attribute :virtual_hardware, :aliases => :VirtualHardwareSection
+          attribute :storage_size, :aliases => :size
+          attribute :links, :aliases => :Link, :type => :array
+
+          def friendly_status
+            load_unless_loaded!
+            case status
+            when '0'
+              'creating'
+            when '2'
+              'off'
+            when '4'
+              'on'
+            else
+              'unkown'
+            end
+          end
+
+          def ready?
+            load_unless_loaded!
+            @status == '2'
+          end
+
+          def on?
+            load_unless_loaded!
+            @status == '4'
+          end
+
+          def off?
+            load_unless_loaded!
+            @status == '2'
+          end
+
+          def power_on
+            power_operation( :power_on => :powerOn )
+          end
+
+          def power_off
+            power_operation( :power_off => :powerOff )
+          end
+
+          def shutdown
+            power_operation( :power_shutdown => :shutdown )
+          end
+
+          def power_reset
+            power_operation( :power_reset => :reset )
+          end
+
+          def graceful_restart
+            requires :href
+            shutdown
+            wait_for { off? }
+            power_on
+          end
+
+          def delete
+            requires :href
+            connection.delete_vapp( href)
+          end
+
+          def name=(new_name)
+            @name = new_name
+            @changed = true
+          end
+
+          def cpus
+            { :count => cpu_mess[:VirtualQuantity].to_i,
+              :units => cpu_mess[:AllocationUnits] }
+          end
+
+          def cpus=(qty)
+            @changed = true
+            cpu_mess[:VirtualQuantity] = qty.to_s
+          end
+
+          def memory
+            { :amount => memory_mess[:VirtualQuantity].to_i,
+              :units => memory_mess[:AllocationUnits] }
+          end
+
+          def memory=(amount)
+            @changed = true
+            memory_mess[:VirtualQuantity] = amount.to_s
+          end
+
+          def disks
+            disk_mess.map do |dm|
+              { :number => dm[:AddressOnParent], :size => dm[:VirtualQuantity].to_i, :resource => dm[:HostResource] }
+            end
+          end
+
+          def add_disk(size)
+            if @disk_change == :deleted
+              raise RuntimeError, "Can't add a disk w/o saving changes or reloading"
+            else
+              @disk_change = :added
+              load_unless_loaded!
+              virtual_hardware[:Item] << { :ResourceType => '17',
+                                           :AddressOnParent => (disk_mess.map { |dm| dm[:AddressOnParent] }.sort.last.to_i + 1).to_s, 
+                                           :VirtualQuantity => size.to_s }
+            end
+            true
+          end
+
+          def delete_disk(number)
+            if @disk_change == :added
+              raise RuntimeError, "Can't delete a disk w/o saving changes or reloading"
+            else
+              @disk_change = :deleted
+              load_unless_loaded!
+              unless number == 0
+                virtual_hardware[:Item].delete_if { |vh| vh[:ResourceType] == '17' && vh[:AddressOnParent].to_i == number }
+              end
+            end
+            true
+          end
+
+          def reload
+            reset_tracking
+            super
+          end
+
+          def save
+            if new_record?
+              #Lame ...
+              raise RuntimeError, "Should not be here"
+            else
+              if on?
+                if @changed
+                  raise RuntimeError, "Can't save cpu, name or memory changes while the VM is on."
+                end
+              end
+              connection.configure_vapp( href, _compose_vapp_data )
+            end
+            reset_tracking
+          end
+
+          private
+
+          def reset_tracking
+            @disk_change = false
+            @changed = false
+          end
+
+          def _compose_vapp_data
+            { :name   => name,
+              :cpus   => cpus[:count],
+              :memory => memory[:amount],
+              :disks  => disks
+            }
+          end
+
+          def memory_mess
+            load_unless_loaded!
+            virtual_hardware[:Item].detect { |item| item[:ResourceType] == "4" }
+          end
+
+          def cpu_mess
+            load_unless_loaded!
+            virtual_hardware[:Item].detect { |item| item[:ResourceType] == "3" }
+          end
+
+          def disk_mess
+            load_unless_loaded!
+            virtual_hardware[:Item].select { |item| item[:ResourceType] == "17" }
+          end
+
+          def power_operation(op)
+            requires :href
+            begin
+              connection.send(op.keys.first, href + "/power/action/#{op.values.first}" )
+            rescue Excon::Errors::InternalServerError => e
+              #Frankly we shouldn't get here ...
+              raise e unless e.to_s =~ /because it is already powered on/
+            end
+            true
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/servers.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/servers.rb
new file mode 100644
index 0000000..157de94
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/servers.rb
@@ -0,0 +1,56 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/server'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Servers < Fog::Vcloud::Collection
+
+          undef_method :create
+
+          model Fog::Vcloud::Terremark::Ecloud::Server
+
+          attribute :href, :aliases => :Href
+
+          def all
+            load(_vapps)
+          end
+
+          def get(uri)
+            if data = connection.get_vapp(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+          def create( catalog_item_uri, options )
+            options[:vdc_uri] = href
+            options[:cpus] ||= 1
+            options[:memory] ||= 512
+            data = connection.instantiate_vapp_template( catalog_item_uri, options ).body
+            object = new(data)
+            object
+          end
+
+          private
+
+          def _resource_entities
+            connection.get_vdc(href).body[:ResourceEntities][:ResourceEntity]
+          end
+
+          def _vapps
+            resource_entities = _resource_entities
+            if resource_entities.nil?
+              []
+            else
+              resource_entities
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/task.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/task.rb
new file mode 100644
index 0000000..a063c84
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/task.rb
@@ -0,0 +1,23 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Task < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+          attribute :status
+          attribute :type
+          attribute :result, :aliases => :Result
+          attribute :owner, :aliases => :Owner
+          attribute :start_time, :aliases => :startTime, :type => :time
+          attribute :end_time, :aliases => :endTime, :type => :time
+          attribute :error, :aliases => :Error
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/tasks.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/tasks.rb
new file mode 100644
index 0000000..01a6a29
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/tasks.rb
@@ -0,0 +1,32 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/task'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Tasks < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Task
+
+          attribute :href, :aliases => :Href
+
+          def all
+            if data = connection.get_task_list(href).body[:Task]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_task(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/vdc.rb
new file mode 100644
index 0000000..69f3291
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/vdc.rb
@@ -0,0 +1,79 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Vdc < Fog::Vcloud::Model
+
+          identity :href
+
+          ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd
+
+          attribute :name
+          attribute :type
+          attribute :description, :aliases => :Description
+          attribute :other_links, :aliases => :Link
+          attribute :compute_capacity, :aliases => :ComputeCapacity
+          attribute :storage_capacity, :aliases => :StorageCapacity
+          attribute :available_networks, :aliases => :AvailableNetworks, :squash => :Network
+          attribute :resource_entities, :aliases => :ResourceEntities, :squash => :ResourceEntity
+          attribute :deployed_vm_quota
+          attribute :instantiated_vm_quota
+
+          def public_ips
+            @public_ips ||= collection_based_on_type("application/vnd.tmrk.ecloud.publicIpsList+xml")
+          end
+
+          def internet_services
+            @internet_services ||= collection_based_on_type("application/vnd.tmrk.ecloud.internetServicesList+xml")
+          end
+
+          def networks
+            @networks ||= Fog::Vcloud::Terremark::Ecloud::Networks.
+              new( :connection => connection,
+                   :href => href )
+          end
+
+          def servers
+            @servers ||= Fog::Vcloud::Terremark::Ecloud::Servers.
+              new( :connection => connection,
+                   :href => href )
+          end
+
+          def tasks
+            @tasks ||= Fog::Vcloud::Terremark::Ecloud::Tasks.
+              new( :connection => connection,
+                   :href => href + "/tasksList" )
+          end
+
+          def catalog
+            @catalog ||= collection_based_on_type("application/vnd.vmware.vcloud.catalog+xml")
+          end
+
+          def firewall_acls
+            @firewall_acls ||= collection_based_on_type("application/vnd.tmrk.ecloud.firewallAclsList+xml")
+          end
+
+          private
+
+          def collection_based_on_type(type)
+            load_unless_loaded!
+            if link = other_links.detect { |link| link[:type] == type }
+              case type
+              when "application/vnd.tmrk.ecloud.publicIpsList+xml"
+                Fog::Vcloud::Terremark::Ecloud::PublicIps
+              when "application/vnd.tmrk.ecloud.internetServicesList+xml"
+                Fog::Vcloud::Terremark::Ecloud::InternetServices
+              when "application/vnd.vmware.vcloud.catalog+xml"
+                Fog::Vcloud::Terremark::Ecloud::Catalog
+              when "application/vnd.tmrk.ecloud.firewallAclsList+xml"
+                Fog::Vcloud::Terremark::Ecloud::FirewallAcls
+              end.new( :connection => connection, :href => link[:href] )
+            else
+              [ ]
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/vdcs.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/vdcs.rb
new file mode 100644
index 0000000..2315ca6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/models/vdcs.rb
@@ -0,0 +1,40 @@
+require 'lib/fog/vcloud/terremark/ecloud/models/vdc'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Vdcs < Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Vdc
+
+          def all
+            data = connection.get_organization(organization_uri).body[:Link].select { |link| link[:type] == "application/vnd.vmware.vcloud.vdc+xml" }
+            data.each { |link| link.delete_if { |key, value| [:rel].include?(key) } }
+            load(data)
+          end
+
+          def get(uri)
+            if data = connection.get_vdc(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+          def organization_uri
+            @organizatio_uri ||= connection.default_organization_uri
+          end
+
+          private
+
+          def organization_uri=(new_organization_uri)
+            @organization_uri = new_organization_uri
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb
new file mode 100644
index 0000000..7cd5f4c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb
@@ -0,0 +1,140 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def generate_internet_service_request(service_data)
+            builder = Builder::XmlMarkup.new
+            builder.CreateInternetServiceRequest(:"xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance",
+                                                 :"xmlns:xsd" => "http://www.w3.org/2001/XMLSchema",
+                                                 :xmlns => "urn:tmrk:eCloudExtensions-2.3") {
+              builder.Name(service_data[:name])
+              builder.Protocol(service_data[:protocol])
+              builder.Port(service_data[:port])
+              builder.Enabled(service_data[:enabled])
+              builder.Description(service_data[:description])
+              builder.RedirectURL(service_data[:redirect_url])
+              if monitor = service_data[:monitor]
+                generate_monitor_section(builder,monitor)
+              end
+            }
+          end
+
+          def generate_monitor_section(builder, monitor)
+            builder.Monitor {
+              builder.MonitorType(monitor[:type])
+              builder.UrlSendString(monitor[:url_send_string])
+              builder.HttpHeader(monitor[:http_headers].join("\n"))
+              builder.ReceiveString(monitor[:receive_string])
+              builder.Interval(monitor[:interval])
+              builder.ResponseTimeOut(monitor[:response_timeout])
+              builder.DownTime(monitor[:downtime])
+              builder.Retries(monitor[:retries])
+              builder.IsEnabled(monitor[:is_enabled])
+            }
+          end
+
+          def validate_internet_service_data(service_data, configure=false)
+            required_opts = [:name, :protocol, :port, :description, :enabled]
+            if configure
+              required_opts + [ :id, :href, :timeout ]
+            end
+            unless required_opts.all? { |opt| service_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Internet Service data missing: #{(required_opts - service_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def validate_internet_service_monitor(monitor)
+            #FIXME: Refactor this type of function into something generic
+            required_opts = [:type, :url_send_string, :http_headers, :receive_string, :is_enabled]
+
+            unless required_opts.all? { |opt| monitor.keys.include?(opt) && monitor[opt] }
+              raise ArgumentError.new("Required Monitor data missing: #{(required_opts - monitor.keys).map(&:inspect).join(", ")}")
+            end
+
+            unless ['HTTP','ECV'].include?(monitor[:type])
+              raise ArgumentError.new("Supported monitor types are: ECV & HTTP")
+            end
+
+            unless monitor[:http_headers].is_a?(Array) || monitor[:http_headers].is_a?(String)
+              raise ArgumentError.new("Monitor :http_headers must be a String or Array")
+            end
+
+            unless [true, false, "true", "false"].include?(monitor[:is_enabled])
+              raise ArgumentError.new("Monitor :is_enabled must be true or false")
+            end
+          end
+
+          def ensure_monitor_defaults!(monitor)
+            if monitor[:http_headers].is_a?(String)
+              monitor[:http_headers] = [ monitor[:http_headers] ]
+            end
+
+            unless monitor[:retries]
+              monitor[:retries] = 3
+            end
+
+            unless monitor[:response_timeout]
+              monitor[:response_timeout] = 2
+            end
+
+            unless monitor[:down_time]
+              monitor[:down_time] = 30
+            end
+
+            unless monitor[:interval]
+              monitor[:interval] = 5
+            end
+          end
+
+          def add_internet_service(internet_services_uri, service_data)
+            validate_internet_service_data(service_data)
+            if monitor = service_data[:monitor]
+              validate_internet_service_monitor(monitor)
+              ensure_monitor_defaults!(monitor)
+            end
+
+            request(
+              :body     => generate_internet_service_request(service_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'},
+              :method   => 'POST',
+              :uri      => internet_services_uri,
+              :parse    => true
+            )
+          end
+
+        end
+
+        class Mock
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=561&Lang=1&SID=
+          #
+
+          def add_internet_service(internet_services_uri, service_data)
+            validate_internet_service_data(service_data)
+
+            internet_services_uri = ensure_unparsed(internet_services_uri)
+
+            if ip = ip_from_uri(internet_services_uri)
+              id = rand(1000)
+              new_service = service_data.merge!( { :href => Fog::Vcloud::Terremark::Ecloud::Mock.internet_service_href( { :id => id } ),
+                                                   :id => id.to_s,
+                                                   :timeout => 2,
+                                                   :nodes => [] } )
+              ip[:services] << new_service
+              xml = generate_internet_service_response( service_data, ip )
+
+              mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/add_node.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/add_node.rb
new file mode 100644
index 0000000..cce2e8a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/add_node.rb
@@ -0,0 +1,65 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def add_node(nodes_uri, node_data)
+            validate_node_data(node_data)
+
+            request(
+              :body     => generate_node_request(node_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml'},
+              :method   => 'POST',
+              :uri      => nodes_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_node_request(node_data)
+            builder = Builder::XmlMarkup.new
+            builder.CreateNodeServiceRequest(:"xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance",
+                                             :"xmlns:xsd" => "http://www.w3.org/2001/XMLSchema",
+                                             :xmlns => "urn:tmrk:eCloudExtensions-2.3") {
+              builder.IpAddress(node_data[:ip_address])
+              builder.Name(node_data[:name])
+              builder.Port(node_data[:port])
+              builder.Enabled(node_data[:enabled])
+              builder.Description(node_data[:description])
+            }
+          end
+
+          def validate_node_data(node_data, configure=false)
+            valid_opts = [:name, :port, :enabled, :description, :ip_address]
+            if configure
+              valid_opts.delete_if { |opt| ![:name, :enabled, :description].include?(opt) }
+            end
+            unless valid_opts.all? { |opt| node_data.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - node_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Mock
+
+          def add_node(nodes_uri, node_data)
+            validate_node_data(node_data)
+            nodes_uri = ensure_unparsed(nodes_uri)
+            service_uri = nodes_uri.gsub('/nodeServices','')
+            ip, service = mock_ip_and_service_from_service_url(service_uri)
+            if ip and service
+              id = rand(1000)
+              service[:nodes] << node_data.merge!( :id => id.to_s, :href => Fog::Vcloud::Terremark::Ecloud::Mock.extension_url + "/nodeService/#{id}" )
+              mock_it 200, mock_node_service_response(node_data, ecloud_xmlns), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb
new file mode 100644
index 0000000..a5e6583
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb
@@ -0,0 +1,50 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+
+          def validate_clone_vapp_options(options)
+            valid_opts = [:name, :poweron]
+            unless valid_opts.all? { |opt| options.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - options.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def generate_clone_vapp_request(uri, options)
+            xml = Builder::XmlMarkup.new
+            xml.CloneVAppParams(xmlns.merge!(:name => options[:name], :deploy => "true", :powerOn => options[:poweron])) {
+              xml.VApp( :href => uri, :type => "application/vnd.vmware.vcloud.vApp+xml",
+                        :xmlns => "http://www.vmware.com/vcloud/v0.8")
+            }
+          end
+
+          def clone_vapp(vdc_uri, vapp_uri, options = {})
+            unless options.has_key?(:poweron)
+              options[:poweron] = "false"
+            end
+
+            validate_clone_vapp_options(options)
+
+            request(
+              :body     => generate_clone_vapp_request(vapp_uri, options),
+              :expects  => 202,
+              :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.cloneVAppParams+xml'},
+              :method   => 'POST',
+              :uri      => vdc_uri + '/action/clonevapp',
+              :parse    => true
+            )
+          end
+        end
+
+        class Mock
+          def clone_vapp(vdc_uri, vapp_uri, customization_data)
+            validate_customization_data(customization_data)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb
new file mode 100644
index 0000000..66ba358
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb
@@ -0,0 +1,93 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def generate_internet_service_response(service_data,ip_address_data)
+            builder = Builder::XmlMarkup.new
+            builder.InternetService(:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance",
+                                    :xmlns => "urn:tmrk:eCloudExtensions-2.3") {
+              builder.Id(service_data[:id])
+              builder.Href(service_data[:href].to_s)
+              builder.Name(service_data[:name])
+              builder.Protocol(service_data[:protocol])
+              builder.Port(service_data[:port])
+              builder.Enabled(service_data[:enabled])
+              builder.Description(service_data[:description])
+              builder.Timeout(service_data[:timeout])
+              builder.RedirectURL(service_data[:redirect_url])
+              builder.PublicIpAddress {
+                builder.Id(ip_address_data[:id])
+                builder.Href(ip_address_data[:href].to_s)
+                builder.Name(ip_address_data[:name])
+              }
+              if monitor = service_data[:monitor]
+                generate_monitor_section(builder,monitor)
+              end
+            }
+          end
+
+          def validate_public_ip_address_data(ip_address_data)
+            valid_opts = [:name, :href, :id]
+            unless valid_opts.all? { |opt| ip_address_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Internet Service data missing: #{(valid_opts - ip_address_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def configure_internet_service(internet_service_uri, service_data, ip_address_data)
+            validate_internet_service_data(service_data, true)
+
+            validate_public_ip_address_data(ip_address_data)
+
+            if monitor = service_data[:monitor]
+              validate_internet_service_monitor(monitor)
+              ensure_monitor_defaults!(monitor)
+            end
+
+            request(
+              :body     => generate_internet_service_response(service_data, ip_address_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'},
+              :method   => 'PUT',
+              :uri      => internet_service_uri,
+              :parse    => true
+            )
+          end
+
+        end
+
+        class Mock
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=583&Lang=1&SID=
+          #
+
+          def configure_internet_service(internet_service_uri, service_data, ip_address_data)
+            validate_internet_service_data(service_data, true)
+
+            validate_public_ip_address_data(ip_address_data)
+
+            internet_service_uri = ensure_unparsed(internet_service_uri)
+
+            xml = nil
+
+            if ip = ip_from_uri(ip_address_data[:href])
+              if service = ip[:services].detect { |service| service[:id] == internet_service_uri.split('/')[-1] }
+                ip[:services][ip[:services].index(service)] = service_data
+                xml = generate_internet_service_response(service_data, ip)
+              end
+            end
+
+            if xml
+              mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb
new file mode 100644
index 0000000..bdbe8bc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb
@@ -0,0 +1,54 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def validate_network_data(network_data, configure=false)
+            valid_opts = [:id, :href, :name, :rnat, :address, :broadcast, :gateway]
+            unless valid_opts.all? { |opt| network_data.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - network_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def configure_network(network_uri, network_data)
+            validate_network_data(network_data)
+
+            request(
+              :body     => generate_configure_network_request(network_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.networkService+xml'},
+              :method   => 'PUT',
+              :uri      => network_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_configure_network_request(network_data)
+            builder = Builder::XmlMarkup.new
+            builder.Network(:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance",
+                            :xmlns => "urn:tmrk:eCloudExtensions-2.3") {
+              builder.Id(network_data[:id])
+              builder.Href(network_data[:href])
+              builder.Name(network_data[:name])
+              builder.RnatAddress(network_data[:rnat])
+              builder.Address(network_data[:address])
+              builder.BroadcastAddress(network_data[:broadcast])
+              builder.GatewayAddress(network_data[:gateway])
+            }
+          end
+
+        end
+
+        class Mock
+
+          def configure_network(network_uri, network_data)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb
new file mode 100644
index 0000000..97d6a93
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb
@@ -0,0 +1,53 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def validate_network_ip_data(network_ip_data, configure=false)
+            valid_opts = [:id, :href, :name, :status, :server, :rnat]
+            unless valid_opts.all? { |opt| network_ip_data.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - network_ip_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def configure_network_ip(network_ip_uri, network_ip_data)
+            validate_network_ip_data(network_ip_data)
+
+            request(
+              :body     => generate_configure_network_ip_request(network_ip_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' },
+              :method   => 'PUT',
+              :uri      => network_ip_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_configure_network_ip_request(network_ip_data)
+            builder = Builder::XmlMarkup.new
+            builder.IpAddress(:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance",
+                              :xmlns => "urn:tmrk:eCloudExtensions-2.3") {
+              builder.Id(network_ip_data[:id])
+              builder.Href(network_ip_data[:href])
+              builder.Name(network_ip_data[:name])
+              builder.Status(network_ip_data[:status])
+              builder.Server(network_ip_data[:server])
+              builder.RnatAddress(network_ip_data[:rnat])
+            }
+          end
+
+        end
+
+        class Mock
+
+          def configure_network_ip(network_ip_uri, network_ip_data)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb
new file mode 100644
index 0000000..7acec9e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb
@@ -0,0 +1,54 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def configure_node(node_uri, node_data)
+            validate_node_data(node_data, true)
+
+            request(
+              :body     => generate_configure_node_request(node_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml'},
+              :method   => 'PUT',
+              :uri      => node_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_configure_node_request(node_data)
+            builder = Builder::XmlMarkup.new
+            builder.NodeService(:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance",
+                                    :xmlns => "urn:tmrk:eCloudExtensions-2.0") {
+              builder.Name(node_data[:name])
+              builder.Enabled(node_data[:enabled].to_s)
+              builder.Description(node_data[:description])
+            }
+          end
+
+        end
+
+        class Mock
+
+          def configure_node(node_uri, node_data)
+            node_uri = ensure_unparsed(node_uri)
+
+            validate_node_data(node_data, true)
+
+            if node = mock_node_from_url(node_uri)
+              node[:name] = node_data[:name]
+              node[:enabled] = node_data[:enabled]
+              node[:description] = node_data[:description]
+              mock_it 200, mock_node_service_response(node, ecloud_xmlns), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb
new file mode 100644
index 0000000..237d030
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb
@@ -0,0 +1,116 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def generate_configure_vapp_request(vapp_uri, vapp_data)
+            rasd_xmlns = { "xmlns" => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData" }
+
+            xml = Nokogiri::XML(request( :uri => vapp_uri).body)
+            xml.root['name'] = vapp_data[:name]
+
+            #cpu
+            xml.at("//xmlns:ResourceType[.='3']/..", rasd_xmlns).at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:cpus]
+
+            #memory
+            xml.at("//xmlns:ResourceType[.='4']/..", rasd_xmlns).at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:memory]
+
+            #disks
+            real_disks = xml.xpath("//xmlns:ResourceType[ .='17']/..", rasd_xmlns)
+            real_disk_numbers = real_disks.map { |disk| disk.at('.//xmlns:AddressOnParent', rasd_xmlns).content }
+            disk_numbers = vapp_data[:disks].map { |vdisk| vdisk[:number].to_s }
+
+            if vapp_data[:disks].length < real_disks.length
+              #Assume we're removing a disk
+              remove_disk_numbers = real_disk_numbers - disk_numbers
+              remove_disk_numbers.each do |number|
+                if result = xml.at("//xmlns:ResourceType[ .='17']/../xmlns:AddressOnParent[.='#{number}']/..", rasd_xmlns)
+                  result.remove
+                end
+              end
+            elsif vapp_data[:disks].length > real_disks.length
+              add_disk_numbers = disk_numbers - real_disk_numbers
+
+              add_disk_numbers.each do |number|
+                new_disk = real_disks.first.dup
+                new_disk.at('.//xmlns:AddressOnParent', rasd_xmlns).content = -1
+                new_disk.at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:disks].detect { |disk| disk[:number].to_s == number.to_s }[:size]
+                real_disks.first.parent << new_disk
+              end
+            end
+
+            #puts xml.root.to_s
+            xml.root.to_s
+            
+            #builder = Builder::XmlMarkup.new
+            #builder.Vapp(:href => vapp_uri.to_s,
+            #             :type => 'application/vnd.vmware.vcloud.vApp+xml',
+            #             :name => vapp_data[:name],
+            #             :status => 2,
+            #             :size => 0,
+            #             :xmlns => 'http://www.vmware.com/vcloud/v0.8',
+            #             :"xmlns:xsi" => 'http://www.w3.org/2001/XMLSchema-instance',
+            #             :"xmlns:xsd" => 'http://www.w3.org/2001/XMLSchema') {
+            #  #builder.VirtualHardwareSection(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #  builder.Section(:"xsi:type" => "q2:VirtualHardwareSection_Type", :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"xmlns:q2" => "http://www.vmware.com/vcloud/v0.8") {
+            #    builder.Info('Virtual Hardware')
+            #    builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #    #builder.Item {
+            #      builder.InstanceID(1, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.ResourceType(3, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.VirtualQuantity(vapp_data[:cpus], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #    }
+            #    builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #    #builder.Item {
+            #      builder.InstanceID(2, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.ResourceType(4, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.VirtualQuantity(vapp_data[:memory], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #    }
+            #    vapp_data[:disks].each do |disk_data|
+            #      #builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #      builder.Item {
+            #        builder.AddressOnParent(disk_data[:number], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.HostResource(disk_data[:resource], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.InstanceID(9, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.ResourceType(17, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.VirtualQuantity(disk_data[:size], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      }
+            #    end
+            #
+            #  }
+            #}
+          end
+
+          def validate_vapp_data(vapp_data)
+            valid_opts = [:name, :cpus, :memory, :disks]
+            unless valid_opts.all? { |opt| vapp_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Vapp data missing: #{(valid_opts - vapp_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def configure_vapp(vapp_uri, vapp_data)
+            validate_vapp_data(vapp_data)
+
+            request(
+              :body     => generate_configure_vapp_request(vapp_uri, vapp_data),
+              :expects  => 202,
+              :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.vApp+xml' },
+              :method   => 'PUT',
+              :uri      => vapp_uri,
+              :parse    => true
+            )
+          end
+
+        end
+
+        class Mock
+          def configure_vapp(vapp_uri, vapp_data)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb
new file mode 100644
index 0000000..43bd9aa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb
@@ -0,0 +1,33 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :delete_internet_service, 200, 'DELETE', {}, ""
+        end
+
+        class Mock
+
+          def delete_internet_service(service_uri)
+
+            deleted = false
+            if ip = mock_ip_from_service_url(service_uri)
+              if service = ip[:services].detect { |service| service[:href] == service_uri }
+                ip[:services].delete(service)
+                deleted = true
+              end
+            end
+
+            if deleted
+              mock_it 200, '', { }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb
new file mode 100644
index 0000000..8edfbba
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb
@@ -0,0 +1,28 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :delete_node, 200, 'DELETE', {}, ""
+        end
+
+        class Mock
+
+          def delete_node(node_uri)
+            node_uri = ensure_unparsed(node_uri)
+
+            node = mock_node_from_url(node_uri)
+            service = mock_service_from_node_url(node_uri)
+            if node and service
+              service[:nodes].delete(node)
+              mock_it 200, '', {}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb
new file mode 100644
index 0000000..287abd9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb
@@ -0,0 +1,19 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :delete_vapp, 202, "DELETE"
+        end
+
+        class Mock
+          def delete_vapp(vapp_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb
new file mode 100644
index 0000000..88f5181
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_catalog
+        end
+
+        class Mock
+          def get_catalog(catalog_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb
new file mode 100644
index 0000000..99c6a71
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_catalog_item
+        end
+
+        class Mock
+          def get_catalog(catalog_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb
new file mode 100644
index 0000000..20dcfa4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_customization_options
+        end
+
+        class Mock
+          def get_customization_options( options_uri )
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb
new file mode 100644
index 0000000..fa48874
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_firewall_acl
+        end
+
+        class Mock
+          def get_firewall_acl(firewall_acl_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb
new file mode 100644
index 0000000..0683f1a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_firewall_acls
+        end
+
+        class Mock
+          def get_firewall_acls(firewall_acls_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb
new file mode 100644
index 0000000..356ddc3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb
@@ -0,0 +1,66 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_internet_services
+        end
+
+        class Mock
+
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=580&Lang=1&SID=
+          #http://support.theenterprisecloud.com/kb/default.asp?id=560&Lang=1&SID=
+          #
+          #
+          def self.internet_services_for_ip(xml,ip)
+            ip[:services].each do |service|
+              xml.InternetService {
+                xml.Id(service[:id])
+                xml.Href(Fog::Vcloud::Terremark::Ecloud::Mock.internet_service_href(service))
+                xml.Name(service[:name])
+                xml.PublicIpAddress {
+                  xml.Id(ip[:id])
+                  xml.Href(Fog::Vcloud::Terremark::Ecloud::Mock.public_ip_href(ip))
+                  xml.Name(ip[:name])
+                }
+                xml.Port(service[:port])
+                xml.Protocol(service[:protocol])
+                xml.Enabled(service[:enabled])
+                xml.Timeout(service[:timeout])
+                xml.Description(service[:description])
+                xml.RedirectURL(service[:redirect_url])
+                xml.Monitor
+              }
+            end
+          end
+
+          def get_internet_services(internet_services_uri)
+            internet_services_uri = ensure_unparsed(internet_services_uri)
+            xml = nil
+            builder = Builder::XmlMarkup.new
+            if vdc = vdc_from_uri(internet_services_uri)
+              xml = builder.InternetServices( :xmlns => "urn:tmrk:eCloudExtensions-2.3",:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance" ) { |xml|
+                vdc[:public_ips].each do |ip|
+                  Fog::Vcloud::Terremark::Ecloud::Mock.internet_services_for_ip(xml,ip)
+                end
+              }
+            elsif ip = ip_from_uri(internet_services_uri)
+              xml = builder.InternetServices( :xmlns => "urn:tmrk:eCloudExtensions-2.3",:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance" ) { |xml|
+                Fog::Vcloud::Terremark::Ecloud::Mock.internet_services_for_ip(xml,ip)
+              }
+            end
+            if xml
+              mock_it 200,
+                xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.internetServicesList+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network.rb
new file mode 100644
index 0000000..aafc114
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network.rb
@@ -0,0 +1,48 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          # Handled by the main Vcloud get_network
+        end
+
+        class Mock
+
+          def get_network(network_uri)
+            #
+            # Based off of:
+            # http://support.theenterprisecloud.com/kb/default.asp?id=546&Lang=1&SID=
+            #
+            network_uri = ensure_unparsed(network_uri)
+            type = "application/vnd.vmware.vcloud.network+xml"
+            response = Excon::Response.new
+            if network = mock_data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:href] == network_uri }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.Network(xmlns.merge(:href => network[:href], :name => network[:name], :type => type)) {
+                  xml.Link( :rel => "down", :href => network[:href] + "/ips", :type => "application/xml", :name => "IP Addresses" )
+                  xml.Link( :rel => "down", :href => network[:extension_href], :type => "application/xml", :name => network[:name] )
+                  xml.Configuration {
+                    xml.Gateway(network[:gateway])
+                    xml.Netmask(network[:netmask])
+                  }
+                  if network[:features]
+                    xml.Features {
+                      network[:features].each do |feature|
+                        eval "xml.#{feature[:type].to_sym}('#{feature[:value]}')"
+                      end
+                    }
+                  end
+                },
+                { 'Content-Type' => type }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb
new file mode 100644
index 0000000..4fe071f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb
@@ -0,0 +1,36 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_network_extensions
+        end
+
+        class Mock
+
+          def get_network_extensions(network_uri)
+            network_uri = ensure_unparsed(network_uri)
+            type = "application/vnd.vmware.vcloud.network+xml"
+            response = Excon::Response.new
+            if network = mock_data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:extension_href] == network_uri }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.Network(:xmlns => "urn:tmrk:eCloudExtensions-2.3", :"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {
+                  xml.Address(network[:name].split("/")[0])
+                  xml.RnatAddress(network[:rnat])
+                  xml.Href(network[:extension_href])
+                  xml.Id(network[:id])
+                  xml.Name(network[:name])
+                  xml.GatewayAddress(network[:gateway])
+                  xml.BroadcastAddress(IPAddr.new(network[:subnet]).to_range.last.to_s)
+                }, { 'Content-Type' => type }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb
new file mode 100644
index 0000000..0ec4a8c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb
@@ -0,0 +1,44 @@
+#
+# AFAICT this is basically undocumented ATM - 6/18/2010 - freeformz
+#
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_network_ip
+        end
+
+        class Mock
+
+          def get_network_ip(ip_uri)
+            response = Excon::Response.new
+            ip_id = ip_uri.split("/").last
+            if network = mock_data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| IPAddr.new(network[:subnet]).to_range.map { |ip| ip.to_s.gsub('.','') }.include?(ip_id) }
+              ip = IPAddr.new(network[:subnet]).to_range.detect { |ip| ip.to_s.gsub('.','') == ip_id }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.IpAddress(ecloud_xmlns) {
+                  xml.Id( ip_id )
+                  xml.Href( ip_uri.to_s )
+                  xml.Name( ip.to_s )
+                  if network[:ips].has_key?(ip.to_s)
+                    xml.Status( "Assigned" )
+                    xml.Server( network[:ips][ip.to_s] )
+                  else
+                    xml.Status( "Available" )
+                  end
+                },
+                { 'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb
new file mode 100644
index 0000000..80ca1be
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb
@@ -0,0 +1,50 @@
+#
+# AFAICT - This is basically undocumented - 6/18/2010 - freeformz
+#
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_network_ips
+        end
+
+        class Mock
+          require 'ipaddr'
+
+          def get_network_ips(network_ips_uri)
+            network_ips_uri = ensure_unparsed(network_ips_uri)
+            response = Excon::Response.new
+            if network = mock_data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:href] == network_ips_uri.gsub(%r:/ips$:,'') }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.IpAddresses {
+                  IPAddr.new(network[:name]).to_range.to_a[3..-2].each do |ip|
+                    xml.IpAddress {
+                      xml.Name(ip.to_s)
+                      xml.Href("#{Fog::Vcloud::Terremark::Ecloud::Mock.extension_url}/ip/#{ip.to_s.gsub('.','')}")
+                      if network[:ips].has_key?(ip.to_s)
+                        xml.Status("Assigned")
+                        xml.Server(network[:ips][ip.to_s])
+                      else
+                        xml.Status("Available")
+                      end
+                      xml.RnatAddress(network[:rnat])
+                    }
+                  end
+                },
+                { 'Content-Type' => 'application/vnd.tmrk.ecloud.ipAddressesList+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+            
+
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_node.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_node.rb
new file mode 100644
index 0000000..cab794d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_node.rb
@@ -0,0 +1,45 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_node
+        end
+
+        class Mock
+
+          #
+          # Based on http://support.theenterprisecloud.com/kb/default.asp?id=641&Lang=1&SID=
+          #
+          #
+          #
+          def mock_node_service_response(node, xmlns)
+            xml = Builder::XmlMarkup.new
+            xml.NodeService(xmlns) {
+              xml.Id(node[:id])
+              xml.Href(node[:href])
+              xml.Name(node[:name])
+              xml.IpAddress(node[:ip_address])
+              xml.Port(node[:port])
+              xml.Enabled(node[:enabled])
+              xml.Description(node[:description])
+            }
+          end
+
+          def get_node(node_uri)
+
+            node_uri = ensure_unparsed(node_uri)
+
+            if node = mock_node_from_url(node_uri)
+              xml = Builder::XmlMarkup.new
+              mock_it 200, mock_node_service_response(node, ecloud_xmlns), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb
new file mode 100644
index 0000000..00feb4a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb
@@ -0,0 +1,44 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_nodes
+        end
+
+        class Mock
+
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=637&Lang=1&SID=
+          #
+          def get_nodes(nodes_uri)
+            nodes_uri = ensure_unparsed(nodes_uri)
+            service_uri = nodes_uri.gsub('/nodeServices','')
+            ip, service = mock_ip_and_service_from_service_url(service_uri)
+            if ip and service
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.NodeServices(ecloud_xmlns) {
+                  service[:nodes].each do |node|
+                    xml.NodeService {
+                      xml.Id(node[:id])
+                      xml.Href(node[:href])
+                      xml.Name(node[:name])
+                      xml.IpAddress(node[:ip_address])
+                      xml.Port(node[:port])
+                      xml.Enabled(node[:enabled])
+                      xml.Description(node[:description])
+                    }
+                  end
+                }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb
new file mode 100644
index 0000000..3e51d9e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb
@@ -0,0 +1,35 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_public_ip
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=567&Lang=1&SID=
+          #
+
+          def get_public_ip(public_ip_uri)
+            public_ip_uri = ensure_unparsed(public_ip_uri)
+            if ip = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.map { |vdc| vdc[:public_ips] }.flatten.detect { |ip| ip[:href] == public_ip_uri }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.PublicIp(:xmlns => "urn:tmrk:eCloudExtensions-2.0", :"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {
+                  xml.Id(ip[:id])
+                  xml.Href(ip[:href])
+                  xml.Name(ip[:name])
+                }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.publicIp+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb
new file mode 100644
index 0000000..2a0faa7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb
@@ -0,0 +1,40 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_public_ips
+        end
+
+        class Mock
+
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=577&Lang=1&SID=
+          #
+          def get_public_ips(public_ips_uri)
+            public_ips_uri = ensure_unparsed(public_ips_uri)
+            if vdc = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:href].split('/').last == public_ips_uri.split('/')[-2] }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.PublicIPAddresses {
+                  vdc[:public_ips].each do |ip|
+                    xml.PublicIPAddress {
+                      xml.Id(ip[:id])
+                      xml.Href(ip[:href])
+                      xml.Name(ip[:name])
+                    }
+                  end
+                }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.publicIpsList+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_task.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_task.rb
new file mode 100644
index 0000000..786892b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_task.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_task
+        end
+
+        class Mock
+          def get_task(task__uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb
new file mode 100644
index 0000000..a266a5e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb
@@ -0,0 +1,19 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_task_list
+        end
+
+        class Mock
+          def get_task_list(task_list_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb
new file mode 100644
index 0000000..15e014e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_vapp
+        end
+
+        class Mock
+          def get_vapp(vapp_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb
new file mode 100644
index 0000000..cfbb13e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_vapp_template
+        end
+
+        class Mock
+          def get_vapp_template(templace_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb
new file mode 100644
index 0000000..2379a13
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb
@@ -0,0 +1,86 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          # Handled by the main Vcloud get_vdc
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=545&Lang=1&SID=
+
+          def get_vdc(vdc_uri)
+            vdc_uri = ensure_unparsed(vdc_uri)
+            if vdc = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:href] == vdc_uri }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.Vdc(xmlns.merge(:href => vdc[:href], :name => vdc[:name])) {
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/catalog",
+                           :type => "application/vnd.vmware.vcloud.catalog+xml",
+                           :name => vdc[:name])
+                  xml.Link(:rel => "down",
+                           :href => vdc[:extension_href] + "/publicIps",
+                           :type => "application/vnd.tmrk.ecloud.publicIpsList+xml",
+                           :name => "Public IPs")
+                  xml.Link(:rel => "down",
+                           :href => vdc[:extension_href] + "/internetServices",
+                           :type => "application/vnd.tmrk.ecloud.internetServicesList+xml",
+                           :name => "Internet Services")
+                  xml.Link(:rel => "down",
+                           :href => vdc[:extension_href] + "/firewallAcls",
+                           :type => "application/vnd.tmrk.ecloud.firewallAclsList+xml",
+                           :name => "Firewall Access List")
+                  xml.Description("")
+                  xml.StorageCapacity {
+                    xml.Units("bytes * 10^9")
+                    xml.Allocated(vdc[:storage][:allocated])
+                    xml.Used(vdc[:storage][:used])
+                  }
+                  xml.ComputeCapacity {
+                    xml.Cpu {
+                      xml.Units("hz * 10^6")
+                      xml.Allocated(vdc[:cpu][:allocated])
+                    }
+                    xml.Memory {
+                      xml.Units("bytes * 2^20")
+                      xml.Allocated(vdc[:memory][:allocated])
+                    }
+                    xml.DeployedVmsQuota {
+                      xml.Limit("-1")
+                      xml.Used("-1")
+                    }
+                    xml.InstantiatedVmsQuota {
+                      xml.Limit("-1")
+                      xml.Used("-1")
+                    }
+                  }
+                  xml.ResourceEntities {
+                    vdc[:vms].each do |vm|
+                      xml.ResourceEntity(:href => vm[:href],
+                                         :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                         :name => vm[:name])
+                    end
+                  }
+                  xml.AvailableNetworks {
+                    vdc[:networks].each do |network|
+                      xml.Network(:href => network[:href],
+                                  :type => "application/vnd.vmware.vcloud.network+xml",
+                                  :name => network[:name])
+                    end
+                  }
+                }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb
new file mode 100644
index 0000000..25f8b80
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb
@@ -0,0 +1,100 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+
+          def validate_instantiate_vapp_template_options(catalog_item_uri, options)
+            valid_opts = [:name, :vdc_uri, :network_uri, :cpus, :memory, :row, :group]
+            unless valid_opts.all? { |opt| options.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - options.keys).map(&:inspect).join(", ")}")
+            end
+
+            # Figure out the template_uri
+            catalog_item = get_catalog_item( catalog_item_uri ).body
+            catalog_item[:Entity] = [ catalog_item[:Entity] ] if catalog_item[:Entity].is_a?(Hash)
+            catalog_item[:Link] = [ catalog_item[:Link] ] if catalog_item[:Link].is_a?(Hash)
+
+            options[:template_uri] = begin
+               catalog_item[:Entity].detect { |entity| entity[:type] == "application/vnd.vmware.vcloud.vAppTemplate+xml" }[:href]
+            rescue
+              raise RuntimeError.new("Unable to locate template uri for #{catalog_item_uri}")
+            end
+
+            customization_options = begin
+                customization_href = catalog_item[:Link].detect { |link| link[:type] == "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml" }[:href]
+                get_customization_options( customization_href ).body
+            rescue
+              raise RuntimeError.new("Unable to get customization options for #{catalog_item_uri}")
+            end
+
+            # Check to see if we can set the password
+            if options[:password] and customization_options[:CustomizePassword] == "false"
+              raise ArgumentError.new("This catalog item (#{catalog_item_uri}) does not allow setting a password.")
+            end
+
+            # According to the docs if CustomizePassword is "true" then we NEED to set a password
+            if customization_options[:CustomizePassword] == "true" and ( options[:password].nil? or options[:password].empty? )
+              raise ArgumentError.new("This catalog item (#{catalog_item_uri}) requires a :password to instantiate.")
+            end
+          end
+
+          def generate_instantiate_vapp_template_request(options)
+            xml = Builder::XmlMarkup.new
+            xml.InstantiateVAppTemplateParams(xmlns.merge!(:name => options[:name], :"xml:lang" => "en")) {
+              xml.VAppTemplate(:href => options[:template_uri])
+              xml.InstantiationParams {
+                xml.ProductSection( :"xmlns:q1" => "http://www.vmware.com/vcloud/v0.8", :"xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1") {
+                  if options[:password]
+                    xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "password", :"ovf:value" => options[:password] )
+                  end
+                  xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "row", :"ovf:value" => options[:row] )
+                  xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "group", :"ovf:value" => options[:group] )
+                }
+                xml.VirtualHardwareSection( :"xmlns:q1" => "http://www.vmware.com/vcloud/v0.8" ) {
+                  # # of CPUS
+                  xml.Item( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1" ) {
+                    xml.InstanceID(1, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.ResourceType(3, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.VirtualQuantity(options[:cpus], :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  }
+                  # Memory
+                  xml.Item( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1" ) {
+                    xml.InstanceID(2, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.ResourceType(4, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.VirtualQuantity(options[:memory], :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  }
+                }
+                xml.NetworkConfigSection {
+                  xml.NetworkConfig {
+                    xml.NetworkAssociation( :href => options[:network_uri] )
+                  }
+                }
+              }
+            }
+          end
+
+          def instantiate_vapp_template(catalog_item_uri, options = {})
+            validate_instantiate_vapp_template_options(catalog_item_uri, options)
+
+            request(
+              :body     => generate_instantiate_vapp_template_request(options),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml'},
+              :method   => 'POST',
+              :uri      => options[:vdc_uri] + '/action/instantiatevAppTemplate',
+              :parse    => true
+            )
+          end
+        end
+
+        class Mock
+          def instantiate_vapp_template(vdc_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_off.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_off.rb
new file mode 100644
index 0000000..f115d76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_off.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_off, 202, 'POST'
+        end
+
+        class Mock
+          def power_off(off_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_on.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_on.rb
new file mode 100644
index 0000000..0def9d6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_on.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_on, 202, 'POST'
+        end
+
+        class Mock
+          def power_on(on_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb
new file mode 100644
index 0000000..f96ac57
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_reset, 202, 'POST'
+        end
+
+        class Mock
+          def power_reset(reset_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb
new file mode 100644
index 0000000..832d24f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_shutdown, 204, 'POST'
+        end
+
+        class Mock
+          def power_shutdown(shutdown_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/vcloud.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/vcloud.rb
new file mode 100644
index 0000000..ecf8320
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/vcloud.rb
@@ -0,0 +1,22 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Vcloud < Fog::Vcloud
+        request_path 'fog/vcloud/terremark/vcloud/requests'
+        request :get_vdc
+
+        class Real < Fog::Vcloud::Real
+
+          def supporting_versions
+            ["0.8", "0.8a-ext1.6"]
+          end
+
+        end
+
+        class Mock < Fog::Vcloud::Mock
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb
new file mode 100644
index 0000000..1fb76d8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog/lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb
@@ -0,0 +1,57 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Vcloud
+
+        class Real
+          # Handled by the main Vcloud get_vdc
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/09-get-vdc.aspx
+
+          def get_vdc(vdc_uri)
+            vdc_uri = ensure_unparsed(vdc_uri)
+            if vdc = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:href] == vdc_uri }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.Vdc(xmlns.merge(:href => vdc[:href], :name => vdc[:name])) {
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/catalog",
+                           :type => "application/vnd.vmware.vcloud.catalog+xml",
+                           :name => vdc[:name])
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/publicIps",
+                           :type => "application/xml",
+                           :name => "Public IPs")
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/internetServices",
+                           :type => "application/xml",
+                           :name => "Internet Services")
+                  xml.ResourceEntities {
+                    vdc[:vms].each do |vm|
+                      xml.ResourceEntity(:href => vm[:href],
+                                         :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                         :name => vm[:name])
+                    end
+                  }
+                  xml.AvailableNetworks {
+                    vdc[:networks].each do |network|
+                      xml.Network(:href => network[:href],
+                                  :type => "application/vnd.vmware.vcloud.network+xml",
+                                  :name => network[:name])
+                    end
+                  }
+                }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/README.rdoc b/lib/bbcloud/vendor/formatador-0.0.15/README.rdoc
new file mode 100644
index 0000000..f851a18
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/README.rdoc
@@ -0,0 +1,63 @@
+= formatador
+
+STDOUT text formatting
+
+== Quick and dirty
+
+You can call class methods to print out single lines like this:
+
+  Formatador.display_line('Hello World')
+
+You use tags, similar to html, to set formatting options:
+
+  Formatador.display_line('[green]Hello World[/]')
+
+  [/] resets everything to normal, colors are supported and [_color_] sets the background color.
+
+== Standard options
+
+* format - and adds color codes if STDOUT.tty? is true
+* display - calls format on the input and prints it
+* display_line - calls display, but adds on a newline (\n)
+* redisplay - Displays text, prepended with \r which will overwrite the last existing line
+
+== Extensions
+
+* display_table: takes an array of hashes. Each hash is a row, with the keys being the headers and values being the data. An optional second argument can specify which headers/columns to include and in what order they should appear.
+* redisplay_progressbar: takes the current and total values as its first two arguments and redisplays a progressbar (until current = total and then it display_lines). An optional third argument represents the start time and will add an elapsed time counter.
+
+== Indentation
+
+By initializing a formatador object you can keep track of indentation:
+
+  formatador = Formatador.new
+  formatador.display_line('one level of indentation')
+  formatador.indent {
+    formatador.display_line('two levels of indentation')
+  }
+  formatador.display_line('one level of indentation')
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2009 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/Rakefile b/lib/bbcloud/vendor/formatador-0.0.15/Rakefile
new file mode 100644
index 0000000..5f393c8
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/Rakefile
@@ -0,0 +1,147 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+require 'rake/testtask'
+Rake::TestTask.new(:test) do |test|
+  test.libs << 'lib' << 'test'
+  test.pattern = 'test/**/test_*.rb'
+  test.verbose = true
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/formatador.gemspec b/lib/bbcloud/vendor/formatador-0.0.15/formatador.gemspec
new file mode 100644
index 0000000..974cdd2
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/formatador.gemspec
@@ -0,0 +1,76 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'formatador'
+  s.version           = '0.0.15'
+  s.date              = '2010-07-19'
+  s.rubyforge_project = 'formatador'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "Ruby STDOUT text formatting"
+  s.description = "STDOUT text formatting"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    README.rdoc
+    Rakefile
+    formatador.gemspec
+    lib/formatador.rb
+    lib/formatador/progressbar.rb
+    lib/formatador/table.rb
+    tests/formatador_tests.rb
+    tests/tests_helper.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador.rb b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador.rb
new file mode 100644
index 0000000..f5a0b22
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador.rb
@@ -0,0 +1,125 @@
+require File.join(File.dirname(__FILE__), 'formatador', 'table')
+require File.join(File.dirname(__FILE__), 'formatador', 'progressbar')
+
+class Formatador
+
+  VERSION = '0.0.15'
+
+  STYLES = {
+    :"\/"             => "0",
+    :reset            => "0",
+    :bold             => "1",
+    :underline        => "4",
+    :blink_slow       => "5",
+    :blink_fast       => "6",
+    :negative         => "7", # invert color/color
+    :normal           => "22",
+    :underline_none   => "24",
+    :blink_off        => "25",
+    :positive         => "27", # revert color/color
+    :black            => "30",
+    :red              => "31",
+    :green            => "32",
+    :yellow           => "33",
+    :blue             => "34",
+    :magenta          => "35",
+    :purple           => "35",
+    :cyan             => "36",
+    :white            => "37",
+    :_black_          => "40",
+    :_red_            => "41",
+    :_green_          => "42",
+    :_yellow_         => "43",
+    :_blue_           => "44",
+    :_magenta_        => "45",
+    :_purple_         => "45",
+    :_cyan_           => "46",
+    :_white_          => "47",
+    :light_black      => "90",
+    :light_red        => "91",
+    :light_green      => "92",
+    :light_yellow     => "93",
+    :light_blue       => "94",
+    :light_magenta    => "95",
+    :light_purple     => "95",
+    :light_cyan       => "96",
+    :_light_black_    => "100",
+    :_light_red_      => "101",
+    :_light_green_    => "102",
+    :_light_yellow_   => "103",
+    :_light_blue_     => "104",
+    :_light_magenta_  => "105",
+    :_light_purple_   => "105",
+    :_light_cyan_     => "106",
+  }
+
+  PARSE_REGEX  = /\[(#{ STYLES.keys.join('|') })\]/ix
+  INDENT_REGEX = /\[indent\]/ix
+
+  def initialize
+    @indent = 1
+  end
+
+  def display(string = '')
+    print(parse("[indent]#{string}"))
+    STDOUT.flush
+    nil
+  end
+
+  def display_line(string = '')
+    display(string)
+    print("\n")
+    nil
+  end
+
+  def display_lines(lines = [])
+    for line in lines
+      display_line(line)
+    end
+    nil
+  end
+
+  def parse(string)
+    if STDOUT.tty?
+      string.gsub(PARSE_REGEX) { "\e[#{STYLES[$1.to_sym]}m" }.gsub(INDENT_REGEX) { indentation }
+    else
+      string.gsub(PARSE_REGEX, '').gsub(INDENT_REGEX) { indentation }
+    end
+  end
+
+  def indent(&block)
+    @indent += 1
+    yield
+    @indent -= 1
+  end
+
+  def indentation
+    '  ' * @indent
+  end
+
+  def redisplay(string = '')
+    print("\r")
+    display("#{string}")
+    nil
+  end
+
+  %w{display display_line display_lines display_table parse redisplay redisplay_progressbar}.each do |method|
+    eval <<-DEF
+      def self.#{method}(*args, &block)
+        new.#{method}(*args, &block)
+      end
+    DEF
+  end
+
+end
+
+if __FILE__ == $0
+
+  Formatador.display_line("[negative]Formatador![/]")
+  Formatador.display_lines([
+    'one',
+    'two'
+  ])
+  Formatador.display_table([], [:foo])
+
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/progressbar.rb b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/progressbar.rb
new file mode 100644
index 0000000..7c386fc
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/progressbar.rb
@@ -0,0 +1,46 @@
+class Formatador
+
+  def redisplay_progressbar(current, total, options = {})
+    options = { :color => 'white', :width => 50 }.merge!(options)
+    data = progressbar(current, total, options)
+    if current < total
+      redisplay(data)
+    else
+      redisplay("#{data}\n")
+      @progressbar_started_at = nil
+    end
+  end
+
+  private
+
+  def progressbar(current, total, options)
+    color = options[:color]
+    started_at = options[:started_at]
+    width = options[:width]
+
+    output = []
+
+    if options[:label]
+      output << options[:label]
+    end
+
+    padding = ' ' * (total.to_s.size - current.to_s.size)
+    output << "[#{color}]#{padding}#{current}/#{total}[/]"
+
+    percent = current.to_f / total.to_f
+    done = '*' * (percent * width).ceil
+    remaining = ' ' * (width - done.length)
+    output << "[_white_]|[/][#{color}][_#{color}_]#{done}[/]#{remaining}[_white_]|[/]"
+
+    if started_at
+      elapsed = Time.now - started_at
+      minutes = (elapsed / 60).round.to_s
+      seconds = (elapsed % 60).round.to_s
+      output << "#{minutes}:#{'0' if seconds.size < 2}#{seconds}"
+    end
+
+    output << ''
+    output.join('  ')
+  end
+
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/table.rb b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/table.rb
new file mode 100644
index 0000000..b6f600f
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/lib/formatador/table.rb
@@ -0,0 +1,57 @@
+class Formatador
+
+  def display_table(hashes, keys = nil, &block)
+    headers = keys || []
+    widths = {}
+    if hashes.empty? && keys
+      for key in keys
+        widths[key] = key.to_s.length
+      end
+    else
+      for hash in hashes
+        for key in hash.keys
+          unless keys
+            headers << key
+          end
+          widths[key] = [key.to_s.length, widths[key] || 0, hash[key] && hash[key].to_s.length || 0].max
+        end
+        headers = headers.uniq
+      end
+    end
+
+    if block_given?
+      headers = headers.sort(&block)
+    elsif !keys
+      headers = headers.sort {|x,y| x.to_s <=> y.to_s}
+    end
+
+    split = "+"
+    if headers.empty?
+      split << '--+'
+    else
+      for header in headers
+        split << ('-' * (widths[header] + 2)) << '+'
+      end
+    end
+
+    display_line(split)
+    columns = []
+    for header in headers
+      columns << "[bold]#{header}[/]#{' ' * (widths[header] - header.to_s.length)}"
+    end
+    display_line("| #{columns.join(' | ')} |")
+    display_line(split)
+
+    for hash in hashes
+      columns = []
+      for header in headers
+        datum = hash[header] || ''
+        columns << "#{datum}#{' ' * (widths[header] - datum.to_s.length)}"
+      end
+      display_line("| #{columns.join(' | ')} |")
+      display_line(split)
+    end
+    nil
+  end
+
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/tests/formatador_tests.rb b/lib/bbcloud/vendor/formatador-0.0.15/tests/formatador_tests.rb
new file mode 100644
index 0000000..218686e
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/tests/formatador_tests.rb
@@ -0,0 +1,8 @@
+require File.expand_path(File.dirname(__FILE__) + '/tests_helper')
+
+Shindo.tests("Formatador") do
+  test("fails") do
+    "hey buddy, you should probably rename this file and start specing for real"
+    false
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.15/tests/tests_helper.rb b/lib/bbcloud/vendor/formatador-0.0.15/tests/tests_helper.rb
new file mode 100644
index 0000000..774ad7b
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.15/tests/tests_helper.rb
@@ -0,0 +1,5 @@
+$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
+$LOAD_PATH.unshift(File.dirname(__FILE__))
+require 'formatador'
+require 'rubygems'
+require 'shindo'
diff --git a/lib/bbcloud/vendor/gli-1.1.1/.require_paths b/lib/bbcloud/vendor/gli-1.1.1/.require_paths
new file mode 100644
index 0000000..3f37be2
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/.require_paths
@@ -0,0 +1,3 @@
+lib
+lib
+bin
diff --git a/lib/bbcloud/vendor/gli-1.1.1/README.rdoc b/lib/bbcloud/vendor/gli-1.1.1/README.rdoc
new file mode 100644
index 0000000..349b90b
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/README.rdoc
@@ -0,0 +1,230 @@
+= Git-Like Interface Command Line Parser
+
+Author::  Dave Copeland (mailto:davetron5000 at g mail dot com)
+Copyright:: Copyright (c) 2009 by Dave Copeland
+License:: Distributes under the Apache License, see LICENSE.txt in the source distro
+
+This is a DSL you can use to create a command line interface like git, gem or svn, in that the first argument is a command, and there are global and command specific flags.
+
+== Use
+
+Install if you need to:
+
+    sudo gem install gli
+
+The simplest way to get started is to create a scaffold project
+
+    gli init my_proj command_name other_command_name
+
+This will create a basic scaffold project in <tt>./my_proj</tt> with:
+
+* executable in <tt>./my_proj/bin/my_proj</tt>.  This file demonstrates most of what you need to describe your command line interface.
+* an empty test in <tt>./my_proj/test/tc_nothing.rb</tt> that can bootstrap your tests
+* a gemspec shell
+* a README shell
+* Rakefile that can generate RDoc, package your Gem and run tests
+
+=== Example
+
+This example demonstrates most of the features of GLI.
+
+This sets you up to use the DSL that GLI defines:
+
+    #!/usr/bin/ruby
+    $: << File.expand_path(File.dirname(__FILE__) + '/../lib') 
+
+    require 'gli'
+
+    include GLI
+
+This sets a description of your program.  This can be as long as you want.
+
+    program_description 'Support program for bootstrapping GLI-based programs'
+
+This sets a config file for your program.  The config file can be used to store default values for command
+line options and command-specific options on a per-user (or per-site) basis.  The format is YAML-based.  
+Using an absolute path will result in the configuraiton file being located there.  Without an absolute path,
+the file will be located relative to the current user's home directory (which is what is being done here).
+
+    config_file '.glirc'
+
+the configuration file 
+This describes a command line switch "-n" that is global to all commands and specified before
+the command name on the command line.
+
+    desc 'Dry run; don\'t change the disk'
+    switch :n
+
+The following describes a command line flag that is global and has a default value of '<tt>.</tt>'.  It also
+specifies a short description of its argument.  This is used to print command line help.  Note that we
+have specified two different aliases for this flag.  <tt>-r</tt> (because it is listed first) is the default
+one and <tt>--root</tt> (note two-dash syntax) is also supported.  This means that <tt>-r some_dir</tt> and <tt>--root=some_dir</tt> mean
+the same thing to the application.
+
+    desc 'Root dir in which to create project'
+    long_desc 'This is the location where your project ill be created.  A subdirectory named for your project will be created here, and THAT directory will contain the generated files'
+    default_value '.'
+    arg_name 'root_dir'
+    flag [:r,:root]
+
+Here we specify a command.  Inside the block we can use the same sorts of things as we did above to define flags
+and switches specific to the command.  These must come after the command name.  Also note that we use <tt>arg_name</tt>
+here to describe the arguments this command accepts.
+
+    desc 'Create a new GLI-based project'
+    arg_name 'project_name [command[ command]*]'
+    command [:init,:scaffold] do |c|
+
+      c.desc 'Create an ext dir'
+      c.switch [:e,:ext]
+
+      c.desc 'Overwrite/ignore existing files and directories'
+      c.switch [:force]
+
+Here we specify the actual actions to take when the command is executed.  We define a block that
+will be given the global options (as a Hash), the command-specific options (as a hash) and the command
+line arguments
+
+      c.action do |global_options,options,args|
+        if args.length < 1
+          raise 'You must specify the name of your project'
+        end
+        Scaffold.create_scaffold(g[:r],!o[:notest],o[:e],args[0],args[1..-1],o[:force],g[:n])
+      end
+    end
+
+You can also specify some global code to run before, after and on errors:
+
+    pre do |global_options,command,options,args|
+      puts "After parsing, but before #{command.name} is run"
+      return true
+      # return false if we want to skip command execution for some reason
+    end
+
+    post do |global_options,command,options,args|
+      puts "After successful execution of #{command.name}"
+    end
+
+    on_error do |ex|
+      puts "We got an error"
+      return true    # does the standard error handling code
+      # return false # this would skip standard error handling code
+    end
+
+Now, we run the program using the arguments the user provided on the command line
+
+    run(ARGV)
+
+Note that by using <tt>gli init</tt> you can create a shell with all of this already there for you.
+
+What this gives you:
+
+* A reasonably useful help system.  <tt>your_program help</tt> will list all the global options and commands (along with command aliases) and <tt>your_program help command_name</tt> will list help for that given command.
+* Error handling when flags do not receive arguments or unknown flags or switches are given
+* Error handling when an unknown command is specified
+* Default values for flags if they are not specified by the user (switches all default to false)
+* An easy way to allow location-specific defaults for options via a config file for your app
+
+What this doesn't give you:
+
+* A way to indicate required flags
+* A way to indicate a required argument or required number of arguments
+* A way to do default switches to 'true' and therefore accept things like <tt>--no-force</tt>
+* A way to have repeated flags turn into an array or other type-transforming things
+
+== Configuration File
+
+The configuration file format is a very simple means of customizing the execution of your command on a per-user
+or per-site basis.  The idea is that commonly used values that aren't the commands' default can be stored in the configuration
+file so that users do not need to specify them on the command line.  The search order for the value of a particular
+flag then becomes:
+
+1. Command line invocation
+2. Configuration File value
+3. Default value in the application
+
+Note that since there is no way to switch _off_ switches, setting them to default to true in the configuration file
+cannot be "undone" on the command line.  A future version may allow this.
+
+The configuration file format is YAML based and can be bootstrapped via the +initconfig+ command to your application.  
+This command is automatically created and added to your application's commands when you declare that there is a 
+config file.  When invoked, all global options set on the command line are configured 
+inside the configuration file.  Further, a blank area for each
+command of your application is created, to allow the user edit the config file  ith command-specific default values.
+
+    --- 
+    # Global options are here
+    :f: foo
+    :g: blah
+    # Command-specific options are under 'commands'
+    commands: 
+      # defaults for the "doit" command
+      :doit: 
+        :g: bar
+        :s: true
+      # defaults for the "gonow" command
+      :gonow: 
+        :g: foobar
+        :f: barfoo
+
+This allows you to design your application to have it's behavior _entirely_ affected by command line options, with sensible
+defaults stored in a configuration file.
+
+== Reference
+
+
+[+action+] Specify the action to take when a command is executed from the command line.  This is only usable in a command block on the command object (e.g. <tt>c.action</tt>).  This takes a block that yields three parameters: a hash of global options specified on the commandline, a hash of command-specific options specified on the command line, and an array of arguments parsed after the options were set on the command line.  So, a command like <tt>git --git-dir=/tmp commit -a -m 'Foo bar' foo.c bar.c</tt> would result in the global hash containing <tt>:'git-dir' => '/tmp'</tt>, the options hash containing <tt>:a => true, :m => 'Foo bar'</tt> and the arguments array being <tt>['foo.c', 'bar.c']</tt>
+[+arg_name+] Describe the name of the argument to the next flag or command.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.arg_name</tt>)
+[+config_file+] Name the configuration file for your applicaiton.  This can either be an absolute path to where the applicaiton will find the configuration file, or a relative path, that will be interpretted as relative to the user's home directory.  Default is +nil+, which means no configuration file will be used.  Declaring this creates a special +initconfig+ command that can bootstrap this configuration file for your users.
+[+command+] Declare a command.  This takes a symbol or array of symbols and a block.  The block yields one argument, the command itself.  
+[+default_value+] Indicate the default value of the next flag.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.default_value</tt>)
+[+desc+] Describe the next flag, switch, or command you will declare.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.desc</tt>)
+[+flag+] Declare a flag, which is a command line switch that takes an argument.  This takes either a symbol or an array of symbols.  The first symbol decared is used in your program to determine the flag's value at runtime.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.flag</tt>)
+[+long_desc+] Provide a more lengthy description of the next flag, switch, or command you will declare.  This will appear in command line output for commands when you get help for a command.  For flags and switches, this will only appear in the generated rdoc and *not* on the command line.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.long_desc</tt>)
+[+on_error+] Declare an error handling routine that will be called if any command (or other GLI processing) encouters an exception.  This is a block that will receive the exception that was caught.  All exceptions are routed through this block. If the block evaluates to true, the built-in error handling will be called after, otherwise, nothing will happen.
+[+post+] Declare code to run after every command that didn't experience an error.  This is not available inside a command block.  This takes a block that will receive four arguments: the global argument hash (as in <tt>action</tt>), the command (instance of Command), the command-specific options (as in <tt>action</tt>, and the parsed command line arguments (as in <tt>action</tt>).  
+[+pre+] Declare code to run before every command.  This is not available inside a command block.  This takes a block that will receive four arguments: the global argument hash (as in <tt>action</tt>), the command (instance of Command), the command-specific options (as in <tt>action</tt>, and the parsed command line arguments (as in <tt>action</tt>).  If this block evaluates to false, the command will not be executed and the program will stop.
+[+switch+] Declare a switch, which is a command-line switch taking no argument that indicates a boolean "true" when specified on the command line.  This takes either a symbol or array of symbols.  The first symbol declared is used in your program to determine if the switch was set.  This can be used at the global level or inside a command block on the command object (e.g. <tt>c.switch</tt>)
+
+== Interface Generated
+
+The command line interface that is created with the GLI DSL is:
+
+*executable* <i>global options and flags</i> *command* <i>command specific options and flags</i> `arguments`
+
+[switch]    a command line control string that takes no argument.  The <tt>-l</tt> in <tt>ls -l</tt>
+[flag]      a switch that takes an argument.  The <tt>-d' '</tt> in <tt>cut -d' ' file</tt>
+[command]   the command to execute.  The <tt>rebase</tt> in <tt>git rebase</tt>
+[arguments] Anything that's not a switch, flag, or command.  The <tt>main.c</tt> in <tt>git add main.c</tt>
+
+=== Switches
+
+Switches can be specified one at a time in either a long or short format:
+
+    git add -i
+    git add --interactive
+
+Switches can also be combined in their short form:
+
+    ls -l -a    
+    ls -la
+
+=== Flags
+
+Flags can be specified in long or short form, and with or without an equals:
+
+    git merge -s resolve
+    git merge --strategy=resolve
+
+=== Stop Switch
+
+A <tt>--</tt> at any time stops processing and sends the rest of the argument to the command as arguments, even if
+they start with a "--"
+
+:include:gli.rdoc
+
+== Links
+
+* [http://davetron5000.github.com/gli] - RubyDoc
+* [http://www.github.com/davetron5000/gli] - Source on GitHub
+
diff --git a/lib/bbcloud/vendor/gli-1.1.1/bin/gli b/lib/bbcloud/vendor/gli-1.1.1/bin/gli
new file mode 100755
index 0000000..ae16f7f
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/bin/gli
@@ -0,0 +1,64 @@
+#!/usr/bin/ruby
+$: << File.expand_path(File.dirname(__FILE__) + '/../lib') 
+
+require 'gli'
+require 'support/scaffold'
+
+include GLI
+
+desc 'Be verbose'
+switch :v
+
+desc 'Show version'
+switch :version
+
+desc 'Dry run; don''t change the disk'
+switch :n
+
+desc 'Root dir of project'
+long_desc 'This is the directory where the project''s directory will be made, so if you specify a project name ''foo'' and the root dir of ''.'', the directory ''./foo'' will be created'
+default_value '.'
+flag [:r,:root]
+
+desc 'Create a new GLI-based project'
+long_desc <<EOS
+This will create a scaffold command line project that uses GLI
+for command line processing.  Specifically, this will create
+an executable ready to go, as well as a lib and test directory, all
+inside the directory named for your project
+EOS
+arg_name 'project_name [command[ command]*]'
+command [:init,:scaffold] do |c|
+
+  c.desc 'Create an ext dir'
+  c.switch [:e,:ext]
+
+  c.desc 'Do not create a test dir'
+  c.switch [:notest]
+
+  c.desc 'Overwrite/ignore existing files and directories'
+  c.switch [:force]
+
+  c.action do |g,o,args|
+    if args.length < 1
+      raise 'You must specify the name of your project'
+    end
+    Scaffold.create_scaffold(g[:r],!o[:notest],o[:e],args[0],args[1..-1],o[:force],g[:n])
+  end
+end
+
+pre do |global,command,options,args|
+  if (!command || command.name == :help) && global[:version]
+    puts "#{$0} v#{GLI::VERSION}"
+    false
+  else
+    puts "Executing #{command.name}" if global[:v]
+    true
+  end
+end
+
+post do |global,command,options,args|
+  puts "Executed #{command.name}" if global[:v]
+end
+
+run(ARGV)
diff --git a/lib/bbcloud/vendor/gli-1.1.1/gli.rdoc b/lib/bbcloud/vendor/gli-1.1.1/gli.rdoc
new file mode 100644
index 0000000..8c20b5b
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/gli.rdoc
@@ -0,0 +1,45 @@
+= <tt>gli</tt>
+
+    gli [global options] command_name [command-specific options] [--] arguments...
+
+* Use the command +help+ to get a summary of commands
+* Use the command <tt>help command_name</tt> to get a help for +command_name+
+* Use <tt>--</tt> to stop command line argument processing; useful if your arguments have dashes in them
+
+== Global Options
+These options are available for any command and are specified before the name of the command
+
+[<tt>-n</tt>] Dry run; dont change the disk
+[<tt>-r, --root=arg</tt>] Root dir of project <i>( default: <tt>.</tt>)</i>
+
+                          This is the directory where the projects directory will be made, so if you specify a project name foo and the root dir of ., the directory ./foo will be created
+
+[<tt>-v</tt>] Be verbose
+[<tt>--version</tt>] Show version
+== Commands
+[<tt>help</tt>] Shows list of commands or help for one command
+[<tt>init</tt>] Create a new GLI-based project
+
+=== <tt>help [command]</tt>
+
+Shows list of commands or help for one command
+
+=== <tt>init project_name [command[ command]*]</tt>
+
+Create a new GLI-based project
+
+*Aliases*
+* <tt><b>scaffold</b></tt>
+
+This will create a scaffold command line project that uses GLI
+for command line processing.  Specifically, this will create
+an executable ready to go, as well as a lib and test directory, all
+inside the directory named for your project
+
+
+==== Options
+These options are specified *after* the command.
+
+[<tt>-e, --ext</tt>] Create an ext dir
+[<tt>--force</tt>] Overwrite/ignore existing files and directories
+[<tt>--notest</tt>] Do not create a test dir
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli.rb
new file mode 100644
index 0000000..bce9687
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli.rb
@@ -0,0 +1,311 @@
+require 'gli/command_line_token.rb'
+require 'gli/command.rb'
+require 'gli/switch.rb'
+require 'gli/flag.rb'
+require 'gli/options.rb'
+require 'gli_version.rb'
+require 'support/help.rb'
+require 'support/rdoc.rb'
+require 'support/initconfig.rb'
+require 'etc'
+
+# A means to define and parse a command line interface that works as
+# Git's does, in that you specify global options, a command name, command
+# specific options, and then command arguments.
+module GLI
+  extend self
+
+  @@program_name = $0.split(/\//)[-1]
+  @@post_block = nil
+  @@pre_block = nil
+  @@error_block = nil
+  @@config_file = nil
+
+  # Reset the GLI module internal data structures; mostly for testing
+  def reset
+    switches.clear
+    flags.clear
+    commands.clear
+    @@config_file = nil
+    clear_nexts
+  end
+
+  # describe the next switch, flag, or command.  This should be a
+  # short, one-line description
+  def desc(description); @@next_desc = description; end
+
+  # Provide a longer, more detailed description.  This
+  # will be reformatted and wrapped to fit in 80 columns
+  def long_desc(long_desc); @@next_long_desc = long_desc; end
+
+  # describe the argument name of the next flag
+  def arg_name(name); @@next_arg_name = name; end
+  # set the default value of the next flag
+  def default_value(val); @@next_default_value = val; end
+
+  # Create a flag, which is a switch that takes an argument
+  def flag(*names)
+    flag = Flag.new([names].flatten,@@next_desc,@@next_arg_name,@@next_default_value,@@next_long_desc)
+    flags[flag.name] = flag
+    clear_nexts
+  end
+
+  # Create a switch
+  def switch(*names)
+    switch = Switch.new([names].flatten,@@next_desc,@@next_long_desc)
+    switches[switch.name] = switch
+    clear_nexts
+  end
+
+  # Sets the config file.  If not an absolute path
+  # sets the path to the user's home directory
+  def config_file(filename)
+    if filename =~ /^\//
+      @@config_file = filename
+    else
+      @@config_file = Etc.getpwuid.dir + '/' + filename
+    end
+    commands[:initconfig] = InitConfig.new(@@config_file)
+    @@config_file
+  end
+
+  # Define a command.
+  def command(*names)
+    command = Command.new([names].flatten,@@next_desc,@@next_arg_name,@@next_long_desc)
+    commands[command.name] = command
+    yield command
+    clear_nexts
+  end
+
+  # Define a block to run after command line arguments are parsed
+  # but before any command is run.  If this block raises an exception
+  # the command specified will not be executed.
+  # The block will receive the global-options,command,options, and arguments
+  # If this block evaluates to true, the program will proceed; otherwise
+  # the program will end immediately
+  def pre(&a_proc)
+    @@pre_block = a_proc
+  end
+
+  # Define a block to run after command hase been executed, only
+  # if there was not an error.
+  # The block will receive the global-options,command,options, and arguments
+  def post(&a_proc)
+    @@post_block = a_proc
+  end
+
+  # Define a block to run if an error occurs.
+  # The block will receive any Exception that was caught.
+  # It should return false to avoid the built-in error handling (which basically just
+  # prints out a message)
+  def on_error(&a_proc)
+    @@error_block = a_proc
+  end
+
+  # Runs whatever command is needed based on the arguments.
+  def run(args)
+    rdoc = RDocCommand.new
+    commands[:rdoc] = rdoc if !commands[:rdoc]
+    commands[:help] = DefaultHelpCommand.new(rdoc) if !commands[:help]
+    begin
+      config = parse_config
+      global_options,command,options,arguments = parse_options(args,config)
+      proceed = true
+      proceed = @@pre_block.call(global_options,command,options,arguments) if @@pre_block 
+      if proceed
+        command = commands[:help] if !command
+        command.execute(global_options,options,arguments)
+        @@post_block.call(global_options,command,options,arguments) if @@post_block 
+      end
+    rescue Exception => ex
+      regular_error_handling = true
+      regular_error_handling = @@error_block.call(ex) if @@error_block
+
+      if regular_error_handling
+        puts "error: #{ex.message}"
+      end
+    end
+  end
+
+  def parse_config
+    return nil if @@config_file.nil?
+    require 'yaml'
+    if File.exist?(@@config_file)
+      File.open(@@config_file) { |f| YAML::load(f) }
+    else
+      {}
+    end
+  end
+
+  def program_name(override=nil)
+    if override
+      @@program_name = override
+    end
+    @@program_name
+  end
+
+  # Returns an array of four values:
+  #  * global options (as a Hash)
+  #  * Command 
+  #  * command options (as a Hash)
+  #  * arguments (as an Array)
+  def parse_options(args,config=nil)
+    command_configs = {}
+    if config.nil?
+      config = {}
+    else
+      command_configs = config.delete(GLI::InitConfig::COMMANDS_KEY) if !config.nil?
+    end
+    global_options,command,options,arguments = parse_options_helper(args.clone,config,nil,Options.new,Array.new,command_configs)
+    flags.each { |name,flag| global_options[name] = flag.default_value if !global_options[name] }
+    command.flags.each { |name,flag| options[name] = flag.default_value if !options[name] }
+    return [global_options,command,options,arguments]
+  end
+
+  # Finds the index of the first non-flag
+  # argument or -1 if there wasn't one.
+  def find_non_flag_index(args)
+    args.each_index do |i|
+      return i if args[i] =~ /^[^\-]/;
+      return i-1 if args[i] =~ /^\-\-$/;
+    end
+    -1;
+  end
+
+  alias :d :desc
+  alias :f :flag
+  alias :s :switch
+  alias :c :command
+
+  def clear_nexts
+    @@next_desc = nil
+    @@next_arg_name = nil
+    @@next_default_value = nil
+    @@next_long_desc = nil
+  end
+
+  clear_nexts
+
+  def flags; @@flags ||= {}; end
+  def switches; @@switches ||= {}; end
+  def commands; @@commands ||= {}; end
+
+  # Recursive helper for parsing command line options
+  # [args] the arguments that have yet to be processed
+  # [global_options] the global options hash
+  # [command] the Command that has been identified (or nil if not identified yet)
+  # [command_options] options for Command
+  # [arguments] the arguments for Command
+  # [command_configs] the configuration file for all commands, used as defaults
+  #
+  # This works by finding the first non-switch/flag argument, and taking that sublist and trying to pick out
+  # flags and switches.  After this is done, one of the following is true:
+  #   * the sublist is empty - in this case, go again, as there might be more flags to parse
+  #   * the sublist has a flag left in it - unknown flag; we bail
+  #   * the sublist has a non-flag left in it - this is the command (or the start of the arguments list)
+  #
+  # This sort of does the same thing in two phases; in the first phase, the command hasn't been identified, so
+  # we are looking for global switches and flags, ending when we get the command.
+  #
+  # Once the command has been found, we start looking for command-specific flags and switches.
+  # When those have been found, we know the rest of the argument list is arguments for the command
+  def parse_options_helper(args,global_options,command,command_options,arguments,command_configs)
+    non_flag_i = find_non_flag_index(args)
+    all_flags = false
+    if non_flag_i == 0
+      # no flags
+      if !command
+        command_name = args.shift
+        command = find_command(command_name)
+        raise "Unknown command '#{command_name}'" if !command
+        return parse_options_helper(args,
+                                    global_options,
+                                    command,
+                                    default_command_options(command,command_configs),
+                                    arguments,
+                                    command_configs)
+      else
+        return global_options,command,command_options,arguments + args
+      end
+    elsif non_flag_i == -1
+      all_flags = true
+    end
+
+    try_me = args[0..non_flag_i]
+    rest = args[(non_flag_i+1)..args.length]
+    if all_flags
+      try_me = args 
+      rest = []
+    end
+
+    # Suck up whatever options we can
+    switch_hash = switches
+    flag_hash = flags
+    options = global_options
+    if command
+      switch_hash = command.switches
+      flag_hash = command.flags
+      options = command_options
+    end
+
+    switch_hash.each do |name,switch|
+      value = switch.get_value!(try_me)
+      options[name] = value if !options[name]
+    end
+
+    flag_hash.each do |name,flag|
+      value = flag.get_value!(try_me)
+      options[name] = value if value
+    end
+
+    if try_me.empty?
+      return [global_options,command,command_options,arguments] if rest.empty?
+      # If we have no more options we've parsed them all
+      # and rest may have more
+      return parse_options_helper(rest,global_options,command,command_options,arguments,command_configs)
+    else
+      if command
+        check = rest
+        check = rest + try_me if all_flags 
+        check.each() do |arg| 
+          if arg =~ /^\-\-$/
+            try_me.delete arg
+            break 
+          end
+          raise "Unknown argument #{arg}" if arg =~ /^\-/ 
+        end
+        return [global_options,command,command_options,try_me + rest]
+      else
+        # Now we have our command name
+        command_name = try_me.shift
+        raise "Unknown argument #{command_name}" if command_name =~ /^\-/
+
+        command = find_command(command_name)
+        raise "Unknown command '#{command_name}'" if !command
+
+        return parse_options_helper(rest,
+                                    global_options,
+                                    command,
+                                    default_command_options(command,command_configs),
+                                    arguments,
+                                    command_configs)
+      end
+    end
+
+  end
+
+  def default_command_options(command,command_configs)
+    options = (command_configs && command_configs[command.name.to_sym]) || {}
+  end
+
+  def find_command(name)
+    sym = name.to_sym
+    return commands[name.to_sym] if commands[sym]
+    commands.keys.each do |command_name|
+      command = commands[command_name]
+      return command if (command.aliases && command.aliases.include?(sym))
+    end
+    nil
+  end
+
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli/command.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/command.rb
new file mode 100644
index 0000000..22eaa01
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/command.rb
@@ -0,0 +1,74 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # A command to be run, in context of global flags and switches
+  class Command < CommandLineToken
+
+    # Create a new command
+    #
+    # [names] the name or names of this command (symbol or Array of symbols)
+    # [description] description of this command
+    # [arguments_name] description of the arguments, or nil if this command doesn't take arguments
+    # [long_desc] a longer description of the command, possibly with multiple lines and text formatting
+    #
+    def initialize(names,description,arguments_name=nil,long_desc=nil)
+      super(names,description,long_desc)
+      @arguments_description = arguments_name || ''
+      clear_nexts
+    end
+
+    def arguments_description; @arguments_description; end
+
+    def names
+      all_forms
+    end
+
+    def usage
+      usage = name.to_s
+      usage += ' [options]' if !flags.empty? || !switches.empty?
+      usage += ' ' + @arguments_description if @arguments_description
+      usage
+    end
+
+    def flags; @flags ||= {}; end
+    def switches; @switches ||= {}; end
+
+    # describe the next switch or flag
+    def desc(description); @next_desc = description; end
+    # describe the argument name of the next flag
+    def arg_name(name); @next_arg_name = name; end
+    # set the default value of the next flag
+    def default_value(val); @next_default_value = val; end
+
+    def flag(*names)
+      flag = Flag.new([names].flatten,@next_desc,@next_arg_name,@next_default_value)
+      flags[flag.name] = flag
+      clear_nexts
+    end
+
+    # Create a switch
+    def switch(*names)
+      switch = Switch.new([names].flatten,@next_desc)
+      switches[switch.name] = switch
+      clear_nexts
+    end
+
+    def action(&block)
+      @action = block
+    end
+
+    def self.name_as_string(name)
+      name.to_s
+    end
+
+    def clear_nexts
+      @next_desc = nil
+      @next_arg_name = nil
+      @next_default_value = nil
+    end
+
+    def execute(global_options,options,arguments)
+      @action.call(global_options,options,arguments)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli/command_line_token.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/command_line_token.rb
new file mode 100644
index 0000000..be2a08d
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/command_line_token.rb
@@ -0,0 +1,53 @@
+module GLI
+  # Logical element of a command line, mostly so that subclasses can have similar
+  # initialization and interface
+  class CommandLineToken
+    attr_reader :name
+    attr_reader :aliases
+    attr_reader :description
+    attr_reader :long_description
+
+    def initialize(names,description,long_description=nil)
+      @description = description
+      @long_description = long_description
+      @name,@aliases,@names = parse_names(names)
+    end
+
+    def usage
+      all_forms
+    end
+
+    def <=>(other)
+      self.name.to_s <=> other.name.to_s
+    end
+
+    private
+    # Returns a string of all possible forms
+    # of this flag.  Mostly intended for printing
+    # to the user.
+    def all_forms(joiner=', ')
+      forms = all_forms_a
+      forms.join(joiner)
+    end
+
+
+    # Handles dealing with the "names" param, parsing
+    # it into the primary name and aliases list
+    def parse_names(names)
+      names_hash = Hash.new
+      names = names.is_a?(Array) ? names : [names]
+      names.each { |n| names_hash[self.class.name_as_string(n)] = true }
+      name = names.shift
+      aliases = names.length > 0 ? names : nil
+      [name,aliases,names_hash]
+    end
+
+    def all_forms_a
+      forms = [self.class.name_as_string(name)]
+      if aliases
+        forms |= aliases.collect { |a| self.class.name_as_string(a) }.sort { |x,y| y.length <=> x.length }
+      end
+      forms
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli/flag.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/flag.rb
new file mode 100644
index 0000000..e921f06
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/flag.rb
@@ -0,0 +1,66 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # Defines a flag, which is to say a switch that takes an argument
+  class Flag < Switch
+
+    attr_reader :default_value
+
+    def initialize(names,description,argument_name=nil,default=nil,long_desc=nil)
+      super(names,description,long_desc)
+      @argument_name = argument_name || "arg"
+      @default_value = default
+    end
+
+    def get_value!(args)
+      args.each_index() do |index|
+        arg = args[index]
+        present,matched,value = find_me(arg)
+        if present
+          args.delete_at index
+          if !value || value == ''
+            if args[index]
+              value = args[index]
+              args.delete_at index
+              return value
+            else
+              raise "#{matched} requires an argument"
+            end
+          else
+            return value
+          end
+        end
+      end
+      return @default_value
+    end
+
+    def find_me(arg)
+      if @names[arg]
+        return [true,arg,nil] if arg.length == 2
+        # This means we matched the long-form, but there's no argument
+        raise "#{arg} requires an argument via #{arg}=argument"
+      end
+      @names.keys.each() do |name|
+        match_string = "^#{name}=(.*)$"
+        match_data = arg.match(match_string)
+        return [true,name,$1] if match_data;
+      end
+      [false,nil,nil]
+    end
+
+    # Returns a string of all possible forms
+    # of this flag.  Mostly intended for printing
+    # to the user.
+    def all_forms(joiner=', ')
+      forms = all_forms_a
+      string = forms.join(joiner)
+      if forms[-1] =~ /^\-\-/
+        string += '='
+      else
+        string += ' '
+      end
+      string += @argument_name
+      return string
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli/options.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/options.rb
new file mode 100644
index 0000000..2065cc8
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/options.rb
@@ -0,0 +1,14 @@
+require 'ostruct'
+
+class Options < OpenStruct
+
+  def[](k)
+    @table[k.to_sym]
+  end
+
+  def[]=(k, v)
+    @table[k.to_sym] = v
+  end
+
+end
+
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli/switch.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/switch.rb
new file mode 100644
index 0000000..66ebe20
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli/switch.rb
@@ -0,0 +1,56 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # Defines a command line switch
+  class Switch < CommandLineToken
+
+    def initialize(names,description,long_desc=nil)
+      super(names,description,long_desc)
+    end
+
+    # Given the argument list, scans it looking for this switch
+    # returning true if it's in the argumennt list (and removing it from the argument list)
+    def get_value!(args)
+      idx = -1
+      args.each_index do |i|
+        result = find_me(args[i])
+        if result[0]
+          if result[1]
+            args[i] = result[1]
+          else
+            args.delete_at i
+          end
+          return result[0]
+        end
+      end
+      false
+    end
+
+    # Finds the switch in the given arg, returning the arg to keep.
+    # Returns an array of size 2:
+    # [0] true or false if the arg was found
+    # [1] the remaining arg to keep in the command line or nil to remove it
+    def find_me(arg)
+      if @names[arg]
+        return [true,nil]
+      end
+      @names.keys.each() do |name|
+        if name =~ /^-(\w)$/
+          match_string = "^\\-(\\w*)#{$1}(\\w*)$"
+          match_data = arg.match(match_string)
+          if match_data
+            # Note that if [1] and [2] were both empty 
+            # we'd have returned above
+            return [true, "-" + match_data[1] + match_data[2]]
+          end
+        end
+      end
+      [false]
+    end
+
+    def self.name_as_string(name)
+      string = name.to_s
+      string.length == 1 ? "-#{string}" : "--#{string}"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/gli_version.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/gli_version.rb
new file mode 100644
index 0000000..511bf61
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/gli_version.rb
@@ -0,0 +1,3 @@
+module GLI
+  VERSION = '1.1.1'
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/support/help.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/support/help.rb
new file mode 100644
index 0000000..b95640a
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/support/help.rb
@@ -0,0 +1,118 @@
+require 'gli'
+require 'gli/command'
+
+module GLI
+  class DefaultHelpCommand < Command
+    def initialize(*omit_from_list)
+      @omit_from_list = omit_from_list
+      super(:help,'Shows list of commands or help for one command','[command]')
+    end
+
+    def execute(global_options,options,arguments)
+      if arguments.empty?
+        list_global_flags
+        list_commands
+      else
+        list_one_command_help(arguments[0])
+      end
+    end
+
+    private
+
+    def list_global_flags
+      usage = "usage: #{GLI.program_name} command"
+      all_options = GLI.switches.merge(GLI.flags)
+      if !all_options.empty?
+        usage += ' [options]'
+      end
+      puts usage
+      puts
+      puts 'Options:' if !all_options.empty?
+      output_command_tokens_for_help(all_options)
+      puts if !all_options.empty?
+    end
+
+    def list_commands
+      puts 'Commands:'
+      commands_to_show = GLI.commands.reject{ |name,c| @omit_from_list.include?(c) }
+      output_command_tokens_for_help(commands_to_show,:names)
+    end
+
+    def list_one_command_help(command_name)
+      command = GLI.find_command(command_name)
+      if command
+        puts command.usage
+        description = wrap(command.description,4)
+        puts "    #{description}"
+        if command.long_description
+          puts
+          puts "    #{wrap(command.long_description,4)}"
+        end
+        all_options = command.switches.merge(command.flags)
+        if !all_options.empty?
+          puts
+          puts "Options:"
+          output_command_tokens_for_help(all_options)
+        end
+      else
+        puts "No such command #{command_name}"
+      end
+    end
+
+    def output_command_tokens_for_help(tokens,usage_name=:usage)
+      max = 0
+      tokens.values.each do |token| 
+        len = token.send(usage_name).length
+        if len > max 
+          max = len
+        end
+      end
+      names = tokens.keys.sort { |x,y| x.to_s <=> y.to_s }
+      names.each do |name|
+        token = tokens[name]
+        description = token.description || ''
+        if token.kind_of? Flag 
+          description += " (default: #{token.default_value})" if token.default_value
+        end
+        description = wrap(description,max+7)
+        printf "    %-#{max}s - %s\n",token.send(usage_name),description
+      end
+    end
+  end
+
+  private
+
+  # Wraps the line at the given column length, using the given line padding.
+  # Assumes that the first line doesn't need the padding, as its filled
+  # up with other stuff
+  def wrap(line,pad_length=0,line_length=80)
+    line_padding = sprintf("%#{pad_length}s",'')
+    words = line.split(/\s+/)
+    return line if !words || words.empty?
+    wrapped = ''
+    while wrapped.length + line_padding.length < line_length
+      wrapped += ' ' if wrapped.length > 0
+      word = words.shift
+      if (wrapped.length + line_padding.length + word.length > line_length)
+        words.unshift word
+        break;
+      end
+      wrapped += word
+      return wrapped if words.empty?
+    end
+    wrapped += "\n"
+    this_line = line_padding
+    words.each do |word|
+      if this_line.length + word.length > line_length
+        wrapped += this_line
+        wrapped += "\n"
+        this_line = line_padding + word
+      else
+        this_line += ' ' if this_line.length > line_padding.length
+        this_line += word
+      end
+    end
+    wrapped.chomp!
+    wrapped + "\n" + this_line
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/support/initconfig.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/support/initconfig.rb
new file mode 100644
index 0000000..2c6a190
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/support/initconfig.rb
@@ -0,0 +1,35 @@
+require 'gli'
+require 'gli/command'
+require 'yaml'
+
+module GLI
+  class InitConfig < Command
+    COMMANDS_KEY = 'commands'
+
+    def initialize(config_file_name)
+      @filename = config_file_name
+      super(:initconfig,"Initialize the config file using current global options",nil,'Initializes a configuration file where you can set default options for command line flags, both globally and on a per-command basis.  These defaults override the built-in defaults and allow you to omit commonly-used command line flags when invoking this program')
+
+      self.desc 'force overwrite of existing config file'
+      self.switch :force
+    end
+
+    def execute(global_options,options,arguments)
+      if options[:force] || !File.exist?(@filename)
+        config = global_options
+        config[COMMANDS_KEY] = {}
+        GLI.commands.each do |name,command|
+          if (command != self) && (name != :rdoc) && (name != :help)
+            config[COMMANDS_KEY][name.to_sym] = {} if command != self
+          end
+        end
+        File.open(@filename,'w') do |file|
+          YAML.dump(config,file)
+        end
+      else
+        puts "Not overwriting existing config file #{@filename}"
+        puts 'Use --force to override'
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/support/rdoc.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/support/rdoc.rb
new file mode 100644
index 0000000..6467e75
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/support/rdoc.rb
@@ -0,0 +1,78 @@
+require 'gli'
+require 'fileutils'
+
+module GLI
+  class RDocCommand < Command
+
+    def initialize
+      super(:rdoc,'Generates RDoc for your command line interface')
+    end
+
+    def execute(g,o,a)
+      File.open("#{GLI.program_name}.rdoc",'w') do |file|
+        file << "= <tt>#{GLI.program_name}</tt>\n\n"
+        file << "    "
+        file << GLI.program_name
+        file << " "
+        global_options = GLI.switches.merge(GLI.flags)
+        if (global_options && global_options.length > 0)
+          file << "[global options] "
+        end
+        file << "command_name"
+        file << " [command-specific options]"
+        file << " [--] arguments...\n\n"
+        file << "* Use the command +help+ to get a summary of commands\n"
+        file << "* Use the command <tt>help command_name</tt> to get a help for +command_name+\n"
+        file << "* Use <tt>--</tt> to stop command line argument processing; useful if your arguments have dashes in them\n"
+        file << "\n"
+        if (global_options && global_options.length > 0)
+          file << "== Global Options\n"
+          file << "These options are available for any command and are specified before the name of the command\n\n"
+          output_flags(file,global_options)
+        end
+        file << "== Commands\n"
+        GLI.commands.values.sort.each do |command|
+          next if command == self
+          file << "[<tt>#{command.name}</tt>] #{command.description}\n"
+        end
+        file << "\n"
+
+        GLI.commands.values.sort.each do |command|
+          next if command == self
+          file << "=== <tt>#{command.name} #{command.arguments_description}</tt>\n\n"
+          file << "#{command.description}\n\n"
+          if command.aliases
+            file << "*Aliases*\n"
+            command.aliases.each do |al|
+              file << "* <tt><b>#{al}</b></tt>\n"
+            end 
+            file << "\n"
+          end
+          all_options = command.switches.merge(command.flags)
+          if (all_options && all_options.length > 0)
+            file << "#{command.long_description}\n\n"
+            file << "==== Options\n"
+            file << "These options are specified *after* the command.\n\n"
+            output_flags(file,all_options)
+          end
+        end
+      end
+    end
+
+    def output_flags(file,flags)
+      flags.values.sort.each do |flag|
+        file << "[<tt>#{flag.usage}</tt>] #{flag.description}"
+        if flag.kind_of? Flag
+          file << " <i>( default: <tt>#{flag.default_value}</tt>)</i>" if flag.default_value
+        end
+        file << "\n"
+        if flag.long_description
+          file << "\n"
+          # 12 is 4 for tt, 5 for /tt, 2 for the brackets and 1 for spacing
+          (flag.usage.length + 12).times { file << " " }
+          file << "#{flag.long_description}\n\n"
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.1.1/lib/support/scaffold.rb b/lib/bbcloud/vendor/gli-1.1.1/lib/support/scaffold.rb
new file mode 100644
index 0000000..02e261d
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.1.1/lib/support/scaffold.rb
@@ -0,0 +1,233 @@
+require 'gli'
+require 'fileutils'
+
+module GLI
+  class Scaffold
+
+    def self.create_scaffold(root_dir,create_test_dir,create_ext_dir,project_name,commands,force=false,dry_run=false)
+      dirs = [File.join(root_dir,project_name,'lib')]
+      dirs << File.join(root_dir,project_name,'bin')
+      dirs << File.join(root_dir,project_name,'test') if create_test_dir
+      dirs << File.join(root_dir,project_name,'ext') if create_ext_dir
+
+      if mkdirs(dirs,force,dry_run)
+        mk_binfile(root_dir,create_ext_dir,force,dry_run,project_name,commands)
+        mk_readme(root_dir,dry_run,project_name)
+        mk_gemspec(root_dir,dry_run,project_name)
+        mk_rakefile(root_dir,dry_run,project_name,create_test_dir)
+      end
+    end
+
+    def self.mk_readme(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/README.rdoc",'w') do |file|
+        file << "= #{project_name}\n\n"
+        file << "Describe your project here\n\n"
+        file << ":include:#{project_name}.rdoc\n\n"
+      end
+      File.open("#{root_dir}/#{project_name}/#{project_name}.rdoc",'w') do |file|
+        file << "= #{project_name}\n\n"
+        file << "Generate this with\n    #{project_name} rdoc\nAfter you have described your command line interface"
+      end
+    end
+
+    def self.mk_gemspec(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/#{project_name}.gemspec",'w') do |file|
+        file.puts <<EOS
+spec = Gem::Specification.new do |s| 
+  s.name = '#{project_name}'
+  s.version = '0.0.01'
+  s.author = 'Your Name Here'
+  s.email = 'your@email.address.com'
+  s.homepage = 'http://your.website.com'
+  s.platform = Gem::Platform::RUBY
+  s.summary = 'A description of your project'
+# Add your other files here if you make them
+  s.files = %w(
+bin/#{project_name}
+  )
+  s.require_paths << 'lib'
+  s.has_rdoc = true
+  s.extra_rdoc_files = ['README.rdoc','#{project_name}.rdoc']
+  s.rdoc_options << '--title' << 'Git Like Interface' << '--main' << 'README.rdoc' << '-ri'
+  s.bindir = 'bin'
+  s.executables << '#{project_name}'
+end
+EOS
+      end
+    end
+
+    def self.mk_rakefile(root_dir,dry_run,project_name,create_test_dir)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/Rakefile",'w') do |file|
+        file.puts <<EOS
+require 'rake/clean'
+require 'rubygems'
+require 'rake/gempackagetask'
+require 'rake/rdoctask'
+
+Rake::RDocTask.new do |rd|
+  rd.main = "README.rdoc"
+  rd.rdoc_files.include("README.rdoc","lib/**/*.rb","bin/**/*")
+  rd.title = 'Your application title'
+end
+
+spec = eval(File.read('#{project_name}.gemspec'))
+
+Rake::GemPackageTask.new(spec) do |pkg|
+end
+
+EOS
+        if create_test_dir
+          file.puts <<EOS
+require 'rake/testtask'
+Rake::TestTask.new do |t|
+  t.libs << "test"
+  t.test_files = FileList['test/tc_*.rb']
+end
+
+task :default => :test
+EOS
+          File.open("#{root_dir}/#{project_name}/test/tc_nothing.rb",'w') do |test_file|
+            test_file.puts <<EOS
+require 'test/unit'
+require 'test/unit/ui/console/testrunner'
+
+class TC_testNothing < Test::Unit::TestCase
+
+  def setup
+  end
+
+  def teardown
+  end
+
+  def test_the_truth
+    assert true
+  end
+end
+EOS
+          end
+        else
+          file.puts "task :default => :package\n"
+        end
+      end
+    end
+
+    def self.mk_binfile(root_dir,create_ext_dir,force,dry_run,project_name,commands)
+      bin_file = File.join(root_dir,project_name,'bin',project_name)
+      if !File.exist?(bin_file) || force
+        if !dry_run
+          File.open(bin_file,'w') do |file|
+            file.chmod(0755)
+            file.puts '#!/usr/bin/ruby'
+            file.puts '$: << File.expand_path(File.dirname(__FILE__) + \'/../lib\')'
+            file.puts '$: << File.expand_path(File.dirname(__FILE__) + \'/../ext\')' if create_ext_dir
+            file.puts <<EOS
+require 'rubygems'
+require 'gli'
+
+include GLI
+
+desc 'Describe some switch here'
+switch [:s,:switch]
+
+desc 'Describe some flag here'
+default_value 'the default'
+arg_name 'The name of the argument'
+flag [:f,:flagname]
+EOS
+            first = true
+            commands.each do |command|
+              file.puts <<EOS
+
+desc 'Describe #{command} here'
+arg_name 'Describe arguments to #{command} here'
+EOS
+              if first
+                file.puts <<EOS
+command :#{command} do |c|
+  c.desc 'Describe a switch to #{command}'
+  c.switch :s
+
+  c.desc 'Describe a flag to #{command}'
+  c.default_value 'default'
+  c.flag :s
+  c.action do |global_options,options,args|
+
+    # Your command logic here
+     
+    # If you have any errors, just raise them
+    # raise "that command made no sense"
+  end
+end
+EOS
+              else
+                file.puts <<EOS
+command :#{command} do |c|
+  c.action do |global_options,options,args|
+  end
+end
+EOS
+              end
+              first = false
+            end
+            file.puts <<EOS
+
+pre do |global,command,options,args|
+  # Pre logic here
+  # Return true to proceed; false to abourt and not call the
+  # chosen command
+  true
+end
+
+post do |global,command,options,args|
+  # Post logic here
+end
+
+on_error do |exception|
+  # Error logic here
+  # return false to skip default error handling
+  true
+end
+
+GLI.run(ARGV)
+EOS
+            puts "Created #{bin_file}"
+          end
+        end
+      else
+        puts bin_file + " exists; use --force to override"
+        return false
+      end
+      true
+    end
+
+    def self.mkdirs(dirs,force,dry_run)
+      exists = false
+      if !force
+        dirs.each do |dir|
+          if File.exist? dir
+            puts "#{dir} exists; use --force to override"
+            exists = true
+          end
+        end
+      end
+      if !exists
+        dirs.each do |dir|
+          puts "Creating dir #{dir}..."
+          if dry_run
+            $stderr.puts "dry-run; #{dir} not created"
+          else
+            FileUtils.mkdir_p dir
+          end
+        end
+      else
+        puts "Exiting..."
+        return false
+      end
+      true
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/.gemspec b/lib/bbcloud/vendor/hirb/.gemspec
new file mode 100644
index 0000000..482b41b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/.gemspec
@@ -0,0 +1,22 @@
+# -*- encoding: utf-8 -*-
+require 'rubygems' unless Object.const_defined?(:Gem)
+require File.dirname(__FILE__) + "/lib/hirb/version"
+ 
+Gem::Specification.new do |s|
+  s.name        = "hirb"
+  s.version     = Hirb::VERSION
+  s.authors     = ["Gabriel Horner"]
+  s.email       = "gabriel.horner@gmail.com"
+  s.homepage    = "http://tagaholic.me/hirb/"
+  s.summary     = "A mini view framework for console/irb that's easy to use, even while under its influence."
+  s.description = "Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output. Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer two dimensional menus."
+  s.required_rubygems_version = ">= 1.3.6"
+  s.rubyforge_project = 'tagaholic'
+  s.add_development_dependency 'bacon', '>= 1.1.0'
+  s.add_development_dependency 'mocha'
+  s.add_development_dependency 'mocha-on-bacon'
+  s.add_development_dependency 'bacon-bits'
+  s.files = Dir.glob(%w[{lib,test}/**/*.rb bin/* [A-Z]*.{txt,rdoc} ext/**/*.{rb,c} **/deps.rip]) + %w{Rakefile .gemspec}
+  s.extra_rdoc_files = ["README.rdoc", "LICENSE.txt"]
+  s.license = 'MIT'
+end
diff --git a/lib/bbcloud/vendor/hirb/CHANGELOG.rdoc b/lib/bbcloud/vendor/hirb/CHANGELOG.rdoc
new file mode 100644
index 0000000..2648517
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/CHANGELOG.rdoc
@@ -0,0 +1,106 @@
+== 0.3.4
+* Added auto format of array-like objects i.e. ActiveRecord::Relation and Set.
+* Fixed bug when Hirb::Console#table is used without Hirb enabled.
+* Fixed bug when hirb is running within cron and uses tput.
+
+== 0.3.3
+* Added ignore_errors option to ignore view errors and continue with original view.
+* Added support for array menu items.
+* Added support to ObjectTable for objects with an undefined :send method.
+
+== 0.3.2
+* Added irb autocompletions for bond.
+* Fixed tests for ruby 1.9.
+* Changed tests to use bacon.
+* Removed jeweler in Rakefile and pointless $LOAD_PATH manipulation.
+
+== 0.3.1
+* Bug fix on DynamicView.class_to_method to allow overrides of default views.
+* Modified mongo_mapper view to have _id first.
+
+== 0.3.0
+* Added dynamic views.
+* Added default table views for the following database classes/modules:
+  CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+  DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+  Mongoid::Document, Ripple::Document and Sequel::Model.
+* Added Hirb.add_view and Hirb.add_dynamic_view for easier view manipulation.
+* Added :multi_line_nodes option for Tree.
+* Fixed :change_fields option bug in Table.
+* Fixed no headers and nil fields bug in Table.
+* Removed deprecations in Hirb.config_file + View.enable.
+* Removed Views classes and View.format_class.
+* Removed :return_rows option for Table.
+
+== 0.2.10
+* Added multiple options to Menu, most importantly :two_d and :action.
+* Improved table resizing algorithm.
+* Added merging of configs for multiple Hirb.enable calls.
+* Added :max_fields, :hide_empty, :delete_callbacks, :resize, :header_filter
+  and :return_rows options to Table.
+* Added escaping for \t and \r in Table.
+* Renamed Table's :no_newlines option to :escape_special_chars.
+* Removed Table's :field_lengths option.
+* Removed Menu's :validate_one option.
+* Bug fix for table header of a basic array.
+* Deprecating Hirb.config_file + View.enable in next release.
+
+== 0.2.9
+* Added newline filtering and :no_newlines option for table helper.
+* Added default filters for hashes that have hash values.
+* Bug fix for deprecated to_a call.
+
+== 0.2.8
+* Added callbacks to Hirb::Helpers::Table.
+* Added :change_fields option to Hirb::Helpers::Table.
+* Added terminal size detection for jruby.
+* Bug fix for paging long outputs.
+* Bug fix to make unexpected hirb rendering errors more clear.
+
+== 0.2.7
+* 2 ruby 1.9 bug fixes.
+* Bug fix in :fields of Hirb::Helpers::ObjectTable.
+* Made :class option in Hirb::Formatter friendlier to external apps.
+
+== 0.2.6
+* Added :description option and added proc ability to :children_method option for helpers.
+* Bug fix for no ENV['HOME'] on Windows.
+* Bug fix on unaliasing output_method.
+* Bug fix on multiple renders of vertical table.
+
+== 0.2.5
+* Added ability to use Hirb.enable with non-irb ruby shells.
+* Helper configs now recursively merge when inheriting from others via :ancestor option.
+
+== 0.2.4
+* Bug fix on UTF-8 support.
+
+== 0.2.3
+* Added UTF-8 support for Ruby 1.8.x
+* Added :all_fields option to Table helper.
+
+== 0.2.2
+* Added a friendlier default (a vertical table) to incorrectly configured tables.
+* Added vertical table helper thanks to chrononaut.
+* Added detection of :select option from ActiveRecord queries in ActiveRecordTable helper.
+* Added handling anything that responds to :to_a in AutoTable helper.
+
+== 0.2.1
+* Fixed typo in Hirb::Console.view
+
+== 0.2.0
+* Major refactoring with bug fixes and better tests.
+* Improved table algorithm to ensure that tables don't wrap.
+* Added a pager which detects if output should be paged, Hirb::Pager.
+* Added a selection menu, Hirb::Menu
+* Following API changes: Hirb::Helpers::Table.max_width removed and config files don't use
+  the :view key anymore.
+== 0.1.2
+* Added tree views.
+* Added output_method option to Hirb::View.render_output.
+
+== 0.1.1
+* Fixed bug when rendering table with many fields.
+
+== 0.1.0
+* Initial release
diff --git a/lib/bbcloud/vendor/hirb/LICENSE.txt b/lib/bbcloud/vendor/hirb/LICENSE.txt
new file mode 100644
index 0000000..5b44505
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/LICENSE.txt
@@ -0,0 +1,22 @@
+The MIT LICENSE
+
+Copyright (c) 2010 Gabriel Horner
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/hirb/README.rdoc b/lib/bbcloud/vendor/hirb/README.rdoc
new file mode 100644
index 0000000..bd97980
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/README.rdoc
@@ -0,0 +1,182 @@
+To read a linked version of this README, {click here}[http://tagaholic.me/hirb/doc/].
+
+== Description
+
+Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output.
+Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable
+views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options
+for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems
+i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager
+only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer
+{two dimensional menus}[http://tagaholic.me/2010/02/16/two-dimensional-console-menus-with-hirb.html].
+
+== Install
+
+Install the gem with:
+
+    sudo gem install hirb
+
+== View Tutorials
+
+* To create and configure views, see Hirb::View or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/View.html].
+* To create dynamic views, see Hirb::DynamicView or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/DynamicView.html].
+
+== Printing Ascii Tables
+
+To print ascii tables from an array of arrays, hashes or any objects:
+
+  puts Hirb::Helper::AutoTable.render(ARRAY_OF_OBJECTS)
+
+Hirb will intelligently pick up on field names from an array of hashes and create properly-aligned
+fields from an array of arrays. See
+{here}[http://tagaholic.me/2009/10/15/boson-and-hirb-interactions.html#hirbs_handy_tables] for examples.
+
+== Rails Example
+
+Let's load and enable the view framework:
+  $ script/console
+  Loading local environment (Rails 2.3.5)
+  >> require 'hirb'
+  => true
+  >> Hirb.enable
+  => nil
+
+The default configuration provides table views for ActiveRecord::Base descendants.
+If a class isn't configured, Hirb reverts to irb's default echo mode.
+  >> Hirb::Formatter.dynamic_config['ActiveRecord::Base']
+  => {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+
+  # Tag is a model class and descendant of ActiveRecord::Base
+  >> Tag.last
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | id  | created_at              | description | name          | namespace | predicate | value |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml | gem       | tags      | yaml  |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  1 row in set
+
+  >> Hirb::Formatter.dynamic_config['String']
+  => nil
+  >> 'plain ol irb'
+  => 'plain ol irb'
+  >> Hirb::Formatter.dynamic_config['Symbol']
+  => nil
+  >> :blah
+  => :blah
+
+From above you can see there are no views configured for a String or a Symbol so Hirb defaults to
+irb's echo mode. On the other hand, Tag has a view thanks to being a descendant of ActiveRecord::Base
+and there being an :ancestor option.
+
+Having seen hirb display views based on an output object's class, let's see it handle an array of objects:
+
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | id  | created_at              | description | name              | namespace | predicate | value    |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml     | gem       | tags      | yaml     |
+  | 906 | 2009-03-06 08:47:04 UTC |             | gem:tags=nomonkey | gem       | tags      | nomonkey |
+  | 905 | 2009-03-04 00:30:10 UTC |             | article:tags=ruby | article   | tags      | ruby     |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  3 rows in set
+
+At any time you can disable Hirb if you really like irb's lovely echo mode:
+  >> Hirb.disable
+  => nil
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  => [#<Tag id: 907, name: "gem:tags=yaml", description: nil, created_at: "2009-03-06 21:10:41",
+  namespace: "gem", predicate: "tags", value: "yaml">, #<Tag id: 906, name: "gem:tags=nomonkey",
+  description: nil, created_at: "2009-03-06 08:47:04", namespace: "gem", predicate: "tags", value:
+  "nomonkey">, #<Tag id: 905, name: "article:tags=ruby", description: nil, created_at: "2009-03-04
+  00:30:10", namespace: "article", predicate: "tags", value: "ruby">]
+
+== Views: Anytime, Anywhere
+While preconfigured tables are great for database records, sometimes you just want to create
+tables/views for any output object:
+  
+  #These examples don't need to have Hirb::View enabled.
+  >> Hirb.disable
+  => nil
+
+  # Imports table() and view()
+  >> extend Hirb::Console
+  => main
+
+  # Create a table of Dates comparing them with different formats.
+  >> table [Date.today, Date.today.next_month], :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+  +------------+--------+-----------+-------+--------------------------+
+  | to_s       | ld     | ajd       | amjd  | asctime                  |
+  +------------+--------+-----------+-------+--------------------------+
+  | 2009-03-11 | 155742 | 4909803/2 | 54901 | Wed Mar 11 00:00:00 2009 |
+  | 2009-04-11 | 155773 | 4909865/2 | 54932 | Sat Apr 11 00:00:00 2009 |
+  +------------+--------+-----------+-------+--------------------------+
+  2 rows in set
+
+  # Same table as the previous method. However view() will be able to call any helper.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+If these console methods weren't convenient enough, try:
+
+  # Imports view() to all objects.
+  >> require 'hirb/import_object'
+  =>true
+  # Yields same table as above examples.
+  >> [Date.today, Date.today.next_month].view :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+Although views by default are printed to STDOUT, they can be easily modified to write anywhere:
+  # Setup views to write to file 'console.log'.
+  >> Hirb::View.render_method = lambda {|output| File.open("console.log", 'w') {|f| f.write(output) } }
+
+  # Writes to file with same table output as above example.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+  # Doesn't write to file because Symbol doesn't have a view and thus defaults to irb's echo mode.
+  >> :blah
+  =>:blah
+
+  # Go back to printing Hirb views to STDOUT.
+  >> Hirb::View.reset_render_method
+
+== Pager
+
+Hirb has both pager and formatter functionality enabled by default.
+If you want to turn off the functionality of either you can pass that in at startup:
+
+  Hirb.enable :pager=>false
+  Hirb.enable :formatter=>false
+
+or toggle their state at runtime:
+
+  Hirb::View.toggle_pager
+  Hirb::View.toggle_formatter
+
+== Sharing Helpers and Views
+If you have tested helpers you'd like to share, fork Hirb and put them under lib/hirb/helpers. To share
+views for certain classes, put them under lib/hirb/views. Please submit views for gems that have a nontrivial
+number of users.
+
+== Limitations
+If using Wirble, you should call Hirb after it since they both override irb's default output.
+
+== Motivation
+Table code from http://gist.github.com/72234 and {my console app's needs}[http://github.com/cldwalker/tag-tree].
+
+== Credits
+* Chrononaut for vertical table helper.
+* crafterm, spastorino, xaviershay, bogdan and joshua for patches.
+
+== Bugs/Issues
+Please report them {on github}[http://github.com/cldwalker/hirb/issues].
+
+== Links
+* http://tagaholic.me/2009/03/13/hirb-irb-on-the-good-stuff.html
+* http://tagaholic.me/2009/03/18/ruby-class-trees-rails-plugin-trees-with-hirb.html
+* http://tagaholic.me/2009/06/19/page-irb-output-and-improve-ri-with-hirb.html
+
+== Todo
+* Consider generating views based on methods an object responds to.
+* Provide helper methods to all views.
+* Consider adding a template helper.
diff --git a/lib/bbcloud/vendor/hirb/Rakefile b/lib/bbcloud/vendor/hirb/Rakefile
new file mode 100644
index 0000000..a88c05a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/Rakefile
@@ -0,0 +1,35 @@
+require 'rake'
+require 'fileutils'
+
+def gemspec
+  @gemspec ||= eval(File.read('.gemspec'), binding, '.gemspec')
+end
+
+desc "Build the gem"
+task :gem=>:gemspec do
+  sh "gem build .gemspec"
+  FileUtils.mkdir_p 'pkg'
+  FileUtils.mv "#{gemspec.name}-#{gemspec.version}.gem", 'pkg'
+end
+
+desc "Install the gem locally"
+task :install => :gem do
+  sh %{gem install pkg/#{gemspec.name}-#{gemspec.version}}
+end
+
+desc "Generate the gemspec"
+task :generate do
+  puts gemspec.to_ruby
+end
+
+desc "Validate the gemspec"
+task :gemspec do
+  gemspec.validate
+end
+
+desc 'Run tests'
+task :test do |t|
+  sh 'bacon -q -Ilib -I. test/*_test.rb'
+end
+
+task :default => :test
diff --git a/lib/bbcloud/vendor/hirb/lib/bond/completions/hirb.rb b/lib/bbcloud/vendor/hirb/lib/bond/completions/hirb.rb
new file mode 100644
index 0000000..ca9a642
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/bond/completions/hirb.rb
@@ -0,0 +1,15 @@
+complete(:methods=>%w{Hirb::View.enable Hirb.enable}) {
+  %w{config_file output_method output width height formatter pager pager_command}
+}
+complete(:methods=>%w{Hirb::Helpers::Table.render table}) {
+  %w{fields headers max_fields max_width resize number change_fields}+
+  %w{filters header_filter filter_any filter_classes vertical all_fields}+
+  %w{description escape_special_chars table_class hide_empty}
+}
+complete(:method=>"Hirb::Helpers::Tree.render") {
+  %w{type validate indent limit description multi_line_nodes value_method children_method}
+}
+complete(:methods=>%w{Hirb::Menu.render menu}) {
+  %w{helper_class prompt ask directions readline two_d default_field action multi_action} +
+    %w{action_object command reopen}
+}
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb.rb b/lib/bbcloud/vendor/hirb/lib/hirb.rb
new file mode 100644
index 0000000..e3f77ab
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb.rb
@@ -0,0 +1,81 @@
+# Needed by Hirb::String to handle multibyte characters
+$KCODE = 'u' if RUBY_VERSION < '1.9'
+
+require 'hirb/util'
+require 'hirb/string'
+require 'hirb/formatter' # must come before helpers/auto_table
+require 'hirb/dynamic_view'
+require 'hirb/helpers'
+require 'hirb/views'
+require 'hirb/view'
+require 'hirb/console'
+require 'hirb/pager'
+require 'hirb/menu'
+require 'hirb/version'
+
+# Most of Hirb's functionality is in Hirb::View.
+# For a tutorial  on configuring and creating views see Hirb::View. For a tutorial on dynamic views see Hirb::DynamicView.
+#
+# == Config Files
+# Hirb can have multiple config files defined by config_files(). These config files
+# have the following top level keys:
+# [*:output*] This hash is used by the formatter object. See Hirb::Formatter.config for its format.
+# [*:width*]  Width of the terminal/console. Defaults to Hirb::View::DEFAULT_WIDTH or possibly autodetected when Hirb is enabled.
+# [*:height*]  Height of the terminal/console. Defaults to Hirb::View::DEFAULT_HEIGHT or possibly autodetected when Hirb is enabled.
+# [*:formatter*] Boolean which determines if the formatter is enabled. Defaults to true.
+# [*:pager*] Boolean which determines if the pager is enabled. Defaults to true.
+# [*:pager_command*] Command to be used for paging. Command can have options after it i.e. 'less -r'.
+#                    Defaults to common pagers i.e. less and more if detected.
+# [*:ignore_errors*] Boolean which ignores internal view errors and continues with original view
+#                    (i.e. #inspect for irb). Defaults to false.
+module Hirb
+  class <<self
+    attr_accessor :config_files, :config
+
+    # Enables view functionality. See Hirb::View.enable for details.
+    def enable(options={}, &block)
+      View.enable(options, &block)
+    end
+
+    # Disables view functionality. See Hirb::View.disable for details.
+    def disable
+      View.disable
+    end
+
+    # Adds views. See Hirb::View.add for details.
+    def add_view(view, options, &block)
+      View.add(view, options, &block)
+    end
+
+    # Adds views. See Hirb::DynamicView.add for details.
+    def add_dynamic_view(view, options, &block)
+      DynamicView.add(view, options, &block)
+    end
+
+    # Array of config files which are merged sequentially to produce config.
+    # Defaults to config/hirb.yml and ~/.hirb_yml
+    def config_files
+      @config_files ||= default_config_files
+    end
+
+    #:stopdoc:
+    def default_config_files
+      [File.join(Util.find_home, ".hirb.yml")] +
+        (File.exists?('config/hirb.yml') ? ['config/hirb.yml'] : [])
+    end
+
+    def read_config_file(file=config_file)
+      File.exists?(file) ? YAML::load_file(file) : {}
+    end
+
+    def config(reload=false)
+      if (@config.nil? || reload)
+        @config = config_files.inject({}) {|acc,e|
+          Util.recursive_hash_merge(acc,read_config_file(e))
+        }
+      end
+      @config
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/console.rb b/lib/bbcloud/vendor/hirb/lib/hirb/console.rb
new file mode 100644
index 0000000..fefb134
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/console.rb
@@ -0,0 +1,43 @@
+module Hirb
+  # This module is meant to be extended to provide methods for use in a console/irb shell.
+  # For example:
+  #    >> extend Hirb::Console
+  #    >> view 'some string', :class=>Some::String::Formatter
+  #    >> table [[:row1], [:row2]]
+  module Console
+    class<<self
+      # A console version of render_output() which takes its same options but allows for shorthand. All options are passed to
+      # the helper except for the formatter options. Formatter options are :class, :method and :output_method.
+      # Examples:
+      #   render_output output, :class=>:tree :type=>:directory
+      #   # is the same as:
+      #   render_output output, :class=>:tree, :options=> {:type=>:directory}
+      #
+      def render_output(output, options={})
+        View.load_config unless View.config_loaded?
+        View.render_output(output, options.merge(:console=>true))
+      end
+
+      # Takes same arguments and options as render_output() but returns formatted output instead of rendering it.
+      def format_output(output, options={}, &block)
+        View.load_config unless View.config_loaded?
+        View.formatter.format_output(output, options.merge(:console=>true), &block)
+      end
+    end
+
+    # Renders a table for the given object. Takes same options as Hirb::Helpers::Table.render.
+    def table(output, options={})
+      Console.render_output(output, options.merge(:class=>"Hirb::Helpers::AutoTable"))
+    end
+
+    # Renders any specified view for the given object. Takes same options as Hirb::View.render_output.
+    def view(output, options={})
+      Console.render_output(output, options)
+    end
+
+    # Renders a menu given an array using Hirb::Menu.render.
+    def menu(output, options={}, &block)
+      Console.format_output(output, options.merge(:class=>"Hirb::Menu"), &block)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/dynamic_view.rb b/lib/bbcloud/vendor/hirb/lib/hirb/dynamic_view.rb
new file mode 100644
index 0000000..31929f6
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/dynamic_view.rb
@@ -0,0 +1,113 @@
+module Hirb
+  # This module extends a Helper with the ability to have dynamic views for configured output classes.
+  # After a Helper has extended this module, it can use it within a render() by calling
+  # dynamic_options() to get dynamically generated options for the object it's rendering. See Hirb::Helpers::AutoTable as an example.
+  #
+  # == Dynamic Views
+  # Whereas normal views are generated from helpers with static helper options, dynamic views are generated from helpers and
+  # dynamically generated helper options. Let's look at an example for Rails' ActiveRecord classes:
+  #
+  #   Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj|
+  #    {:fields=>obj.class.column_names} }
+  #
+  # From this dynamic view definition, _any_ ActiveRecord model class will render a table with the correct fields, since the fields
+  # are extracted from the output object's class at runtime. Note that dynamic view definitions should return a hash of helper options.
+  #
+  # To define multiple dynamic views, create a Views module where each method ending in '\_view' maps to a class/module:
+  #
+  #   module Hirb::Views::ORM
+  #     def data_mapper__resource_view(obj)
+  #       {:fields=>obj.class.properties.map {|e| e.name }}
+  #     end
+  #
+  #     def sequel__model_view(obj)
+  #       {:fields=>obj.class.columns}
+  #     end
+  #   end
+  #
+  #   Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+  #
+  # In this example, 'data_mapper__resource_view' maps to DataMapper::Resource and 'sequel__model_view' maps to Sequel::Model.
+  # Note that when mapping method names to class names, '__' maps to '::' and '_' signals the next letter to be capitalized.
+  module DynamicView
+    # Add dynamic views to output class(es) for a given helper. If defining one view, the first argument is the output class
+    # and a block defines the dynamic view. If defining multiple views, the first argument should be a Views::* module where
+    # each method in the module ending in _view defines a view for an output class. To map output classes to method names in
+    # a Views module, translate'::' to '__' and a capital letter translates to a '_' and a lowercase letter.
+    # ==== Options:
+    # [*:helper*] Required option. Helper class that view(s) use to format. Hirb::Helpers::AutoTable is the only valid
+    #             helper among default helpers. Can be given in aliased form i.e. :auto_table -> Hirb::Helpers::AutoTable.
+    #
+    # Examples:
+    #    Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+    #    Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj| {:fields=>obj.class.column_names} }
+    def self.add(view, options, &block)
+      raise ArgumentError, ":helper option is required" unless options[:helper]
+      helper = Helpers.helper_class options[:helper]
+      unless helper.is_a?(Module) && class << helper; self.ancestors; end.include?(self)
+        raise ArgumentError, ":helper option must be a helper that has extended DynamicView"
+      end
+      mod = block ? generate_single_view_module(view, &block) : view
+      raise ArgumentError, "'#{mod}' must be a module" unless mod.is_a?(Module)
+      helper.add_module mod
+    end
+
+    def self.generate_single_view_module(output_mod, &block) #:nodoc:
+      meth = class_to_method output_mod.to_s
+      view_mod = meth.capitalize
+      Views::Single.send(:remove_const, view_mod) if Views::Single.const_defined?(view_mod)
+      mod = Views::Single.const_set(view_mod, Module.new)
+      mod.send(:define_method, meth, block)
+      mod
+    end
+
+    def self.class_to_method(mod) #:nodoc:
+      mod.gsub(/(?!^)([A-Z])/) {|e| '_'+e }.gsub('::_', '__').downcase + '_view'
+    end
+
+    # Returns a hash of options based on dynamic views defined for the object's ancestry. If no config is found returns nil.
+    def dynamic_options(obj)
+      view_methods.each do |meth|
+        if obj.class.ancestors.map {|e| e.to_s }.include?(method_to_class(meth))
+          begin
+            return send(meth, obj)
+          rescue
+            raise "View failed to generate for '#{method_to_class(meth)}' "+
+              "while in '#{meth}' with error:\n#{$!.message}"
+          end
+        end
+      end
+      nil
+    end
+
+    #:stopdoc:
+    def add_module(mod)
+      new_methods = mod.instance_methods.select {|e| e.to_s =~ /_view$/ }.map {|e| e.to_s}
+      return if new_methods.empty?
+      extend mod
+      view_methods.replace(view_methods + new_methods).uniq!
+      update_config(new_methods)
+    end
+
+    def update_config(meths)
+      output_config = meths.inject({}) {|t,e|
+        t[method_to_class(e)] = {:class=>self, :ancestor=>true}; t
+      }
+      Formatter.dynamic_config.merge! output_config
+    end
+
+    def method_to_class(meth)
+      view_method_classes[meth] ||= Util.camelize meth.sub(/_view$/, '').gsub('__', '/')
+    end
+
+    def view_method_classes
+      @view_method_classes ||= {}
+    end
+    #:startdoc:
+
+    # Stores view methods that a Helper has been given via DynamicView.add
+    def view_methods
+      @view_methods ||= []
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/formatter.rb b/lib/bbcloud/vendor/hirb/lib/hirb/formatter.rb
new file mode 100644
index 0000000..7c1569f
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/formatter.rb
@@ -0,0 +1,116 @@
+module Hirb
+  # A Formatter object formats an output object (using Formatter.format_output) into a string based on the views defined
+  # for its class and/or ancestry.
+  class Formatter
+    class<<self
+      # This config is used by Formatter.format_output to lazily load dynamic views defined with Hirb::DynamicView.
+      # This hash has the same format as Formatter.config.
+      attr_accessor :dynamic_config
+    end
+    self.dynamic_config = {}
+
+    def initialize(additional_config={}) #:nodoc:
+      @klass_config = {}
+      @config = additional_config || {}
+    end
+
+    # A hash of Ruby class strings mapped to view hashes. A view hash must have at least a :method, :output_method
+    # or :class option for a view to be applied to an output. A view hash has the following keys:
+    # [*:method*] Specifies a global (Kernel) method to do the formatting.
+    # [*:class*] Specifies a class to do the formatting, using its render() class method. If a symbol it's converted to a corresponding
+    #            Hirb::Helpers::* class if it exists.
+    # [*:output_method*] Specifies a method or proc to call on output before passing it to a helper. If the output is an array, it's applied
+    #                    to every element in the array.
+    # [*:options*] Options to pass the helper method or class.
+    # [*:ancestor*] Boolean which when true causes subclasses of the output class to inherit its config. This doesn't effect the current
+    #               output class. Defaults to false. This is used by ActiveRecord classes.
+    # 
+    #   Examples:
+    #     {'WWW::Delicious::Element'=>{:class=>'Hirb::Helpers::ObjectTable', :ancestor=>true, :options=>{:max_width=>180}}}
+    #     {'Date'=>{:class=>:auto_table, :ancestor=>true}}
+    #     {'Hash'=>{:method=>:puts}}
+    def config
+      @config
+    end
+
+    # Adds the view for the given class and view hash config. See Formatter.config for valid keys for view hash.
+    def add_view(klass, view_config)
+      @klass_config.delete(klass)
+      @config[klass.to_s] = view_config
+      true
+    end
+
+    # This method looks for an output object's view in Formatter.config and then Formatter.dynamic_config.
+    # If a view is found, a stringified view is returned based on the object. If no view is found, nil is returned. The options this
+    # class takes are a view hash as described in Formatter.config. These options will be merged with any existing helper
+    # config hash an output class has in Formatter.config. Any block given is passed along to a helper class.
+    def format_output(output, options={}, &block)
+      output_class = determine_output_class(output)
+      options = parse_console_options(options) if options.delete(:console)
+      options = Util.recursive_hash_merge(klass_config(output_class), options)
+      _format_output(output, options, &block)
+    end
+
+    #:stopdoc:
+    def _format_output(output, options, &block)
+      output = options[:output_method] ? (output.is_a?(Array) ?
+        output.map {|e| call_output_method(options[:output_method], e) } :
+        call_output_method(options[:output_method], output) ) : output
+      args = [output]
+      args << options[:options] if options[:options] && !options[:options].empty?
+      if options[:method]
+        send(options[:method],*args)
+      elsif options[:class] && (helper_class = Helpers.helper_class(options[:class]))
+        helper_class.render(*args, &block)
+      elsif options[:output_method]
+        output
+      end
+    end
+
+    def parse_console_options(options) #:nodoc:
+      real_options = [:method, :class, :output_method].inject({}) do |h, e|
+        h[e] = options.delete(e) if options[e]; h
+      end
+      real_options.merge! :options=>options
+    end
+
+    def determine_output_class(output)
+      output.respond_to?(:to_a) ? Array(output)[0].class : output.class
+    end
+
+    def call_output_method(output_method, output)
+      output_method.is_a?(Proc) ? output_method.call(output) : output.send(output_method)
+    end
+
+    # Internal view options built from user-defined ones. Options are built by recursively merging options from oldest
+    # ancestors to the most recent ones.
+    def klass_config(output_class)
+      @klass_config[output_class] ||= build_klass_config(output_class)
+    end
+
+    def build_klass_config(output_class)
+      output_ancestors = output_class.ancestors.map {|e| e.to_s}.reverse
+      output_ancestors.pop
+      hash = output_ancestors.inject({}) {|h, klass|
+        add_klass_config_if_true(h, klass) {|c,klass| c[klass] && c[klass][:ancestor] }
+      }
+      add_klass_config_if_true(hash, output_class.to_s) {|c,klass| c[klass] }
+    end
+
+    def add_klass_config_if_true(hash, klass)
+      if yield(@config, klass)
+        Util.recursive_hash_merge hash, @config[klass]
+      elsif yield(self.class.dynamic_config, klass)
+        @config[klass] = self.class.dynamic_config[klass].dup # copy to local
+        Util.recursive_hash_merge hash, self.class.dynamic_config[klass]
+      else
+        hash
+      end
+    end
+
+    def reset_klass_config
+      @klass_config = {}
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers.rb
new file mode 100644
index 0000000..4c8bbd6
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers.rb
@@ -0,0 +1,17 @@
+module Hirb
+  module Helpers #:nodoc:
+    @helper_classes ||= {}
+    def self.helper_class(klass)
+      @helper_classes[klass.to_s] ||= begin
+        if (helper_class = constants.find {|e| e.to_s == Util.camelize(klass.to_s)})
+          klass = "Hirb::Helpers::#{helper_class}"
+        end
+        Util.any_const_get(klass)
+      end
+    end
+  end
+end
+
+%w{table object_table auto_table tree parent_child_tree vertical_table}.each do |e|
+  require "hirb/helpers/#{e}"
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/auto_table.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/auto_table.rb
new file mode 100644
index 0000000..ed31357
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/auto_table.rb
@@ -0,0 +1,24 @@
+# This helper wraps around the other table helpers i.e. Hirb::Helpers::Table while
+# providing default helper options via Hirb::DynamicView. Using these default options, this
+# helper supports views for the following modules/classes:
+# ActiveRecord::Base, CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+# DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+# Mongoid::Document, Ripple::Document, Sequel::Model.
+class Hirb::Helpers::AutoTable < Hirb::Helpers::Table
+  extend Hirb::DynamicView
+
+  # Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:table_class] Explicit table class to use for rendering. Defaults to
+  #                Hirb::Helpers::ObjectTable if output is not an Array or Hash. Otherwise
+  #                defaults to Hirb::Helpers::Table.
+  def self.render(output, options={})
+    output = Array(output)
+    (defaults = dynamic_options(output[0])) && (options = defaults.merge(options))
+    klass = options.delete(:table_class) || (
+      !(output[0].is_a?(Hash) || output[0].is_a?(Array)) ?
+      Hirb::Helpers::ObjectTable : Hirb::Helpers::Table)
+    klass.render(output, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/object_table.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/object_table.rb
new file mode 100644
index 0000000..6227dac
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/object_table.rb
@@ -0,0 +1,14 @@
+class Hirb::Helpers::ObjectTable < Hirb::Helpers::Table
+  # Rows are any ruby objects. Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:fields] Methods of the object to represent as columns. Defaults to [:to_s].
+  def self.render(rows, options ={})
+    options[:fields] ||= [:to_s]
+    options[:headers] ||= {:to_s=>'value'} if options[:fields] == [:to_s]
+    item_hashes = options[:fields].empty? ? [] : Array(rows).inject([]) {|t,item|
+      t << options[:fields].inject({}) {|h,f| h[f] = item.__send__(f); h}
+    }
+    super(item_hashes, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/parent_child_tree.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/parent_child_tree.rb
new file mode 100644
index 0000000..d056057
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/parent_child_tree.rb
@@ -0,0 +1,24 @@
+class Hirb::Helpers::ParentChildTree < Hirb::Helpers::Tree
+  class <<self
+    # Starting with the given node, this builds a tree by recursively calling a children method.
+    # Takes same options as Hirb::Helper::Table.render with some additional ones below.
+    # ==== Options:
+    # [:value_method] Method or proc to call to display as a node's value. If not given, uses :name if node
+    #                 responds to :name or defaults to :object_id.
+    # [:children_method] Method or proc to call to obtain a node's children. Default is :children.
+    def render(root_node, options={})
+      value_method = options[:value_method] || (root_node.respond_to?(:name) ? :name : :object_id)
+      @value_method = value_method.is_a?(Proc) ? value_method : lambda {|n| n.send(value_method) }
+      children_method = options[:children_method] || :children
+      @children_method = children_method.is_a?(Proc) ? children_method : lambda {|n| n.send(children_method)}
+      @nodes = []
+      build_node(root_node, 0)
+      super(@nodes, options)
+    end
+
+    def build_node(node, level) #:nodoc:
+      @nodes << {:value=>@value_method.call(node), :level=>level}
+      @children_method.call(node).each {|e| build_node(e, level + 1)}
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table.rb
new file mode 100644
index 0000000..de51309
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table.rb
@@ -0,0 +1,323 @@
+require 'hirb/helpers/table/filters'
+require 'hirb/helpers/table/resizer'
+
+module Hirb
+# Base Table class from which other table classes inherit.
+# By default, a table is constrained to a default width but this can be adjusted
+# via the max_width option or Hirb::View.width.
+# Rows can be an array of arrays or an array of hashes.
+#
+# An array of arrays ie [[1,2], [2,3]], would render:
+#   +---+---+
+#   | 0 | 1 |
+#   +---+---+
+#   | 1 | 2 |
+#   | 2 | 3 |
+#   +---+---+
+#
+# By default, the fields/columns are the numerical indices of the array.
+# 
+# An array of hashes ie [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], would render:
+#   +-----+--------+
+#   | age | weight |
+#   +-----+--------+
+#   | 10  | 100    |
+#   | 80  | 500    |
+#   +-----+--------+
+#
+# By default, the fields/columns are the keys of the first hash.
+#
+# === Custom Callbacks
+# Callback methods can be defined to add your own options that modify rows right before they are rendered.
+# Here's an example that allows for searching with a :query option:
+#   module Query
+#     # Searches fields given a query hash
+#     def query_callback(rows, options)
+#       return rows unless options[:query]
+#       options[:query].map {|field,query|
+#         rows.select {|e| e[field].to_s =~ /#{query}/i }
+#       }.flatten.uniq
+#     end
+#   end
+#   Hirb::Helpers::Table.send :include, Query
+#
+#   >> puts Hirb::Helpers::Table.render [{:name=>'batman'}, {:name=>'robin'}], :query=>{:name=>'rob'}
+#   +-------+
+#   | name  |
+#   +-------+
+#   | robin |
+#   +-------+
+#   1 row in set
+#
+# Callback methods:
+# * must be defined in Helpers::Table and end in '_callback'.
+# * should expect rows and a hash of render options. Rows will be an array of hashes.
+# * are expected to return an array of hashes.
+# * are invoked in alphabetical order.
+# For a thorough example, see {Boson::Pipe}[http://github.com/cldwalker/boson/blob/master/lib/boson/pipe.rb].
+#--
+# derived from http://gist.github.com/72234
+ class Helpers::Table
+  BORDER_LENGTH = 3 # " | " and "-+-" are the borders
+  MIN_FIELD_LENGTH = 3
+  class TooManyFieldsForWidthError < StandardError; end
+
+  class << self
+    
+    # Main method which returns a formatted table.
+    # ==== Options:
+    # [*:fields*] An array which overrides the default fields and can be used to indicate field order.
+    # [*:headers*] A hash of fields and their header names. Fields that aren't specified here default to their name.
+    #              When set to false, headers are hidden. Can also be an array but only for array rows.
+    # [*:max_fields*] A hash of fields and their maximum allowed lengths. Maximum length can also be a percentage of the total width
+    #                 (decimal less than one). When a field exceeds it's maximum then it's
+    #                 truncated and has a ... appended to it. Fields that aren't specified have no maximum.
+    # [*:max_width*] The maximum allowed width of all fields put together including field borders. Only valid when :resize is true.
+    #                Default is Hirb::View.width.
+    # [*:resize*] Resizes table to display all columns in allowed :max_width. Default is true. Setting this false will display the full
+    #             length of each field.
+    # [*:number*] When set to true, numbers rows by adding a :hirb_number column as the first column. Default is false.
+    # [*:change_fields*] A hash to change old field names to new field names. This can also be an array of new names but only for array rows.
+    #                    This is useful when wanting to change auto-generated keys to more user-friendly names i.e. for array rows.
+    # [*:filters*] A hash of fields and their filters, applied to every row in a field. A filter can be a proc, an instance method
+    #              applied to the field value or a Filters method. Also see the filter_classes attribute below.
+    # [*:header_filter*] A filter, like one in :filters, that is applied to all headers after the :headers option.
+    # [*:filter_any*] When set to true, any cell defaults to being filtered by its class in :filter_classes.
+    #                 Default Hirb::Helpers::Table.filter_any().
+    # [*:filter_classes*] Hash which maps classes to filters. Default is Hirb::Helpers::Table.filter_classes().
+    # [*:vertical*] When set to true, renders a vertical table using Hirb::Helpers::VerticalTable. Default is false.
+    # [*:all_fields*] When set to true, renders fields in all rows. Valid only in rows that are hashes. Default is false.
+    # [*:description*] When set to true, renders row count description at bottom. Default is true.
+    # [*:escape_special_chars*] When set to true, escapes special characters \n,\t,\r so they don't disrupt tables. Default is false for
+    #                           vertical tables and true for anything else.
+    # Examples:
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]]
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]], :max_fields=>{0=>10}, :header_filter=>:capitalize
+    #    Hirb::Helpers::Table.render [['a',1], ['b',2]], :change_fields=>%w{letters numbers}, :max_fields=>{'numbers'=>0.4}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}]
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :headers=>{:weight=>"Weight(lbs)"}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :filters=>{:age=>[:to_f]}
+    def render(rows, options={})
+      options[:vertical] ? Helpers::VerticalTable.render(rows, options) :
+      new(rows, options).render
+    rescue TooManyFieldsForWidthError
+      $stderr.puts "", "** Error: Too many fields for the current width. Configure your width " +
+        "and/or fields to avoid this error. Defaulting to a vertical table. **"
+      Helpers::VerticalTable.render(rows, options)
+    end
+
+    # A hash which maps a cell value's class to a filter. This serves to set a default filter per field if all of its
+    # values are a class in this hash. By default, Array values are comma joined and Hashes are inspected.
+    # See the :filter_any option to apply this filter per value.
+    attr_accessor :filter_classes
+    # Boolean which sets the default for :filter_any option.
+    attr_accessor :filter_any
+    # Holds last table object created
+    attr_accessor :last_table
+  end
+  self.filter_classes = { Array=>:comma_join, Hash=>:inspect }
+
+  #:stopdoc:
+  attr_accessor :width, :max_fields, :field_lengths, :fields
+  def initialize(rows, options={})
+    raise ArgumentError, "Table must be an array of hashes or array of arrays" unless rows.is_a?(Array) &&
+      (rows[0].is_a?(Hash) or rows[0].is_a?(Array) or rows.empty?)
+    @options = {:description=>true, :filters=>{}, :change_fields=>{}, :escape_special_chars=>true,
+      :filter_any=>Helpers::Table.filter_any, :resize=>true}.merge(options)
+    @fields = set_fields(rows)
+    @rows = set_rows(rows)
+    @headers = set_headers
+    if @options[:number]
+      @headers[:hirb_number] = "number"
+      @fields.unshift :hirb_number
+    end
+    Helpers::Table.last_table = self
+  end
+
+  def set_fields(rows)
+    @options[:change_fields] = array_to_indices_hash(@options[:change_fields]) if @options[:change_fields].is_a?(Array)
+    return @options[:fields].dup if @options[:fields]
+
+    fields = if rows[0].is_a?(Hash)
+      keys = @options[:all_fields] ? rows.map {|e| e.keys}.flatten.uniq : rows[0].keys
+      keys.sort {|a,b| a.to_s <=> b.to_s}
+    else
+      rows[0].is_a?(Array) ? (0..rows[0].length - 1).to_a : []
+    end
+
+    @options[:change_fields].each do |oldf, newf|
+      (index = fields.index(oldf)) && fields[index] = newf
+    end
+    fields
+  end
+
+  def set_rows(rows)
+    rows = Array(rows)
+    if rows[0].is_a?(Array)
+      rows = rows.inject([]) {|new_rows, row|
+        new_rows << array_to_indices_hash(row)
+      }
+    end
+    @options[:change_fields].each do |oldf, newf|
+      rows.each {|e| e[newf] = e.delete(oldf) if e.key?(oldf) }
+    end
+    rows = filter_values(rows)
+    rows.each_with_index {|e,i| e[:hirb_number] = (i + 1).to_s} if @options[:number]
+    deleted_callbacks = Array(@options[:delete_callbacks]).map {|e| "#{e}_callback" }
+    (methods.grep(/_callback$/).map {|e| e.to_s} - deleted_callbacks).sort.each do |meth|
+      rows = send(meth, rows, @options.dup)
+    end
+    validate_values(rows)
+    rows
+  end
+
+  def set_headers
+    headers = @fields.inject({}) {|h,e| h[e] = e.to_s; h}
+    if @options.has_key?(:headers)
+      headers = @options[:headers].is_a?(Hash) ? headers.merge(@options[:headers]) :
+        (@options[:headers].is_a?(Array) ? array_to_indices_hash(@options[:headers]) : @options[:headers])
+    end
+    if @options[:header_filter]
+      headers.each {|k,v|
+        headers[k] = call_filter(@options[:header_filter], v)
+      }
+    end
+    headers
+  end
+
+  def render
+    body = []
+    unless @rows.length == 0
+      setup_field_lengths
+      body += render_header
+      body += render_rows
+      body += render_footer
+    end
+    body << render_table_description if @options[:description]
+    body.join("\n")
+  end
+
+  def render_header
+    @headers ? render_table_header : [render_border]
+  end
+
+  def render_footer
+    [render_border]
+  end
+
+  def render_table_header
+    title_row = '| ' + @fields.map {|f|
+      format_cell(@headers[f], @field_lengths[f])
+    }.join(' | ') + ' |'
+    [render_border, title_row, render_border]
+  end
+  
+  def render_border
+    '+-' + @fields.map {|f| '-' * @field_lengths[f] }.join('-+-') + '-+'
+  end
+  
+  def format_cell(value, cell_width)
+    text = String.size(value) > cell_width ?
+      (
+      (cell_width < 5) ? String.slice(value, 0, cell_width) : String.slice(value, 0, cell_width - 3) + '...'
+      ) : value
+    String.ljust(text, cell_width)
+  end
+
+  def render_rows
+    @rows.map do |row|
+      row = '| ' + @fields.map {|f|
+        format_cell(row[f], @field_lengths[f])
+      }.join(' | ') + ' |'
+    end
+  end
+  
+  def render_table_description
+    (@rows.length == 0) ? "0 rows in set" :
+      "#{@rows.length} #{@rows.length == 1 ? 'row' : 'rows'} in set"
+  end
+  
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+    if @options[:resize]
+      raise TooManyFieldsForWidthError if @fields.size > self.actual_width.to_f / MIN_FIELD_LENGTH
+      Resizer.resize!(self)
+    else
+      enforce_field_constraints
+    end
+  end
+
+  def enforce_field_constraints
+    max_fields.each {|k,max| @field_lengths[k] = max if @field_lengths[k].to_i > max }
+  end
+
+  def max_fields
+    @max_fields ||= (@options[:max_fields] ||= {}).each {|k,v|
+      @options[:max_fields][k] = (actual_width * v.to_f.abs).floor if v.to_f.abs < 1
+    }
+  end
+
+  def actual_width
+    @actual_width ||= self.width - (@fields.size * BORDER_LENGTH + 1)
+  end
+
+  def width
+    @width ||= @options[:max_width] || View.width
+  end
+
+  # find max length for each field; start with the headers
+  def default_field_lengths
+    field_lengths = @headers ? @headers.inject({}) {|h,(k,v)| h[k] = String.size(v); h} :
+      @fields.inject({}) {|h,e| h[e] = 1; h }
+    @rows.each do |row|
+      @fields.each do |field|
+        len = String.size(row[field])
+        field_lengths[field] = len if len > field_lengths[field].to_i
+      end
+    end
+    field_lengths
+  end
+
+  def set_filter_defaults(rows)
+    @filter_classes.each do |klass, filter|
+      @fields.each {|field|
+        if rows.all? {|r| r[field].class == klass }
+          @options[:filters][field] ||= filter
+        end
+      }
+    end
+  end
+
+  def filter_values(rows)
+    @filter_classes = Helpers::Table.filter_classes.merge @options[:filter_classes] || {}
+    set_filter_defaults(rows) unless @options[:filter_any]
+    rows.map {|row|
+      @fields.inject({}) {|new_row,f|
+        (filter = @options[:filters][f]) || (@options[:filter_any] && (filter = @filter_classes[row[f].class]))
+        new_row[f] = filter ? call_filter(filter, row[f]) : row[f]
+        new_row
+      }
+    }
+  end
+
+  def call_filter(filter, val)
+    filter.is_a?(Proc) ? filter.call(val) :
+      val.respond_to?(Array(filter)[0]) ? val.send(*filter) : Filters.send(filter, val)
+  end
+
+  def validate_values(rows)
+    rows.each {|row|
+      @fields.each {|f|
+        row[f] = row[f].to_s || ''
+        row[f] = row[f].gsub(/(\t|\r|\n)/) {|e| e.dump.gsub('"','') } if @options[:escape_special_chars]
+      }
+    }
+  end
+  
+  # Converts an array to a hash mapping a numerical index to its array value.
+  def array_to_indices_hash(array)
+    array.inject({}) {|hash,e|  hash[hash.size] = e; hash }
+  end
+  #:startdoc:
+end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table/filters.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table/filters.rb
new file mode 100644
index 0000000..46ba518
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table/filters.rb
@@ -0,0 +1,10 @@
+class Hirb::Helpers::Table
+  # Contains filter methods used by :filters option. To define a custom filter, simply open this module and create a method
+  # that take one argument, the value you will be filtering.
+  module Filters
+    extend self
+    def comma_join(arr) #:nodoc:
+      arr.join(', ')
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table/resizer.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table/resizer.rb
new file mode 100644
index 0000000..eadbc12
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/table/resizer.rb
@@ -0,0 +1,82 @@
+class Hirb::Helpers::Table
+  # Resizes a table's fields to the table's max width.
+  class Resizer
+    # Modifies field_lengths to fit within width. Also enforces a table's max_fields.
+    def self.resize!(table)
+      obj = new(table)
+      obj.resize
+      obj.field_lengths
+    end
+
+    #:stopdoc:
+    attr_reader :field_lengths
+    def initialize(table)
+      @table, @width, @field_size = table, table.actual_width, table.fields.size
+      @field_lengths = table.field_lengths
+      @original_field_lengths = @field_lengths.dup
+    end
+
+    def resize
+      adjust_long_fields || default_restrict_field_lengths
+      @table.enforce_field_constraints
+      add_extra_width
+    end
+
+    # Simple algorithm which allows smaller fields to be displayed while
+    # restricting longer fields to an average_long_field
+    def adjust_long_fields
+      while (total_length = sum(@field_lengths.values)) > @width
+        average_field = total_length / @field_size.to_f
+        long_lengths = @field_lengths.values.select {|e| e > average_field }
+        return false if long_lengths.empty?
+
+        # adjusts average long field by ratio with @width
+        average_long_field = sum(long_lengths)/long_lengths.size * @width/total_length
+        @field_lengths.each {|f,length|
+          @field_lengths[f] = average_long_field if length > average_long_field
+        }
+      end
+      true
+    end
+
+    # Produces a field_lengths which meets the @width requirement
+    def default_restrict_field_lengths
+      original_total_length = sum @original_field_lengths.values
+      # set fields by their relative weight to original length
+      new_lengths = @original_field_lengths.inject({}) {|t,(k,v)|
+        t[k] = (v / original_total_length.to_f * @width).to_i; t  }
+
+      # set all fields the same if relative doesn't work
+      unless new_lengths.values.all? {|e| e > MIN_FIELD_LENGTH} && (sum(new_lengths.values) <= @width)
+        new_lengths = @field_lengths.inject({}) {|t,(k,v)| t[k] = @width / @field_size; t }
+      end
+      @field_lengths.each {|k,v| @field_lengths[k] = new_lengths[k] }
+    end
+
+    def add_extra_width
+      added_width = 0
+      extra_width = @width - sum(@field_lengths.values)
+      unmaxed_fields = @field_lengths.keys.select {|f| !remaining_width(f).zero? }
+      # order can affect which one gets the remainder so let's keep it consistent
+      unmaxed_fields = unmaxed_fields.sort_by {|e| e.to_s}
+
+      unmaxed_fields.each_with_index do |f, i|
+        extra_per_field = (extra_width - added_width) / (unmaxed_fields.size - i)
+        add_to_field = remaining_width(f) < extra_per_field ? remaining_width(f) : extra_per_field
+        added_width += add_to_field
+        @field_lengths[f] += add_to_field
+      end
+    end
+
+    def remaining_width(field)
+      (@remaining_width ||= {})[field] ||= begin
+        (@table.max_fields[field] || @original_field_lengths[field]) - @field_lengths[field]
+      end
+    end
+
+    def sum(arr)
+      arr.inject {|t,e| t += e }
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/tree.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/tree.rb
new file mode 100644
index 0000000..2697423
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/tree.rb
@@ -0,0 +1,181 @@
+# Base tree class which given an array of nodes produces different types of trees.
+# The types of trees currently are:
+# * basic:
+#    0
+#      1
+#        2
+#        3
+#      4
+# 
+# * directory:
+#    0
+#    |-- 1
+#    |   |-- 2
+#    |   `-- 3
+#    `-- 4
+# 
+# * number:
+#    1. 0
+#      1. 1
+#        1. 2
+#        2. 3
+#      2. 4 
+# 
+# Tree nodes can be given as an array of arrays or an array of hashes.
+# To render the above basic tree with an array of hashes:
+#   Hirb::Helpers::Tree.render([{:value=>0, :level=>0}, {:value=>1, :level=>1}, {:value=>2, :level=>2}, 
+#     {:value=>3, :level=>2}, {:value=>4, :level=>1}])
+# Note from the hash keys that :level refers to the depth of the tree while :value refers to the text displayed
+# for a node.
+#
+# To render the above basic tree with an array of arrays:
+#   Hirb::Helpers::Tree.render([[0,0], [1,1], [2,2], [2,3], [1,4]])
+# Note that the each array pair consists of the level and the value for the node.
+class Hirb::Helpers::Tree
+  class ParentlessNodeError < StandardError; end
+
+  class <<self
+    # Main method which renders a tree.
+    # ==== Options:
+    # [:type] Type of tree. Either :basic, :directory or :number. Default is :basic.
+    # [:validate] Boolean to validate tree. Checks to see if all nodes have parents. Raises ParentlessNodeError if
+    #             an invalid node is found. Default is false.
+    # [:indent] Number of spaces to indent between levels for basic + number trees. Default is 4.
+    # [:limit] Limits the level or depth of a tree that is displayed. Root node is level 0.
+    # [:description] Displays brief description about tree ie how many nodes it has.
+    # [:multi_line_nodes] Handles multi-lined nodes by indenting their newlines. Default is false.
+    #  Examples:
+    #     Hirb::Helpers::Tree.render([[0, 'root'], [1, 'child']], :type=>:directory)
+    def render(nodes, options={})
+      new(nodes, options).render
+    end
+  end
+
+  # :stopdoc:
+  attr_accessor :nodes
+  
+  def initialize(input_nodes, options={})
+    @options = options
+    @type = options[:type] || :basic
+    if input_nodes[0].is_a?(Array)
+      @nodes = input_nodes.map {|e| Node.new(:level=>e[0], :value=>e[1]) }
+    else
+      @nodes = input_nodes.map {|e| Node.new(e)}
+    end
+    @nodes.each_with_index {|e,i| e.merge!(:tree=>self, :index=>i)}
+    @nodes.each {|e| e[:value] = e[:value].to_s }
+    validate_nodes if options[:validate]
+    self
+  end
+
+  def render
+    body = render_tree
+    body += render_description if @options[:description]
+    body
+  end
+  
+  def render_description
+    "\n\n#{@nodes.length} #{@nodes.length == 1 ? 'node' : 'nodes'} in tree"
+  end
+
+  def render_tree
+    @indent = ' ' * (@options[:indent] || 4 )
+    @nodes = @nodes.select {|e| e[:level] <= @options[:limit] } if @options[:limit]
+    case @type.to_s
+    when 'directory' then render_directory
+    when 'number'    then render_number
+    else render_basic
+    end
+  end
+
+  def render_nodes
+    value_indent = @options[:multi_line_nodes] ? @indent : nil
+    @nodes.map {|e| yield(e) + e.value(value_indent) }.join("\n")
+  end
+
+  def render_directory
+    mark_last_nodes_per_level
+    render_nodes {|e|
+      value = ''
+      unless e.root?
+        value << e.render_parent_characters
+        value << (e[:last_node] ? "`-- " : "|-- ")
+      end
+      value
+    }
+  end
+  
+  def render_number
+    counter = {}
+    @nodes.each {|e|
+      parent_level_key = "#{(e.parent ||{})[:index]}.#{e[:level]}"
+      counter[parent_level_key] ||= 0
+      counter[parent_level_key] += 1
+      e[:pre_value] = "#{counter[parent_level_key]}. "
+    }
+    render_nodes {|e| @indent * e[:level] + e[:pre_value] }
+  end
+
+  def render_basic
+    render_nodes {|e| @indent * e[:level] }
+  end
+
+  def validate_nodes
+    @nodes.each do |e|
+      raise ParentlessNodeError if (e[:level] > e.previous[:level]) && (e[:level] - e.previous[:level]) > 1
+    end
+  end
+  
+  # walks tree accumulating last nodes per unique parent+level
+  def mark_last_nodes_per_level
+    @nodes.each {|e| e.delete(:last_node)}
+    last_node_hash = @nodes.inject({}) {|h,e|
+      h["#{(e.parent ||{})[:index]}.#{e[:level]}"] = e; h
+    }
+    last_node_hash.values.uniq.each {|e| e[:last_node] = true}
+  end
+  #:startdoc:
+  class Node < ::Hash #:nodoc:
+    class MissingLevelError < StandardError; end
+    class MissingValueError < StandardError; end
+    
+    def initialize(hash)
+      super
+      raise MissingLevelError unless hash.has_key?(:level)
+      raise MissingValueError unless hash.has_key?(:value)
+      replace(hash)
+    end
+
+    def value(indent=nil)
+      indent ? self[:value].gsub("\n", "\n#{indent * self[:level]}") : self[:value]
+    end
+
+    def parent
+      self[:tree].nodes.slice(0 .. self[:index]).reverse.detect {|e| e[:level] < self[:level]}
+    end
+
+    def next
+      self[:tree].nodes[self[:index] + 1]
+    end
+
+    def previous
+      self[:tree].nodes[self[:index] - 1]
+    end
+
+    def root?; self[:level] == 0; end
+
+    # refers to characters which connect parent nodes 
+    def render_parent_characters
+      parent_chars = []
+      get_parents_character(parent_chars)
+      parent_chars.reverse.map {|level| level + ' ' * 3 }.join('')
+    end
+
+    def get_parents_character(parent_chars)
+      if self.parent
+        parent_chars << (self.parent[:last_node] ? ' ' : '|') unless self.parent.root?
+        self.parent.get_parents_character(parent_chars)
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/helpers/vertical_table.rb b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/vertical_table.rb
new file mode 100644
index 0000000..1f18f3e
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/helpers/vertical_table.rb
@@ -0,0 +1,37 @@
+class Hirb::Helpers::VerticalTable < Hirb::Helpers::Table
+
+  # Renders a vertical table using the same options as Hirb::Helpers::Table.render except for the ones below
+  # and :max_fields, :vertical and :max_width which aren't used.
+  # ==== Options:
+  # [:hide_empty] Boolean which hides empty values (nil or '') from being displayed. Default is false.
+  def self.render(rows, options={})
+    new(rows, {:escape_special_chars=>false, :resize=>false}.merge(options)).render
+  end
+
+  #:stopdoc:
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+  end
+
+  def render_header; []; end
+  def render_footer; []; end
+
+  def render_rows
+    i = 0
+    longest_header = Hirb::String.size @headers.values.sort_by {|e| Hirb::String.size(e) }.last
+    stars = "*" * [(longest_header + (longest_header / 2)), 3].max
+    @rows.map do |row|
+      row = "#{stars} #{i+1}. row #{stars}\n" +
+      @fields.map {|f|
+        if !@options[:hide_empty] || (@options[:hide_empty] && !row[f].empty?)
+          "#{Hirb::String.rjust(@headers[f], longest_header)}: #{row[f]}"
+        else
+          nil
+        end
+      }.compact.join("\n")
+      i+= 1
+      row
+    end
+  end
+  #:startdoc:
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/import_object.rb b/lib/bbcloud/vendor/hirb/lib/hirb/import_object.rb
new file mode 100644
index 0000000..8bd0f1f
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/import_object.rb
@@ -0,0 +1,10 @@
+module Hirb
+  module ObjectMethods
+    # Takes same options as Hirb::View.render_output.
+    def view(*args)
+      Hirb::Console.render_output(*(args.unshift(self)))
+    end
+  end
+end
+
+Object.send :include, Hirb::ObjectMethods
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/menu.rb b/lib/bbcloud/vendor/hirb/lib/hirb/menu.rb
new file mode 100644
index 0000000..ffafd14
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/menu.rb
@@ -0,0 +1,221 @@
+module Hirb
+  # This class provides a menu using Hirb's table helpers by default to display choices.
+  # Menu choices (syntax at Hirb::Util.choose_from_array) refer to rows. However, when in
+  # two_d mode, choices refer to specific cells by appending a ':field' to a choice.
+  # A field name can be an abbreviated. Menus can also have an action mode, which turns the
+  # menu prompt into a commandline that executes the choices as arguments and uses methods as
+  # actions/commands.
+  class Menu
+    class Error < StandardError; end
+
+    # Detects valid choices and optional field/column
+    CHOSEN_REGEXP = /^(\d([^:]+)?)(?::)?(\S+)?/
+    CHOSEN_ARG = '%s'
+    DIRECTIONS = "Specify individual choices (4,7), range of choices (1-3) or all choices (*)."
+
+
+    # This method will return an array unless it's exited by simply pressing return, which returns nil.
+    # If given a block, the block will yield if and with any menu items are chosen.
+    # All options except for the ones below are passed to render the menu.
+    #
+    # ==== Options:
+    # [*:helper_class*]  Helper class to render menu. Helper class is expected to implement numbering given a :number option.
+    #                    To use a very basic menu, set this to false. Defaults to Hirb::Helpers::AutoTable.
+    # [*:prompt*]  String for menu prompt. Defaults to "Choose: ".
+    # [*:ask*] Always ask for input, even if there is only one choice. Default is true.
+    # [*:directions*] Display directions before prompt. Default is true.
+    # [*:readline*] Use readline to get user input if available. Input strings are added to readline history. Default is false.
+    # [*:two_d*] Turn menu into a 2 dimensional (2D) menu by allowing user to pick values from table cells. Default is false.
+    # [*:default_field*] Default field for a 2D menu. Defaults to first field in a table.
+    # [*:action*] Turn menu into an action menu by letting user pass menu choices as an argument to a method/command.
+    #             A menu choice's place amongst other arguments is preserved. Default is false.
+    # [*:multi_action*] Execute action menu multiple times iterating over the menu choices. Default is false.
+    # [*:action_object*] Object that takes method/command calls. Default is main.
+    # [*:command*] Default method/command to call when no command given.
+    # [*:reopen*] Reopens $stdin with given file or with /dev/tty when set to true. Use when
+    #             $stdin is already reading in piped data.
+    # Examples:
+    #     >> extend Hirb::Console
+    #     => self
+    #     >> menu [1,2,3], :prompt=> "So many choices, so little time: "
+    #     >> menu [{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:a,b], :two_d=>true)
+    def self.render(output, options={}, &block)
+      new(options).render(output, &block)
+    rescue Error=>e
+      $stderr.puts "Error: #{e.message}"
+    end
+
+    #:stopdoc:
+    def initialize(options={})
+      @options = {:helper_class=>Hirb::Helpers::AutoTable, :prompt=>"Choose: ", :ask=>true,
+        :directions=>true}.merge options
+      @options[:reopen] = '/dev/tty' if @options[:reopen] == true
+    end
+
+    def render(output, &block)
+      @output = Array(output)
+      return [] if @output.size.zero?
+      chosen = choose_from_menu
+      block.call(chosen) if block && chosen.size > 0
+      @options[:action] ? execute_action(chosen) : chosen
+    end
+
+    def get_input
+      prompt = pre_prompt + @options[:prompt]
+      prompt = DIRECTIONS+"\n"+prompt if @options[:directions]
+      $stdin.reopen @options[:reopen] if @options[:reopen]
+
+      if @options[:readline] && readline_loads?
+        get_readline_input(prompt)
+      else
+        print prompt
+        $stdin.gets.chomp.strip
+      end
+    end
+
+    def get_readline_input(prompt)
+      input = Readline.readline prompt
+      Readline::HISTORY << input
+      input
+    end
+
+    def pre_prompt
+      prompt = ''
+      prompt << "Default field: #{default_field}\n" if @options[:two_d] && default_field
+      prompt << "Default command: #{@options[:command]}\n" if @options[:action] && @options[:command]
+      prompt
+    end
+
+    def choose_from_menu
+      return unasked_choice if @output.size == 1 && !@options[:ask]
+
+      if (helper_class = Util.any_const_get(@options[:helper_class]))
+        View.render_output(@output, :class=>@options[:helper_class], :options=>@options.merge(:number=>true))
+      else
+        @output.each_with_index {|e,i| puts "#{i+1}: #{e}" }
+      end
+
+      parse_input get_input
+    end
+
+    def unasked_choice
+      return @output unless @options[:action]
+      raise(Error, "Default command and field required for unasked action menu") unless default_field && @options[:command]
+      @new_args = [@options[:command], CHOSEN_ARG]
+      map_tokens([[@output, default_field]])
+    end
+
+    def execute_action(chosen)
+      return nil if chosen.size.zero?
+      if @options[:multi_action]
+        chosen.each {|e| invoke command, add_chosen_to_args(e) }
+      else
+        invoke command, add_chosen_to_args(chosen)
+      end
+    end
+
+    def invoke(cmd, args)
+      action_object.send(cmd, *args)
+    end
+
+    def parse_input(input)
+      if (@options[:two_d] || @options[:action])
+        tokens = input_to_tokens(input)
+        map_tokens(tokens)
+      else
+        Util.choose_from_array(@output, input)
+      end
+    end
+
+    def map_tokens(tokens)
+      if return_cell_values?
+        @output[0].is_a?(Hash) ? tokens.map {|arr,f| arr.map {|e| e[f]} }.flatten :
+          tokens.map {|arr,f|
+            arr.map {|e| e.is_a?(Array) && f.is_a?(Integer) ? e[f] : e.send(f) }
+          }.flatten
+      else
+        tokens.map {|e| e[0] }.flatten
+      end
+    end
+
+    def return_cell_values?
+      @options[:two_d]
+    end
+
+    def input_to_tokens(input)
+      @new_args = []
+      tokens = (@args = split_input_args(input)).map {|word| parse_word(word) }.compact
+      cleanup_new_args
+      tokens
+    end
+
+    def parse_word(word)
+      if word[CHOSEN_REGEXP]
+        @new_args << CHOSEN_ARG
+        field = $3 ? unalias_field($3) : default_field ||
+          raise(Error, "No default field/column found. Fields must be explicitly picked.")
+        [Util.choose_from_array(@output, word), field ]
+      else
+        @new_args << word
+        nil
+      end
+    end
+
+    def cleanup_new_args
+      if @new_args.all? {|e| e == CHOSEN_ARG }
+        @new_args = [CHOSEN_ARG]
+      else
+        i = @new_args.index(CHOSEN_ARG) || raise(Error, "No rows chosen")
+        @new_args.delete(CHOSEN_ARG)
+        @new_args.insert(i, CHOSEN_ARG)
+      end
+    end
+
+    def add_chosen_to_args(items)
+      args = @new_args.dup
+      args[args.index(CHOSEN_ARG)] = items
+      args
+    end
+
+    def command
+      @command ||= begin
+        cmd = (@new_args == [CHOSEN_ARG]) ? nil : @new_args.shift
+        cmd ||= @options[:command] || raise(Error, "No command given for action menu")
+      end
+    end
+
+    def action_object
+      @options[:action_object] || eval("self", TOPLEVEL_BINDING)
+    end
+
+    def split_input_args(input)
+      input.split(/\s+/)
+    end
+
+    def default_field
+      @default_field ||= @options[:default_field] || fields[0]
+    end
+
+    # Has to be called after displaying menu
+    def fields
+      @fields ||= @options[:fields] || (@options[:ask] && table_helper_class? && Helpers::Table.last_table ?
+        Helpers::Table.last_table.fields[1..-1] : [])
+    end
+
+    def table_helper_class?
+      @options[:helper_class].is_a?(Class) && @options[:helper_class] < Helpers::Table
+    end
+
+    def unalias_field(field)
+      fields.sort_by {|e| e.to_s }.find {|e| e.to_s[/^#{field}/] } || raise(Error, "Invalid field '#{field}'")
+    end
+
+    def readline_loads?
+      require 'readline'
+      true
+    rescue LoadError
+      false
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/pager.rb b/lib/bbcloud/vendor/hirb/lib/hirb/pager.rb
new file mode 100644
index 0000000..8ff1250
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/pager.rb
@@ -0,0 +1,95 @@
+module Hirb
+  # This class provides class methods for paging and an object which can conditionally page given a terminal size that is exceeded.
+  class Pager
+    class<<self
+      # Pages using a configured or detected shell command.
+      def command_pager(output, options={})
+        basic_pager(output) if valid_pager_command?(options[:pager_command])
+      end
+
+      def pager_command(*commands) #:nodoc:
+        @pager_command = (!@pager_command.nil? && commands.empty?) ? @pager_command : 
+          begin
+            commands = [ENV['PAGER'], 'less', 'more', 'pager'] if commands.empty?
+            commands.compact.uniq.find {|e| Util.command_exists?(e[/\w+/]) }
+          end
+      end
+
+      # Pages with a ruby-only pager which either pages or quits.
+      def default_pager(output, options={})
+        pager = new(options[:width], options[:height])
+        while pager.activated_by?(output, options[:inspect])
+          puts pager.slice!(output, options[:inspect])
+          return unless continue_paging?
+        end
+        puts output
+        puts "=== Pager finished. ==="
+      end
+
+      #:stopdoc:
+      def valid_pager_command?(cmd)
+        cmd ? pager_command(cmd) : pager_command
+      end
+
+      private
+      def basic_pager(output)
+        pager = IO.popen(pager_command, "w")
+        begin
+          save_stdout = STDOUT.clone
+          STDOUT.reopen(pager)
+          STDOUT.puts output
+        rescue Errno::EPIPE
+        ensure
+         STDOUT.reopen(save_stdout)
+         save_stdout.close
+         pager.close
+        end
+      end
+
+      def continue_paging?
+        puts "=== Press enter/return to continue or q to quit: ==="
+        !$stdin.gets.chomp[/q/i]
+      end
+      #:startdoc:
+    end
+
+    attr_reader :width, :height
+
+    def initialize(width, height, options={})
+      resize(width, height)
+      @pager_command = options[:pager_command] if options[:pager_command]
+    end
+
+    # Pages given string using configured pager.
+    def page(string, inspect_mode)
+      if self.class.valid_pager_command?(@pager_command)
+        self.class.command_pager(string, :pager_command=>@pager_command)
+      else
+        self.class.default_pager(string, :width=>@width, :height=>@height, :inspect=>inspect_mode)
+      end
+    end
+
+    def slice!(output, inspect_mode=false) #:nodoc:
+      effective_height = @height - 2 # takes into account pager prompt
+      if inspect_mode
+        sliced_output = String.slice(output, 0, @width * effective_height)
+        output.replace String.slice(output, @width * effective_height, String.size(output))
+        sliced_output
+      else
+        # could use output.scan(/[^\n]*\n?/) instead of split
+        sliced_output = output.split("\n").slice(0, effective_height).join("\n")
+        output.replace output.split("\n").slice(effective_height..-1).join("\n")
+        sliced_output
+      end
+    end
+
+    # Determines if string should be paged based on configured width and height.
+    def activated_by?(string_to_page, inspect_mode=false)
+      inspect_mode ? (String.size(string_to_page) > @height * @width) : (string_to_page.count("\n") > @height)
+    end
+
+    def resize(width, height) #:nodoc:
+      @width, @height = View.determine_terminal_size(width, height)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/string.rb b/lib/bbcloud/vendor/hirb/lib/hirb/string.rb
new file mode 100644
index 0000000..0d96585
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/string.rb
@@ -0,0 +1,44 @@
+module Hirb
+  # Provides string helpers to deal with UTF-8 and ruby 1.8.x
+  module String
+    extend self
+    # :stopdoc:
+    if RUBY_VERSION < '1.9'
+      def size(string)
+        string.scan(/./).length
+      end
+
+      def ljust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? string + " " * leftover : string
+      end
+
+      def rjust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? " " * leftover + string : string
+      end
+
+      def slice(string, start, finish)
+        string.scan(/./).slice(start, finish).join('')
+      end
+    else
+      def size(string)
+        string.length
+      end
+
+      def ljust(string, desired_length)
+        string.ljust(desired_length)
+      end
+
+      def rjust(string, desired_length)
+        string.rjust(desired_length)
+      end
+
+      def slice(*args)
+        string = args.shift
+        string.slice(*args)
+      end
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/util.rb b/lib/bbcloud/vendor/hirb/lib/hirb/util.rb
new file mode 100644
index 0000000..2db4b65
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/util.rb
@@ -0,0 +1,96 @@
+module Hirb
+  # Group of handy utility functions used throughout Hirb.
+  module Util
+    extend self
+    # Returns a constant like Module#const_get no matter what namespace it's nested in.
+    # Returns nil if the constant is not found.
+    def any_const_get(name)
+      return name if name.is_a?(Module)
+      begin
+        klass = Object
+        name.split('::').each {|e|
+          klass = klass.const_get(e)
+        }
+        klass
+      rescue
+         nil
+      end
+    end
+
+    # Recursively merge hash1 with hash2.
+    def recursive_hash_merge(hash1, hash2)
+      hash1.merge(hash2) {|k,o,n| (o.is_a?(Hash)) ? recursive_hash_merge(o,n) : n}
+    end
+
+    # From Rails ActiveSupport, converting undescored lowercase to camel uppercase.
+    def camelize(string)
+      string.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
+    end
+
+    # Used by Hirb::Menu to select items from an array. Array counting starts at 1. Ranges of numbers are specified with a '-' or '..'.
+    # Multiple ranges can be comma delimited. Anything that isn't a valid number is ignored. All elements can be returned with a '*'.
+    # Examples:
+    #    1-3,5-6 -> [1,2,3,5,6]
+    #    *   -> all elements in array
+    #    ''  -> [] 
+    def choose_from_array(array, input, options={})
+      options = {:splitter=>","}.merge(options)
+      return array if input.strip == '*'
+      result = []
+      input.split(options[:splitter]).each do |e|
+        if e =~ /-|\.\./
+          min,max = e.split(/-|\.\./)
+          slice_min = min.to_i - 1
+          result.push(*array.slice(slice_min, max.to_i - min.to_i + 1))
+        elsif e =~ /\s*(\d+)\s*/
+          index = $1.to_i - 1
+          next if index < 0
+          result.push(array[index]) if array[index]
+        end
+      end
+      result
+    end
+
+    # Determines if a shell command exists by searching for it in ENV['PATH'].
+    def command_exists?(command)
+      ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
+    end
+
+    # Returns [width, height] of terminal when detected, nil if not detected.
+    # Think of this as a simpler version of Highline's Highline::SystemExtensions.terminal_size()
+    def detect_terminal_size
+      if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
+        [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
+      elsif (RUBY_PLATFORM =~ /java/ || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
+        [`tput cols`.to_i, `tput lines`.to_i]
+      elsif STDIN.tty? && command_exists?('stty')
+        `stty size`.scan(/\d+/).map { |s| s.to_i }.reverse
+      else
+        nil
+      end
+    rescue
+      nil
+    end
+
+    # Captures STDOUT of anything run in its block and returns it as string.
+    def capture_stdout(&block)
+      original_stdout = $stdout
+      $stdout = fake = StringIO.new
+      begin
+        yield
+      ensure
+        $stdout = original_stdout
+      end
+      fake.string
+    end
+
+    # From Rubygems, determine a user's home.
+    def find_home
+      ['HOME', 'USERPROFILE'].each {|e| return ENV[e] if ENV[e] }
+      return "#{ENV['HOMEDRIVE']}#{ENV['HOMEPATH']}" if ENV['HOMEDRIVE'] && ENV['HOMEPATH']
+      File.expand_path("~")
+    rescue
+      File::ALT_SEPARATOR ? "C:/" : "/"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/version.rb b/lib/bbcloud/vendor/hirb/lib/hirb/version.rb
new file mode 100644
index 0000000..9115328
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/version.rb
@@ -0,0 +1,3 @@
+module Hirb
+  VERSION = '0.3.4'
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/view.rb b/lib/bbcloud/vendor/hirb/lib/hirb/view.rb
new file mode 100644
index 0000000..a2cfb92
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/view.rb
@@ -0,0 +1,284 @@
+module Hirb
+  # This class is responsible for managing all view-related functionality.
+  #
+  # == Create a View
+  # Let's create a simple view for Hash objects:
+  #   $ irb -rubygems
+  #   >> require 'hirb'
+  #   =>true
+  #   >> Hirb.enable
+  #   =>nil
+  #   >> require 'yaml'
+  #   =>true
+  #
+  #   # A view method is the smallest view
+  #   >> def yaml(output); output.to_yaml; end
+  #   => nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :method=>:yaml
+  #   => true
+  #
+  #   # Hashes now appear as yaml
+  #   >> {:a=>1, :b=>{:c=>3}}
+  #   ---
+  #   :a : 1
+  #   :b : 
+  #     :c : 3
+  #   => true
+  #
+  # Another way of creating a view is a Helper class:
+  #
+  #   # Create yaml view class
+  #   >> class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   =>nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :class=>Hirb::Helpers::Yaml
+  #   =>true
+  #
+  #   # Hashes appear as yaml like above ...
+  #
+  # == Configure a View
+  # To configure the above Helper class as a view, either pass Hirb.enable a hash:
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable :output=>{"Hash"=>{:class=>"Hirb::Helpers::Yaml"}}
+  #
+  # Or create a config file at config/hirb.yml or ~/.hirb.yml:
+  #   # The config file for the yaml example would look like:
+  #   # ---
+  #   # :output :
+  #   #   Hash :
+  #   #    :class : Hirb::Helpers::Yaml
+  #
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable
+  #
+  # For more about configuring Hirb, see the Config Files section in Hirb.
+  module View
+    DEFAULT_WIDTH = 120
+    DEFAULT_HEIGHT = 40
+    class<<self
+      attr_accessor :render_method
+      attr_reader :config
+
+      # This activates view functionality i.e. the formatter, pager and size detection. If irb exists, it overrides irb's output
+      # method with Hirb::View.view_output. When called multiple times, new configs are merged into the existing config.
+      # If using Wirble, you should call this after it. The view configuration can be specified in a hash via a config file,
+      # or as options to this method. In addition to the config keys mentioned in Hirb, options also take the following keys:
+      # ==== Options:
+      # * config_file: Name of config file(s) that are merged into existing config
+      # * output_method: Specify an object's class and instance method (separated by a period) to be realiased with
+      #   hirb's view system. The instance method should take a string to be output. Default is IRB::Irb.output_value
+      #   if using irb.
+      # Examples:
+      #   Hirb.enable
+      #   Hirb.enable :formatter=>false, :output_method=>"Mini.output"
+      def enable(options={}, &block)
+        Array(options.delete(:config_file)).each {|e|
+          @new_config_file = true
+          Hirb.config_files << e
+        }
+        enable_output_method(options.delete(:output_method))
+        merge_or_load_config options
+        resize(config[:width], config[:height])
+        @enabled = true
+      end
+
+      # Indicates if Hirb::View is enabled.
+      def enabled?
+        @enabled || false
+      end
+
+      # Disable's Hirb's output and revert's irb's output method if irb exists.
+      def disable
+        @enabled = false
+        unalias_output_method(@output_method) if @output_method
+        false
+      end
+
+      # Toggles pager on or off. The pager only works while Hirb::View is enabled.
+      def toggle_pager
+        config[:pager] = !config[:pager]
+      end
+
+      # Toggles formatter on or off.
+      def toggle_formatter
+        config[:formatter] = !config[:formatter]
+      end
+
+      # Resizes the console width and height for use with the table and pager i.e. after having resized the console window. *nix users
+      # should only have to call this method. Non-*nix users should call this method with explicit width and height. If you don't know
+      # your width and height, in irb play with "a"* width to find width and puts "a\n" * height to find height.
+      def resize(width=nil, height=nil)
+        config[:width], config[:height] = determine_terminal_size(width, height)
+        pager.resize(config[:width], config[:height])
+      end
+      
+      # This is the main method of this class. When view is enabled, this method searches for a formatter it can use for the output and if
+      # successful renders it using render_method(). The options this method takes are helper config hashes as described in 
+      # Hirb::Formatter.format_output(). Returns true if successful and false if no formatting is done or if not enabled.
+      def view_output(output, options={})
+        enabled? && config[:formatter] && render_output(output, options)
+      rescue Exception=>e
+        if config[:ignore_errors]
+          $stderr.puts "Hirb Error: #{e.message}"
+          false
+        else
+          index = (obj = e.backtrace.find {|f| f =~ /^\(eval\)/}) ? e.backtrace.index(obj) : e.backtrace.length
+          $stderr.puts "Hirb Error: #{e.message}", e.backtrace.slice(0,index).map {|e| "    " + e }
+          true
+        end
+      end
+
+      # Captures STDOUT and renders it using render_method(). The main use case is to conditionally page captured stdout.
+      def capture_and_render(&block)
+        render_method.call Util.capture_stdout(&block)
+      end
+
+      # A lambda or proc which handles the final formatted object.
+      # Although this pages/puts the object by default, it could be set to do other things
+      # i.e. write the formatted object to a file.
+      def render_method
+        @render_method ||= default_render_method
+      end
+
+      # Resets render_method back to its default.
+      def reset_render_method
+        @render_method = default_render_method
+      end
+      
+      # Current console width
+      def width
+        config && config[:width] ? config[:width] : DEFAULT_WIDTH
+      end
+
+      # Current console height
+      def height
+        config && config[:height] ? config[:height] : DEFAULT_HEIGHT
+      end
+
+      # Current formatter config, storing a hash of all static views
+      def formatter_config
+        formatter.config
+      end
+
+      # Adds a view when View is enabled. See Formatter.add_view for more details.
+      def add(klass, view_config)
+        if enabled?
+          formatter.add_view(klass, view_config)
+        else
+          puts "View must be enabled to add a view"
+        end
+      end
+
+      #:stopdoc:
+      def enable_output_method(meth)
+        if (meth ||= Object.const_defined?(:IRB) ? "IRB::Irb.output_value" : false) && !@output_method
+          @output_method = meth
+          alias_output_method(@output_method)
+        end
+      end
+
+      def unalias_output_method(output_method)
+        klass, klass_method = output_method.split(".")
+        eval %[
+          ::#{klass}.class_eval do
+            alias_method :#{klass_method}, :non_hirb_view_output
+          end
+        ]
+        @output_method = nil
+      end
+
+      def alias_output_method(output_method)
+        klass, klass_method = output_method.split(".")
+        eval %[
+          ::#{klass}.class_eval do
+            alias_method :non_hirb_view_output, :#{klass_method}
+            if '#{klass}' == "IRB::Irb"
+              def #{klass_method} #:nodoc:
+                Hirb::View.view_output(@context.last_value) || Hirb::View.page_output(@context.last_value.inspect, true) ||
+                  non_hirb_view_output
+              end
+            else
+              def #{klass_method}(output_string) #:nodoc:
+                Hirb::View.view_output(output_string) || Hirb::View.page_output(output_string.inspect, true) ||
+                  non_hirb_view_output(output_string)
+              end
+            end
+          end
+        ]
+      end
+
+      def render_output(output, options={})
+        if (formatted_output = formatter.format_output(output, options))
+          render_method.call(formatted_output)
+          true
+        else
+          false
+        end
+      end
+
+      def determine_terminal_size(width, height)
+        detected  = (width.nil? || height.nil?) ? Util.detect_terminal_size || [] : []
+        [width || detected[0] || DEFAULT_WIDTH , height || detected[1] || DEFAULT_HEIGHT]
+      end
+
+      def page_output(output, inspect_mode=false)
+        if enabled? && config[:pager] && pager.activated_by?(output, inspect_mode)
+          pager.page(output, inspect_mode)
+          true
+        else
+          false
+        end
+      end
+
+      def pager
+        @pager ||= Pager.new(config[:width], config[:height], :pager_command=>config[:pager_command])
+      end
+
+      def pager=(value); @pager = value; end
+
+      def formatter(reload=false)
+        @formatter = reload || @formatter.nil? ? Formatter.new(config[:output]) : @formatter
+      end
+
+      def formatter=(value); @formatter = value; end
+
+      def merge_or_load_config(additional_config={})
+        if @config && (@new_config_file || !additional_config.empty?)
+          Hirb.config = nil
+          load_config Util.recursive_hash_merge(@config, additional_config)
+          @new_config_file = false
+        elsif !@enabled
+          load_config(additional_config)
+        end
+      end
+
+      def load_config(additional_config={})
+        @config = Util.recursive_hash_merge default_config, additional_config
+        formatter(true)
+        true
+      end
+
+      def config_loaded?; !!@config; end
+
+      def config
+        @config
+      end
+      
+      def default_render_method
+        lambda {|output| page_output(output) || puts(output) }
+      end
+
+      def default_config
+        Util.recursive_hash_merge({:pager=>true, :formatter=>true}, Hirb.config || {})
+      end
+      #:startdoc:
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/views.rb b/lib/bbcloud/vendor/hirb/lib/hirb/views.rb
new file mode 100644
index 0000000..330a802
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/views.rb
@@ -0,0 +1,8 @@
+module Hirb
+  # Namespace for Helpers defining multiple views in a module i.e. via DynamicView.
+  module Views
+    module Single #:nodoc:
+    end
+  end
+end
+%w{rails orm mongo_db couch_db misc_db}.each {|e| require "hirb/views/#{e}" }
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/views/couch_db.rb b/lib/bbcloud/vendor/hirb/lib/hirb/views/couch_db.rb
new file mode 100644
index 0000000..ad4ef11
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/views/couch_db.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::CouchDb #:nodoc:
+  def default_couch(obj)
+    {:fields=>([:_id] + obj.class.properties.map {|e| e.name }) }
+  end
+
+  alias_method :couch_rest__extended_document_view, :default_couch
+  alias_method :couch_foo__base_view, :default_couch
+  alias_method :couch_potato__persistence_view, :default_couch
+end
+
+Hirb::DynamicView.add Hirb::Views::CouchDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/views/misc_db.rb b/lib/bbcloud/vendor/hirb/lib/hirb/views/misc_db.rb
new file mode 100644
index 0000000..48f8d1b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/views/misc_db.rb
@@ -0,0 +1,15 @@
+module Hirb::Views::MiscDb #:nodoc:
+  def friendly__document_view(obj)
+    {:fields=>obj.class.attributes.keys - [:id]}
+  end
+
+  def ripple__document_view(obj)
+    {:fields=>obj.class.properties.keys}
+  end
+
+  def d_b_i__row_view(obj)
+    {:fields=>obj.column_names, :table_class=>Hirb::Helpers::Table}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::MiscDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/views/mongo_db.rb b/lib/bbcloud/vendor/hirb/lib/hirb/views/mongo_db.rb
new file mode 100644
index 0000000..a79d35b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/views/mongo_db.rb
@@ -0,0 +1,14 @@
+module Hirb::Views::MongoDb #:nodoc:
+  def mongoid__document_view(obj)
+    {:fields=>['_id'] + obj.class.fields.keys}
+  end
+
+  def mongo_mapper__document_view(obj)
+    fields = obj.class.column_names
+    fields.delete('_id') && fields.unshift('_id')
+    {:fields=>fields}
+  end
+  alias_method :mongo_mapper__embedded_document_view, :mongo_mapper__document_view
+end
+
+Hirb::DynamicView.add Hirb::Views::MongoDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/views/orm.rb b/lib/bbcloud/vendor/hirb/lib/hirb/views/orm.rb
new file mode 100644
index 0000000..ded4b9b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/views/orm.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::ORM #:nodoc:
+  def data_mapper__resource_view(obj)
+    {:fields=>obj.class.properties.map {|e| e.name }}
+  end
+
+  def sequel__model_view(obj)
+    {:fields=>obj.class.columns}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::ORM, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb/lib/hirb/views/rails.rb b/lib/bbcloud/vendor/hirb/lib/hirb/views/rails.rb
new file mode 100644
index 0000000..03105ff
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb/lib/hirb/views/rails.rb
@@ -0,0 +1,19 @@
+module Hirb::Views::Rails #:nodoc:
+  def active_record__base_view(obj)
+    {:fields=>get_active_record_fields(obj)}
+  end
+
+  def get_active_record_fields(obj)
+    fields = obj.class.column_names.map {|e| e.to_sym }
+    # if query used select
+    if obj.attributes.keys.sort != obj.class.column_names.sort
+      selected_columns = obj.attributes.keys
+      sorted_columns = obj.class.column_names.dup.delete_if {|e| !selected_columns.include?(e) }
+      sorted_columns += (selected_columns - sorted_columns)
+      fields = sorted_columns.map {|e| e.to_sym}
+    end
+    fields
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::Rails, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/ini-0.1.1/.require_paths b/lib/bbcloud/vendor/ini-0.1.1/.require_paths
new file mode 100644
index 0000000..e875275
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/.require_paths
@@ -0,0 +1,3 @@
+lib
+test
+bin
diff --git a/lib/bbcloud/vendor/ini-0.1.1/README b/lib/bbcloud/vendor/ini-0.1.1/README
new file mode 100644
index 0000000..1e69cfe
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/README
@@ -0,0 +1,113 @@
+
+= Conventional INI File Parsing and Writing
+
+== Introduction
+
+Ah yes, INI files. We love them. We hate them. We cannot escape
+them. Originally made popular by Windows, INI files are everywhere
+including in Samba[www.samba.org] and Trac[trac.edgewall.org]. This
+gem has one goal: make INI file, structure, and stream manipulation
+as fast, safe, and simple as possible. We take a modal approach
+with a pluggable parser class.
+
+== Sample File
+
+  ; some comment about section1
+  [section1]
+  var1 = foo
+  var2 = doodle
+
+  [section2]
+
+  ; some comment about var1
+  var1 = baz
+
+  ; some comment about var2    
+  var2 = shoodle
+
+== Conventional Format
+
+There is no formal INI specification but most parsers observe the
+following so we do also by default:
+
+=== Sections
+
+Section declarations are wrapped in square brackets
+(<tt>[section1]</tt>) with no spaces surrounding the section
+name. Duplicate sections are discouraged but if included are merged.
+
+=== Parameters
+
+The <tt>var1 = foo</tt> above is an example of a parameter, also
+frequently referred to a property, item, or pair.  Each parameter is
+made up of a key name (<tt>var1</tt>), an equals sign (<tt>=</tt>),
+and a value (<tt>foo</tt>) with optional spaces. Leading spaces
+before the key name are allowed and leading spaces before or after
+the value are trimmed. Values are literally the characters that
+remain, even if quoted (<tt>var1 = "foo"</tt> would include the
+quotes in the value). Duplicate parameters, either in the same
+section or merged duplicate sections, play 'last one wins'.
+
+=== Comments
+
+All lines starting with a semicolon (<tt>;</tt>) are assumed to be
+comments and are ignored. This character must be the first on the line.
+
+=== Blank Lines
+
+All lines that contain nothing but spaces are ignored.
+
+=== Line Endings
+
+Lines end at either a CRLF or just a LF (CR=\015, LF=\012). Files
+may mix the two within the same file to accomodate edits from
+different platforms.
+
+=== Format Variations Supported
+
+Because INI format is not formally specified, many variations exist
+in the wild. Some of these are supported by extra parsers that are
+included and set by changing the <tt>mode</tt> of the <ini> instance.
+
+To maintain backward compatibility with the original 'inifile' gem,
+the following variations are supported by the default parser: 
+
+* <b>Comments:</b> the comment character can be specified when an instance is created
+* <b>Parameters:</b> separator character can be specified when an instance is created
+* <b>Duplicate Sections:</b> merged
+* <b>Duplicate Parameters:</b> the last one wins
+
+=== Currently Unsupported Format Variations
+
+If it isn't listed above, chances are it isn't supported. But here
+are some specific variations in case you are wondering (and, yes,
+we do have plans eventually support them, either as defaults or options):
+
+* Parameter value continuation with backslash (<tt>\\</tt>)
+* Parameter value double-quoting with escapes (<tt>foo = "value with \\n in it"</tt>)
+* Parameter values using braces (<tt>{}</tt>)
+* Parameter values using simple commas parsing into arrays
+
+== Copyright and License
+
+Copyright (c) 2006-2007 The 'ini' and 'inifile' Gem Team
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/lib/ini.rb b/lib/bbcloud/vendor/ini-0.1.1/lib/ini.rb
new file mode 100644
index 0000000..00a1859
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/lib/ini.rb
@@ -0,0 +1,264 @@
+# $Id: ini.rb 1 2007-01-17 15:21:30Z ironmo $
+
+#
+# This class represents the INI file and can be used to parse, modify,
+# and write INI files.
+#
+class Ini
+
+  # :stopdoc:
+  class Error < StandardError; end
+  # :startdoc:
+
+  #
+  # call-seq:
+  #    IniFile.load( filename )
+  #    IniFile.load( filename, options )
+  #
+  # Open the given _filename_ and load the contetns of the INI file.
+  # The following _options_ can be passed to this method:
+  #
+  #    :comment => ';'      The line comment character(s)
+  #    :parameter => '='    The parameter / value separator
+  #
+  def self.load( filename, opts = {} )
+    new(filename, opts)
+  end
+
+  #
+  # call-seq:
+  #    IniFile.new( filename )
+  #    IniFile.new( filename, options )
+  #
+  # Create a new INI file using the given _filename_. If _filename_
+  # exists and is a regular file, then its contents will be parsed.
+  # The following _options_ can be passed to this method:
+  #
+  #    :comment => ';'      The line comment character(s)
+  #    :parameter => '='    The parameter / value separator
+  #
+  def initialize( filename, opts = {} )
+    @fn = filename
+    @comment = opts[:comment] || ';'
+    @param = opts[:parameter] || '='
+    @ini = Hash.new {|h,k| h[k] = Hash.new}
+
+    @rgxp_comment = %r/\A\s*\z|\A\s*[#{@comment}]/
+    @rgxp_section = %r/\A\s*\[([^\]]+)\]/o
+    @rgxp_param   = %r/\A([^#{@param}]+)#{@param}(.*)\z/
+
+    parse
+  end
+
+  #
+  # call-seq:
+  #    write
+  #    write( filename )
+  #
+  # Write the INI file contents to the filesystem. The given _filename_
+  # will be used to write the file. If _filename_ is not given, then the
+  # named used when constructing this object will be used.
+  #
+  def write( filename = nil )
+    @fn = filename unless filename.nil?
+
+    ::File.open(@fn, 'w') do |f|
+      @ini.each do |section,hash|
+        f.puts "[#{section}]"
+        hash.each {|param,val| f.puts "#{param} #{@param} #{val}"}
+        f.puts
+      end
+    end
+    self
+  end
+  alias :save :write
+
+  #
+  # call-seq:
+  #    each {|section, parameter, value| block}
+  #
+  # Yield each _section_, _parameter_, _value_ in turn to the given
+  # _block_. The method returns immediately if no block is supplied.
+  #
+  def each
+    return unless block_given?
+    @ini.each do |section,hash|
+      hash.each do |param,val|
+        yield section, param, val
+      end
+    end
+    self
+  end
+
+  #
+  # call-seq:
+  #    each_section {|section| block}
+  #
+  # Yield each _section_ in turn to the given _block_. The method returns
+  # immediately if no block is supplied.
+  #
+  def each_section
+    return unless block_given?
+    @ini.each_key {|section| yield section}
+    self
+  end
+
+  #
+  # call-seq:
+  #    delete_section( section )
+  #
+  # Deletes the named _section_ from the INI file. Returns the
+  # parameter / value pairs if the section exists in the INI file. Otherwise,
+  # returns +nil+.
+  #
+  def delete_section( section )
+    @ini.delete section.to_s
+  end
+
+  #
+  # call-seq:
+  #    ini_file[section]
+  #
+  # Get the hash of parameter/value pairs for the given _section_. If the
+  # _section_ hash does not exist it will be created.
+  #
+  def []( section )
+    return nil if section.nil?
+    @ini[section.to_s]
+  end
+
+  #
+  # call-seq:
+  #    has_section?( section )
+  #
+  # Returns +true+ if the named _section_ exists in the INI file.
+  #
+  def has_section?( section )
+    @ini.has_key? section.to_s
+  end
+
+  #
+  # call-seq:
+  #    sections
+  #
+  # Returns an array of the section names.
+  #
+  def sections
+    @ini.keys
+  end
+
+  #
+  # call-seq:
+  #    freeze
+  #
+  # Freeze the state of the +IniFile+ object. Any attempts to change the
+  # object will raise an error.
+  #
+  def freeze
+    super
+    @ini.each_value {|h| h.freeze}
+    @ini.freeze
+    self
+  end
+
+  #
+  # call-seq:
+  #    taint
+  #
+  # Marks the INI file as tainted -- this will traverse each section marking
+  # each section as tainted as well.
+  #
+  def taint
+    super
+    @ini.each_value {|h| h.taint}
+    @ini.taint
+    self
+  end
+
+  #
+  # call-seq:
+  #    dup
+  #
+  # Produces a duplicate of this INI file. The duplicate is independent of the
+  # original -- i.e. the duplicate can be modified without changing the
+  # orgiinal. The tainted state of the original is copied to the duplicate.
+  #
+  def dup
+    other = super
+    other.instance_variable_set(:@ini, Hash.new {|h,k| h[k] = Hash.new})
+    @ini.each_pair {|s,h| other[s].merge! h}
+    other.taint if self.tainted?
+    other
+  end
+
+  #
+  # call-seq:
+  #    clone
+  #
+  # Produces a duplicate of this INI file. The duplicate is independent of the
+  # original -- i.e. the duplicate can be modified without changing the
+  # orgiinal. The tainted state and the frozen state of the original is copied
+  # to the duplicate.
+  #
+  def clone
+    other = dup
+    other.freeze if self.frozen?
+    other
+  end
+
+  #
+  # call-seq:
+  #    eql?( other )
+  #
+  # Returns +true+ if the _other_ object is equivalent to this INI file. For
+  # two INI files to be equivalent, they must have the same sections with  the
+  # same parameter / value pairs in each section.
+  #
+  def eql?( other )
+    return true if equal? other
+    return false unless other.instance_of? self.class
+    @ini == other.instance_variable_get(:@ini)
+  end
+  alias :== :eql?
+
+
+  private
+  #
+  # call-seq
+  #    parse
+  #
+  # Parse the ini file contents.
+  #
+  def parse
+    return unless ::Kernel.test ?f, @fn
+    section = nil
+
+    ::File.open(@fn, 'r') do |f|
+      while line = f.gets
+        line = line.chomp
+
+        case line
+        # ignore blank lines and comment lines
+        when @rgxp_comment: next
+
+        # this is a section declaration
+        when @rgxp_section: section = @ini[$1.strip]
+
+        # otherwise we have a parameter
+        when @rgxp_param
+          begin
+            section[$1.strip] = $2.strip
+          rescue NoMethodError
+            raise Error, "parameter encountered before first section"
+          end
+
+        else
+          raise Error, "could not parse line '#{line}"
+        end
+      end  # while
+    end  # File.open
+  end
+
+end
+
+# EOF
diff --git a/lib/bbcloud/vendor/ini-0.1.1/lib/inifile.rb b/lib/bbcloud/vendor/ini-0.1.1/lib/inifile.rb
new file mode 100644
index 0000000..d82f808
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/lib/inifile.rb
@@ -0,0 +1,10 @@
+# $Id: inifile.rb 1 2007-01-17 15:21:30Z ironmo $
+
+# The 'inifile' gem will eventually be deprecated in favor of the
+# 'ini' gem as it becomes able to handle streams, stringio and string buffers of INI
+# formatted data.
+
+require 'ini'
+
+class IniFile < Ini
+end
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_1.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_1.ini
new file mode 100644
index 0000000..15d3325
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_1.ini
@@ -0,0 +1,6 @@
+; having a paramater / value pair outside a section is an error
+one = 1
+
+[section_one]
+one = 1
+two = 2
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_2.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_2.ini
new file mode 100644
index 0000000..0e3bac8
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/bad_2.ini
@@ -0,0 +1,6 @@
+[section_one]
+one = 1
+two = 2
+
+; the following is not a valid line
+invalid line
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/comment.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/comment.ini
new file mode 100644
index 0000000..52b9855
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/comment.ini
@@ -0,0 +1,5 @@
+# comments should be ignored
+[section_one]
+one = 1
+two = 2
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/good.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/good.ini
new file mode 100644
index 0000000..ca9ac05
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/good.ini
@@ -0,0 +1,17 @@
+[section_one]
+one = 1
+two = 2
+
+[section_two]
+three =         3    
+
+; comments should be ignored
+[section three]
+four   =4
+five=5
+six =6
+
+[section_four]
+   [section_five]
+ seven and eight= 7 & 8
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/mixed_comment.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/mixed_comment.ini
new file mode 100644
index 0000000..77ed510
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/mixed_comment.ini
@@ -0,0 +1,7 @@
+# comments should be ignored
+; multiple comments characeters are supported
+; (I'm lookin' at you, samba)
+[section_one]
+one = 1
+two = 2
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/data/param.ini b/lib/bbcloud/vendor/ini-0.1.1/test/data/param.ini
new file mode 100644
index 0000000..0700f6b
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/data/param.ini
@@ -0,0 +1,5 @@
+; comments should be ignored
+[section_one]
+one : 1
+two:2
+
diff --git a/lib/bbcloud/vendor/ini-0.1.1/test/test_inifile.rb b/lib/bbcloud/vendor/ini-0.1.1/test/test_inifile.rb
new file mode 100644
index 0000000..b5d764c
--- /dev/null
+++ b/lib/bbcloud/vendor/ini-0.1.1/test/test_inifile.rb
@@ -0,0 +1,277 @@
+# Code Generated by ZenTest v. 3.3.0
+#                 classname: asrt / meth =  ratio%
+#             Rini::IniFile:    0 /    9 =   0.00%
+
+begin
+  require 'inifile'
+rescue LoadError
+  require 'rubygems'
+  require 'inifile'
+end
+
+begin; require 'turn'; rescue LoadError; end
+require 'test/unit' unless defined? $ZENTEST and $ZENTEST
+
+class TestIniFile < Test::Unit::TestCase
+
+  def setup
+    @ini_file = ::IniFile.new 'test/data/good.ini'
+    @contents = [
+      ['section_one', 'one', '1'],
+      ['section_one', 'two', '2'],
+      ['section_two', 'three', '3'],
+      ['section three', 'four', '4'],
+      ['section three', 'five', '5'],
+      ['section three', 'six', '6'],
+      ['section_five', 'seven and eight', '7 & 8']
+    ].sort
+  end
+
+  def test_class_load
+    ini_file = ::IniFile.load 'test/data/good.ini'
+    assert_instance_of ::IniFile, ini_file
+
+    # see if we can parse different style comments
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/comment.ini'}
+
+    ini_file = ::IniFile.load 'test/data/comment.ini', :comment => '#'
+    assert_instance_of ::IniFile, ini_file
+
+    # see if we can parse mixed style comments
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/mixed_comment.ini'}
+
+    ini_file = ::IniFile.load 'test/data/mixed_comment.ini', :comment => ';#'
+    assert_instance_of ::IniFile, ini_file
+
+    # see if we can parse different style param separators
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/param.ini'}
+
+    ini_file = ::IniFile.load 'test/data/param.ini', :parameter => ':'
+    assert_instance_of ::IniFile, ini_file
+
+    # make sure we error out on files with bad lines
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/bad_1.ini'}
+    assert_raise(::IniFile::Error) {::IniFile.load 'test/data/bad_2.ini'}
+  end
+
+  def test_clone
+    clone = @ini_file.clone
+    assert_equal @ini_file, clone
+    assert !clone.tainted?
+    assert !clone.frozen?
+
+    # the clone should be completely independent of the original
+    clone['new_section']['one'] = 1
+    assert_not_equal @ini_file, clone
+
+    # the tainted state is copied to clones
+    @ini_file.taint
+    assert @ini_file.tainted?
+
+    clone = @ini_file.clone
+    assert clone.tainted?
+
+    # the frozen state is also copied to clones
+    @ini_file.freeze
+    assert @ini_file.frozen?
+
+    clone = @ini_file.clone
+    assert clone.tainted?
+    assert clone.frozen?
+  end
+
+  def test_delete_section
+    assert_nil @ini_file.delete_section('section_nil')
+
+    h = {'one' => '1', 'two' => '2'}
+    assert_equal true, @ini_file.has_section?('section_one')
+    assert_equal h, @ini_file.delete_section('section_one')
+    assert_equal false, @ini_file.has_section?('section_one')
+    assert_nil @ini_file.delete_section('section_one')
+  end
+
+  def test_dup
+    dup = @ini_file.dup
+    assert_equal @ini_file, dup
+    assert !dup.tainted?
+    assert !dup.frozen?
+
+    # the duplicate should be completely independent of the original
+    dup['new_section']['one'] = 1
+    assert_not_equal @ini_file, dup
+
+    # the tainted state is copied to duplicates
+    @ini_file.taint
+    assert @ini_file.tainted?
+
+    dup = @ini_file.dup
+    assert dup.tainted?
+
+    # the frozen state, however, is not
+    @ini_file.freeze
+    assert @ini_file.frozen?
+
+    dup = @ini_file.dup
+    assert dup.tainted?
+    assert !dup.frozen?
+  end
+
+  def test_each
+    ary = []
+    @ini_file.each {|*args| ary << args}
+
+    assert_equal @contents, ary.sort
+
+    ary = []
+    ::IniFile.new('temp.ini').each {|*args| ary << args}
+    assert_equal [], ary
+  end
+
+  def test_each_section
+    expected = [
+      'section_one', 'section_two', 'section three',
+      'section_four', 'section_five'
+    ].sort
+
+    ary = []
+    @ini_file.each_section {|section| ary << section}
+
+    assert_equal expected, ary.sort
+
+    ary = []
+    ::IniFile.new('temp.ini').each_section {|section| ary << section}
+    assert_equal [], ary
+  end
+
+  def test_eql_eh
+    assert @ini_file.eql?(@ini_file)
+    assert @ini_file.eql?(@ini_file.clone)
+    assert !@ini_file.eql?('string')
+    assert !@ini_file.eql?(IniFile.new(''))
+  end
+
+  def test_freeze
+    assert_equal false, @ini_file.frozen?
+    @ini_file.each_section do |s|
+      assert_equal false, @ini_file[s].frozen?
+    end
+
+    @ini_file.freeze
+
+    assert_equal true, @ini_file.frozen?
+    @ini_file.each_section do |s|
+      assert_equal true, @ini_file[s].frozen?
+    end
+  end
+
+  def test_has_section_eh
+    assert_equal true,  @ini_file.has_section?('section_one')
+    assert_equal false, @ini_file.has_section?('section_ten')
+    assert_equal true,  @ini_file.has_section?(:section_two)
+    assert_equal false, @ini_file.has_section?(nil)
+
+    ini_file = ::IniFile.new 'temp.ini'
+    assert_equal false, ini_file.has_section?('section_one')
+    assert_equal false, ini_file.has_section?('one')
+    assert_equal false, ini_file.has_section?('two')
+  end
+
+  def test_index
+    expected = {
+      'one' => '1',
+      'two' => '2'
+    }
+    assert_equal expected, @ini_file[:section_one]
+
+    expected = {'three' => '3'}
+    assert_equal expected, @ini_file['section_two']
+
+    expected = {
+      'four' => '4',
+      'five' => '5',
+      'six'  => '6',
+    }
+    assert_equal expected, @ini_file['section three']
+
+    expected = {}
+    assert_equal expected, @ini_file['section_four']
+
+    expected = {'seven and eight' => '7 & 8'}
+    assert_equal expected, @ini_file['section_five']
+
+    expected = {}
+    assert_equal expected, @ini_file['section_six']
+
+    assert_nil @ini_file[nil]
+
+    expected = {}
+    ini_file = ::IniFile.new 'temp.ini'
+    assert_equal expected, ini_file['section_one']
+    assert_equal expected, ini_file['one']
+    assert_nil ini_file[nil]
+  end
+
+  def test_initialize
+    # see if we can parse different style comments
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/comment.ini'}
+
+    ini_file = ::IniFile.new 'test/data/comment.ini', :comment => '#'
+    assert_equal true, ini_file.has_section?('section_one')
+
+    # see if we can parse different style param separators
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/param.ini'}
+
+    ini_file = ::IniFile.new 'test/data/param.ini', :parameter => ':'
+    assert_equal true, ini_file.has_section?('section_one')
+    assert_equal '1', ini_file['section_one']['one']
+    assert_equal '2', ini_file['section_one']['two']
+
+    # make sure we error out on files with bad lines
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/bad_1.ini'}
+    assert_raise(::IniFile::Error) {::IniFile.new 'test/data/bad_2.ini'}
+  end
+
+  def test_sections
+    expected = [
+      'section_one', 'section_two', 'section three',
+      'section_four', 'section_five'
+    ].sort
+
+    assert_equal expected, @ini_file.sections.sort
+
+    ini_file = ::IniFile.new 'temp.ini'
+    assert_equal [], ini_file.sections
+  end
+
+  def test_taint
+    assert_equal false, @ini_file.tainted?
+    @ini_file.each_section do |s|
+      assert_equal false, @ini_file[s].tainted?
+    end
+
+    @ini_file.taint
+
+    assert_equal true, @ini_file.tainted?
+    @ini_file.each_section do |s|
+      assert_equal true, @ini_file[s].tainted?
+    end
+  end
+
+  def test_write
+    tmp = 'test/data/temp.ini'
+    ::File.delete tmp if ::Kernel.test(?f, tmp)
+
+    @ini_file.save tmp
+    assert_equal true, ::Kernel.test(?f, tmp)
+
+    ::File.delete tmp if ::Kernel.test(?f, tmp)
+
+    ini_file = ::IniFile.new tmp
+    ini_file.save
+    assert_nil ::Kernel.test(?s, tmp)
+
+    ::File.delete tmp if ::Kernel.test(?f, tmp)
+  end
+end
+
+# EOF
